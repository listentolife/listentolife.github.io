<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Listentolife&apos;s Blog">
<meta name="keywords" content="HTML CSS JavaScript">
<meta property="og:type" content="website">
<meta property="og:title" content="Listentolife">
<meta property="og:url" content="http://listentolife.github.io/index.html">
<meta property="og:site_name" content="Listentolife">
<meta property="og:description" content="Listentolife&apos;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Listentolife">
<meta name="twitter:description" content="Listentolife&apos;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://listentolife.github.io/"/>





  <title>Listentolife</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Listentolife</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">简单就好</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archive" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/06/09/work-summary6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/work-summary6/" itemprop="url">工作总结(6)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-09T22:38:28+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结，主要针对移动端网页开发中遇到的软键盘坑来整理的。</p>
<p>最近在做移动端页面，然后遇到一个很多人都遇到的坑：当页面有固定在底部的评论框的情况下，当点击评论框获得聚焦之后，底部评论框会被软键盘顶起，但是不会贴着软键盘顶部，而且后面的页面也会向上滚动一定高度，而且仍然可以滚动。这个问题的结果就是，在评论框获得聚焦时，整个页面会滚动，输入框位置很突兀，如果输入框是textarea，则有可能有一部分推到页面顶部一样，用户体验非常差。</p>
<p>这个问题拆解出来，有几个需要解决的问题：</p>
<ol>
<li><p>背景页面仍然可以滚动。我尝试了增加遮罩层，但是还是不受控制；</p>
</li>
<li><p>底部评论框顶起的位置不正确。这个问题在安卓系统不会出现，所以是iOS的坑；</p>
</li>
<li><p>底部评论框获得聚焦的时候，背景页面会被顶起。</p>
</li>
</ol>
<p>这个坑我在网上找了很多帖子，发现真的是一个很难解决的问题。我也有找到一些解决方案，但是实际实现下来效果还是很差。这里我们一个个问题来整理如何解决。</p>
<h4 id="背景页面滚动问题"><a href="#背景页面滚动问题" class="headerlink" title="背景页面滚动问题"></a>背景页面滚动问题</h4><p>这个问题不管在安卓还是iOS系统上都会出现。原因应该出现在本身页面高度超过窗口高度，而且移动端有touchmove事件，虽然有遮罩层，但是其实body是遮罩层的根节点，所以存在事件捕获跟冒泡的问题。</p>
<p>因此，主要的问题是要阻止touchmove事件。解决方案需要完成两步操作：</p>
<h5 id="1-禁止body的touch事件。这样可以确保touchmove事件不会从body元素开始捕获"><a href="#1-禁止body的touch事件。这样可以确保touchmove事件不会从body元素开始捕获" class="headerlink" title="1. 禁止body的touch事件。这样可以确保touchmove事件不会从body元素开始捕获"></a>1. 禁止body的touch事件。这样可以确保touchmove事件不会从body元素开始捕获</h5><p>处理的办法是设置body元素的touchAction属性为<code>none</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.style.touchAction = &apos;none&apos;;</span><br></pre></td></tr></table></figure>
<p>这样就可以禁止body的touch事件。不过这个只是适用于安卓系统，在safari上并不适用，因为safari不支持该属性</p>
<h5 id="2-阻止body发生默认的行为。这样可以保证touchmove事件不会触发body元素的滚动"><a href="#2-阻止body发生默认的行为。这样可以保证touchmove事件不会触发body元素的滚动" class="headerlink" title="2. 阻止body发生默认的行为。这样可以保证touchmove事件不会触发body元素的滚动"></a>2. 阻止body发生默认的行为。这样可以保证touchmove事件不会触发body元素的滚动</h5><p>处理的办法是使用<code>e.preventDefault()</code>，同时在绑定<code>addEventListener</code>的时候，需要再传一个<code>options</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&apos;touchmove&apos;, this.stopTouch, &#123; passive: false, capture: true &#125;);</span><br><span class="line"></span><br><span class="line">stopTouch (e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addEventListener</code>的第三个参数<code>options</code>的写法比较少用到，我们一般用到的是<code>useCapture</code>，而且一般也是使用默认值<code>false</code>。在MDN有详细的说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">options</span><br><span class="line">一个指定有关 listener 属性的可选参数对象。可用的选项如下：</span><br><span class="line">capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</span><br><span class="line">once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。</span><br><span class="line">passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</span><br></pre></td></tr></table></figure>
<p>我们在这里使用<code>{ passive: false }</code>，这样使用<code>preventDefault()</code>时Chrome等一些浏览器就不会报错；而使用<code>{ capture: true }</code>则可以是事件尽早被阻止。</p>
<p>第一个问题完整的解决方案代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    show(newVal) &#123;</span><br><span class="line">        this.toggleContainerTouchAction(newVal);</span><br><span class="line">        if (newVal) &#123;</span><br><span class="line">            document.body.addEventListener(&apos;touchmove&apos;, this.stopTouch, &#123; passive: false, capture: true &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            document.body.removeEventListener(&apos;touchmove&apos;, this.stopTouch, &#123; capture: true &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method: &#123;</span><br><span class="line">    toggleContainerTouchAction (flag) &#123;</span><br><span class="line">        document.body.style.touchAction = flag ? &apos;none&apos; : &apos;auto&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopTouch (e) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="底部评论框顶起的位置"><a href="#底部评论框顶起的位置" class="headerlink" title="底部评论框顶起的位置"></a>底部评论框顶起的位置</h4><p>首先，这个问题的根本问题是iOS在处理fixed布局时，当页面输入框获得焦点的时候，会把fixed改成absolute绝对定位，同时计算fixed容器在页面的位置，以此作为绝对定位的位置。正常来说其实会让底部评论框顶到软键盘顶部的位置，虽然如果滚动页面的话底部评论框是会跟软键盘分开，但是上面已经有解决方案了，所以其实还好。问题在于因为在软键盘上滑的同时，页面整体也会被动向上滚动，但评论框的位置是在页面滚动前计算的，所以才会出现顶起后还跟软键盘分离的情况。</p>
<p>因此，首先可以想到的是，不用fixed布局，而改用absolute布局，同时在输入框获得焦点的时候，动态计算输入框容器的高度。</p>
<p>不过直接放弃fixed布局其实是很可惜的，因为如果一开始写布局的时候就用绝对定位，那底部评论框就得一直动态计算位置，而且这个问题只是iOS系统才会出现，安卓系统是没问题的。</p>
<p>所以在处理的时候，我把问题拆分了：</p>
<ol>
<li>输入框在布局上，iOS跟安卓是分开处理的；</li>
<li>其次，iOS系统的布局，也按软键盘调起(等同于输入框获得焦点)与否分开处理；</li>
<li>因为页面滚动已经被设置为不可滚动，所以动态计算可以控制在一定次数以内。这三个优化可以让方案实施时减少JS的操作，提高页面性能，增加CSS样式操作。</li>
</ol>
<h5 id="1-样式布局"><a href="#1-样式布局" class="headerlink" title="1. 样式布局"></a>1. 样式布局</h5><p>样式布局上，我把fixed布局跟absolute布局从原来class<code>.input-container</code>中分离出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.input-container-absolute &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.input-container-fixed &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    bottom: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过<code>v-bind</code>先把<code>.input-container-fixed</code>绑到输入框容器上。当输入框获得焦点的时候，判断平台是iOS还是安卓，如果是iOS，就改成<code>.input-container-absolute</code>，如果是安卓，就不变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleComment () &#123;</span><br><span class="line">    if (this.tp.platformInfo === &apos;iOS&apos;) &#123;</span><br><span class="line">        this.inputCls = &apos;input-container-absolute input-container&apos;;</span><br><span class="line">		/* ... */</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*...*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>当输入框失去焦点的时候，再改回fixed布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleBlur () &#123;</span><br><span class="line">    if (this.tp.platformInfo === &apos;iOS&apos;) &#123;</span><br><span class="line">        /* ... */</span><br><span class="line">		this.$refs.inputCon.style.top = &apos;&apos;;</span><br><span class="line">        this.inputCls = &apos;input-container-fixed input-container&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这样对于安卓系统来说，解决iOS系统的js操作跟安卓系统来说一点影响都没有。</p>
<h5 id="2-iOS系统的布局"><a href="#2-iOS系统的布局" class="headerlink" title="2. iOS系统的布局"></a>2. iOS系统的布局</h5><p>其实上面的代码也基本说明了，在iOS系统上，布局也不是完全使用绝对布局，就上面的代码，就可以保证在软键盘没有被调起的时候，不需要js控制布局。</p>
<h5 id="3-动态计算"><a href="#3-动态计算" class="headerlink" title="3. 动态计算"></a>3. 动态计算</h5><p>这个问题是整个问题的核心点。首先，使用什么值来确定输入框的位置。因为使用了绝对定位，而且这个位置问题其实是y轴上滚动造成的，所以问题缩小为<code>top</code>跟<code>bottom</code>的选择上。一般fixed布局使用<code>bottom</code>，绝对定位也使用<code>bottom</code>可以统一定位方式，但是实际在<code>.input-container-fixed</code>跟<code>.input-container-absolute</code>的样式上，其实已经说明了绝对定位时，我是选择<code>top</code>来控制输入框的位置的。因为我在尝试使用<code>bottom</code>，发现计算不出来，尴尬…</p>
<p>所以我是计算了<code>top</code>。怎么计算？我们这么考虑，应该是这样的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top = 页面滚动高度 + 视窗高度 - 输入框容器高度</span><br></pre></td></tr></table></figure>
<p>首先，页面滚动高度可以通过<code>document.documentElement.scrollTop</code>或<code>document.body.scrollTop</code>获得；输入框是在软键盘的顶部，而且其实当软键盘调起之后，实际的视窗高度是原来视窗高度减去软键盘高度。这部分不需要计算，直接使用<code>window.innerHeight</code>；输入框容器高度可以通过<code>offsetHeight</code>获得。因此，公式转换成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top = document.documentElement.scrollTop/document.body.scrollTop + window.innerHeight - this.$refs.input.offsetHeight</span><br></pre></td></tr></table></figure>
<p>这里简单说一下，bottom的计算我就是用上面的公式，就是不减去容器高度而已，但是显示效果就是不对…</p>
<p>所以就有下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">getScrollTop () &#123;</span><br><span class="line">    let scroll_top = 0;</span><br><span class="line">    if (document.documentElement &amp;&amp; document.documentElement.scrollTop) &#123;</span><br><span class="line">        scroll_top = document.documentElement.scrollTop;</span><br><span class="line">    &#125; else if (document.body) &#123;</span><br><span class="line">        scroll_top = document.body.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    return scroll_top;</span><br><span class="line">&#125;,</span><br><span class="line">		  </span><br><span class="line">handleScroll () &#123;</span><br><span class="line">    if (this.commentVisible) &#123;</span><br><span class="line">        this.scrollHeight = this.getScrollTop();</span><br><span class="line">		// +5px是为了确保输入框跟软键盘是贴在一起的，所以让输入框有一点点藏在软键盘下面是最保险的做法</span><br><span class="line">        this.$refs.inputCon.style.top = `$&#123;this.scrollHeight + window.innerHeight - this.$refs.inputCon.offsetHeight + 5&#125;px`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>其实直接使用上面的代码也不能解决，因为软键盘弹出是有时间的，也就是如果一获取焦点就计算，那就会导致输入框还在软键盘弹出前视窗的底部。所以要动态计算，即在一定时间内，需要使用定时器<code>setInterval</code>不断计算输入框的位置，这样在软键盘调起的过程，输入框也能一直附在软键盘顶部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scrollContent () &#123;</span><br><span class="line">    clearInterval(this.interval);</span><br><span class="line">    let i = 0;</span><br><span class="line">    this.interval = setInterval(() =&gt; &#123;</span><br><span class="line">        this.handleScroll();</span><br><span class="line">        i++;</span><br><span class="line">        if (i &gt; 20) &#123;</span><br><span class="line">            this.clearSrcoll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 50)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这里控制了只计算20次，是因为软键盘被调起的时间其实很短，测试情况大概1秒内就可以完成，不用一直动态计算，而且定时器间隔时间是50，所以就计算为20次。</p>
<p>因此，样式布局的方法就得增加一些代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">clearSrcoll() &#123;</span><br><span class="line">    clearInterval(this.interval);</span><br><span class="line">&#125;,</span><br><span class="line">		  </span><br><span class="line">handleComment () &#123;</span><br><span class="line">    if (this.tp.platformInfo === &apos;iOS&apos;) &#123;</span><br><span class="line">        this.inputCls = &apos;input-container-absolute input-container&apos;;</span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">            this.scrollContent();</span><br><span class="line">        &#125;, 10)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*...*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">handleBlur () &#123;</span><br><span class="line">    if (this.tp.platformInfo === &apos;iOS&apos;) &#123;</span><br><span class="line">        /* ... */</span><br><span class="line">		this.clearSrcoll();</span><br><span class="line">		this.$refs.inputCon.style.top = &apos;&apos;;</span><br><span class="line">        this.inputCls = &apos;input-container-fixed input-container&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这里要说明的是，跟业务代码是有不同的，因为实际上页面一开始放的评论框容器没有input标签，只是放了一个像输入框的底部容器，加了点击事件后，会控制显示输入框容器的显示，然后在DOM刷新之后(<code>this.$nextTick</code>)使用<code>focus()</code>触发输入框获得焦点。所以就不放完整代码了。</p>
<h4 id="页面顶起"><a href="#页面顶起" class="headerlink" title="页面顶起"></a>页面顶起</h4><p>这个问题其实没有解决，考虑到影响不大，而且当页面高度只有一屏时，也不会出现(主要是没有找到很好的解决方案)，所以就不处理了。但是这个问题在其他情况下有解决方案，详情可以看工作总结(五)中关于iOS下微信H5页面的坑解决方案的整理。</p>
<p>上面就是全部内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/06/09/work-summary5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/work-summary5/" itemprop="url">工作总结(5)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-09T22:35:28+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇总结主要涉及微信H5开发中的比较重要的内容，整理下来也是为了以后可以方便开发。</p>
<p>其实微信接口的使用在微信公众号文档中都有详细的讲解，所以我会整理工作中使用微信接口的代码逻辑。所有代码都是在Vuejs框架下开发的。</p>
<h3 id="微信网页授权"><a href="#微信网页授权" class="headerlink" title="微信网页授权"></a>微信网页授权</h3><p>微信网页授权是微信H5中最为重要的，因为如果授权不成功，用户也进不了页面中来。</p>
<p>微信网页授权分两种情况，用scope来体现：当scope为<code>snsapi_base</code>时，网页授权可以获得用户的openid，而且是静默授权，并自动跳转到回调页中，相当于直接进入H5页面中；当scope为<code>snsapi_userinfo</code>时，网页授权可以获得用户的基本信息，但是需要用户手动同意。还有一种是涉及用户关注公众号的，暂且不提。这里我们主要也是整理前一种网页授权方式。</p>
<p>微信公众号文档中对网页授权流程有分步骤，按照以获取用户openid为目的，操作就是引导用户打开以下链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// appid为公众号唯一标识</span><br><span class="line">// redirect_uri是授权后重定向的回调链接，对应业务链接</span><br><span class="line">// response_type是返回类型，请填写code</span><br><span class="line">// scope是授权类型</span><br><span class="line">// state为可选的参数，重定向后会带上，业务可以带一些参数</span><br><span class="line">// #wechat_redirect是无论直接打开还是做页面302重定向时候，必须带此参数</span><br><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</span><br></pre></td></tr></table></figure>
<p>然后静默获得用户授权之后，会跳转到以下链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// redirect_uri是重定向的回调链接</span><br><span class="line">// code是换取access_token的票据</span><br><span class="line">// state是网页授权时带上的可选参数</span><br><span class="line">redirect_uri/?code=CODE&amp;state=STATE</span><br></pre></td></tr></table></figure>
<p>我在搜索相关开发博客的时候也有看到在前端完成上面跳转的，简单说就是先判断链接是否带有code参数，没有的话就把<code>window.location.href</code>指向网页授权链接，重定向之后获得code参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.wxCode = this.$route.query.code ? code : &apos;&apos;;</span><br><span class="line">let local = window.location.href;</span><br><span class="line">if (this.wxCode == null || this.wxCode === &apos;&apos;) &#123; // 如果获取不到code，则重定向</span><br><span class="line">    window.location.href = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;APPID&#125;&amp;redirect_uri=$&#123;encodeURIComponent(local)&#125;&amp;response_type=$&#123;this.wxCode&#125;&amp;scope=$&#123;wxConfig.scope&#125;#wechat_redirect`;</span><br><span class="line">&#125; else &#123; </span><br><span class="line">    // 如果获取到code，发请求后端</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是实际开发中我们并没有在前端做这部分内容，而且交给后端做重定向。因为网页授权链接中带有appid，是公众号唯一标识，比较重要，考虑到保险起见，不放在前端代码中。</p>
<p>上面的代码可以看到，获取code之后，还需要后端获取access_token。文档也有提到，这部分安全级别非常高，涉及公众号secret跟用户的access_token，所以不允许在客户端请求。因此，获得code之后，我们可以把code通过接口传到服务器，在服务器进行access_token的获取。这一步可以获取到用户的openid，这个openid是用户跟公众号唯一的openid，所以非常有用。所以最终的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    inWx () &#123; // 判断是否在微信环境中</span><br><span class="line">        const userAgent = navigator.userAgent.toLowerCase();</span><br><span class="line">        return  /micromessenger/.test(userAgent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">created () &#123;</span><br><span class="line">    if (this.inWx) &#123;</span><br><span class="line">        this.initInfo();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    initInfo () &#123;</span><br><span class="line">        this.wxCode = this.$route.query.code;</span><br><span class="line">        // 由于是后端实现网页重定向跟授权的，所以其实前端只要获得code并发起请求传给服务器就可以了</span><br><span class="line">        /* ... */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="微信SDK"><a href="#微信SDK" class="headerlink" title="微信SDK"></a>微信SDK</h3><p>首先，使用微信sdk的前提是域名已绑定微信公众号。然后步骤是：引入js文件，通过config配置权限，通过ready接口跟error接口处理验证，最后用checkJsApi接口判断接口支持情况。</p>
<h4 id="引入js文件"><a href="#引入js文件" class="headerlink" title="引入js文件"></a>引入js文件</h4><p>在html文件中引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">// 或</span><br><span class="line">// &lt;script src=&quot;http://res2.wx.qq.com/open/js/jweixin-1.4.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">// 都支持https</span><br></pre></td></tr></table></figure>
<h4 id="config配置"><a href="#config配置" class="headerlink" title="config配置"></a>config配置</h4><p>根据微信公众号文档，config配置需要以下字段：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> wx.config(&#123;</span><br><span class="line">    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">    appId: &apos;&apos;, // 必填，公众号的唯一标识</span><br><span class="line">    timestamp: , // 必填，生成签名的时间戳</span><br><span class="line">    nonceStr: &apos;&apos;, // 必填，生成签名的随机串</span><br><span class="line">    signature: &apos;&apos;,// 必填，签名</span><br><span class="line">    jsApiList: [] // 必填，需要使用的JS接口列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 由于appid是公众号唯一标识，最好不要存放在客户端，所以可以通过请求从服务器获得除debug跟jsApiList之外的信息。所以会分两步走：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        jsApiList: [</span><br><span class="line">            &apos;updateAppMessageShareData&apos;, </span><br><span class="line">            &apos;updateTimelineShareData&apos;, </span><br><span class="line">            &apos;onMenuShareTimeline&apos;, </span><br><span class="line">            &apos;onMenuShareAppMessage&apos;, </span><br><span class="line">            &apos;onMenuShareQQ&apos;, </span><br><span class="line">            &apos;onMenuShareWeibo&apos;,</span><br><span class="line">            &apos;onMenuShareQZone&apos;, </span><br><span class="line">            &apos;previewImage&apos;, </span><br><span class="line">            &apos;openLocation&apos;, </span><br><span class="line">            &apos;getLocation&apos;</span><br><span class="line">        ],</span><br><span class="line">        checkResult: &#123;&#125;,</span><br><span class="line">        wxShareConfig: &#123;&#125;,</span><br><span class="line">        wxconfig_share: &#123;</span><br><span class="line">            title: &apos;&apos;, // 分享标题</span><br><span class="line">            desc: &apos;&apos;, // 分享描述</span><br><span class="line">            link: &apos;&apos;, // 分享链接</span><br><span class="line">            imgUrl: &apos;&apos;, // 分享图标</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">     getWechatConfig () &#123;</span><br><span class="line">        axios.get(api).then(res =&gt; &#123;</span><br><span class="line">            this.wxConfig = res.data;</span><br><span class="line">		    this.wxInit(this.wxConfig);</span><br><span class="line">	    &#125;).catch(error =&gt; &#123;</span><br><span class="line">            /* ... */</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">    wxInit(_rpdata) &#123;</span><br><span class="line">        // this.jsApiList = _rpdata.jsApiList;</span><br><span class="line">        wx.config(&#123;</span><br><span class="line">            debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">            appId: _rpdata.appId, // 必填，公众号的唯一标识</span><br><span class="line">            timestamp: _rpdata.timeStamp, // 必填，生成签名的时间戳</span><br><span class="line">            nonceStr: _rpdata.nonceStr, // 必填，生成签名的随机串</span><br><span class="line">            signature: _rpdata.signature, // 必填，签名，见附录1</span><br><span class="line">            jsApiList: this.jsApiList // 必填，需要使用的JS接口列表</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ready接口跟error接口处理"><a href="#ready接口跟error接口处理" class="headerlink" title="ready接口跟error接口处理"></a>ready接口跟error接口处理</h4><p> 在传入config之后，可以直接调用ready接口处理验证成功的，而error接口则是处理验证失败的情况：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    wxInit(_rpdata) &#123;</span><br><span class="line">        // this.jsApiList = _rpdata.jsApiList;</span><br><span class="line">        wx.config(&#123;</span><br><span class="line">            debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">            appId: _rpdata.appId, // 必填，公众号的唯一标识</span><br><span class="line">            timestamp: _rpdata.timeStamp, // 必填，生成签名的时间戳</span><br><span class="line">            nonceStr: _rpdata.nonceStr, // 必填，生成签名的随机串</span><br><span class="line">            signature: _rpdata.signature, // 必填，签名，见附录1</span><br><span class="line">            jsApiList: this.jsApiList // 必填，需要使用的JS接口列表</span><br><span class="line">        &#125;);</span><br><span class="line">        wx.ready(() =&gt; &#123;</span><br><span class="line">            /* ... */</span><br><span class="line">        &#125;);</span><br><span class="line">        wx.error(function (res) &#123;</span><br><span class="line">            /* ... */</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="checkJsApi接口"><a href="#checkJsApi接口" class="headerlink" title="checkJsApi接口"></a>checkJsApi接口</h3><p> 验证成功之后，还需要调用checkJsApi接口来判断客户端是否支持指定JS接口：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">wxInit(_rpdata) &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">    wx.ready(() =&gt; &#123;</span><br><span class="line">        wx.checkJsApi(&#123;</span><br><span class="line">            this.checkJsApi().then(() =&gt; &#123;</span><br><span class="line">                /* ... */</span><br><span class="line">				/* 这里就可以调用各种验证成功的接口了 */</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">checkJsApi() &#123;</span><br><span class="line">    return new Promise((resolve) =&gt; &#123;</span><br><span class="line">        wx.checkJsApi(&#123;</span><br><span class="line">            jsApiList: this.jsApiList, // 需要检测的JS接口列表，所有JS接口列表见附录2,</span><br><span class="line">            success: (res) =&gt; &#123;</span><br><span class="line">                console.log(res)</span><br><span class="line">                console.log(res.checkResult)</span><br><span class="line">                this.checkResult = res.checkResult;</span><br><span class="line">                // 以键值对的形式返回，可用的api值true，不可用为false</span><br><span class="line">                // 如：&#123;&quot;checkResult&quot;:&#123;&quot;chooseImage&quot;:true&#125;,&quot;errMsg&quot;:&quot;checkJsApi:ok&quot;&#125;</span><br><span class="line">                this.checkResult = res.checkResult;</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p> 以上完成微信SDK基础配置处理。</p>
<h3 id="微信分享"><a href="#微信分享" class="headerlink" title="微信分享"></a>微信分享</h3><p> 微信分享这块包括了所有分享的平台，使用的也是微信SDK所提供的所有分享相关的接口。目前微信分享有以下这些接口：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> updateAppMessageShareData // 分享给朋友及分享到QQ接口</span><br><span class="line">updateTimelineShareData // 分享到朋友圈及分享到QQ空间接口</span><br><span class="line">onMenuShareTimeline // 分享到朋友圈接口(即将废弃)</span><br><span class="line">onMenuShareAppMessage // 分享给朋友接口(即将废弃)</span><br><span class="line">onMenuShareQQ // 分享到QQ接口(即将废弃)</span><br><span class="line">onMenuShareWeibo // 分享到腾讯微博</span><br><span class="line">onMenuShareQZone // 分享到QQ空间</span><br></pre></td></tr></table></figure>
<p> 所有接口的写法基本相同，所有这里只列举一个接口的写法作为例子。通过上面的接口验证后，就可以调用这些接口了。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> wxShareInit() &#123;</span><br><span class="line">    const checkResult = this.checkResult;</span><br><span class="line">    if (checkResult.updateAppMessageShareData) &#123;</span><br><span class="line">        wx.updateAppMessageShareData(&#123;</span><br><span class="line">            title: this.wxconfig_share.title, // 分享标题</span><br><span class="line">            desc: this.wxconfig_share.desc, // 分享描述</span><br><span class="line">            link: this.wxconfig_share.link, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致</span><br><span class="line">            imgUrl: this.wxconfig_share.imgUrl, // 分享图标</span><br><span class="line">            success: function () &#123;</span><br><span class="line">                // 用户确认分享后执行的回调函数</span><br><span class="line">                console.log(&apos;share AppMessage success!&apos;)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">	// 其他接口写法相同</span><br><span class="line">	/*...*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="微信关注"><a href="#微信关注" class="headerlink" title="微信关注"></a>微信关注</h3><p>微信关注这个比较容易，其实就是跳转到历史消息页面，如果用户没有关注公众号的话，这个页面会显示关注按钮。这个链接的形式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=xxxxxxxx#wechat_redirect</span><br></pre></td></tr></table></figure>
<p>其中，xxxxxxxx用公众号的uin id的base64编码替换。这个公众号的uin id可以在微信公众平台登入账号后，在源代码中查找uin即可找到一串数字，然后把这串数字用base64编码，获得。</p>
<p>不过实际的效果是这个页面的关注按钮有时会出现，有时没有，后来网上查了一下，这个页面的关注按钮已经被微信屏蔽了，除非跟微信投钱合作，才会显示。所以……</p>
<h3 id="微信关注判断"><a href="#微信关注判断" class="headerlink" title="微信关注判断"></a>微信关注判断</h3><p>微信关注的判断目前我还没有做过，但是大致的了解到判断的方案。最关键的是需要获得openid，获得access_token，然后通过获取用户基本信息接口获得用户信息，进而判断。</p>
<p>首先，获得openid的方法已经在微信网页授权一节有说明，故可以获得；获得access_token需要前端获取code，然后传给服务器去换access_token，所以这一步也在微信网页授权一节有说明，故也可以获得。</p>
<p>获取用户基本信息接口为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// http请求方式: GET</span><br><span class="line">https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</span><br></pre></td></tr></table></figure>
<p>然后根据微信公众号开发文档所介绍的，返回的数据有这些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;subscribe&quot;: 1, </span><br><span class="line">    &quot;openid&quot;: &quot;o6_bmjrPTlm6_2sgVt7hMZOPfL2M&quot;, </span><br><span class="line">    &quot;nickname&quot;: &quot;Band&quot;, </span><br><span class="line">    &quot;sex&quot;: 1, </span><br><span class="line">    &quot;language&quot;: &quot;zh_CN&quot;, </span><br><span class="line">    &quot;city&quot;: &quot;广州&quot;, </span><br><span class="line">    &quot;province&quot;: &quot;广东&quot;, </span><br><span class="line">    &quot;country&quot;: &quot;中国&quot;, </span><br><span class="line">    &quot;headimgurl&quot;:&quot;http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</span><br><span class="line">    &quot;subscribe_time&quot;: 1382694957,</span><br><span class="line">    &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">    &quot;remark&quot;: &quot;&quot;,</span><br><span class="line">    &quot;groupid&quot;: 0,</span><br><span class="line">    &quot;tagid_list&quot;:[128,2],</span><br><span class="line">    &quot;subscribe_scene&quot;: &quot;ADD_SCENE_QR_CODE&quot;,</span><br><span class="line">    &quot;qr_scene&quot;: 98765,</span><br><span class="line">    &quot;qr_scene_str&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以获得到不少的信息了，这里我们关注的是<code>subscribe</code>这个字段，是指用户是否订阅该公众号标识。0为未关注，1为已关注。这样，我们就可以判断用户是否关注公众号了。</p>
<h3 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h3><p>微信支付有两种方案，一种是依赖上面的微信JS-SDK，再配置完成之后调用chooseWXPay方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 官方文档</span><br><span class="line">wx.chooseWXPay(&#123;</span><br><span class="line">    timestamp: 0, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符</span><br><span class="line">    nonceStr: &apos;&apos;, // 支付签名随机串，不长于 32 位</span><br><span class="line">    package: &apos;&apos;, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\*\*\*）</span><br><span class="line">    signType: &apos;&apos;, // 签名方式，默认为&apos;SHA1&apos;，使用新版支付需传入&apos;MD5&apos;</span><br><span class="line">    paySign: &apos;&apos;, // 支付签名</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">        // 支付成功后的回调函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以参考上面微信分享一节的封装方案进行开发。</p>
<p>另一种方案是调用在微信内置浏览器才有的WeixinJSBridge内置对象。这种方案使用起来比较简单，不需要引入什么，配置什么，只要是在微信内置浏览器中，就一定能调用这个内置对象。使用的时候只要先判断是否存在WeixinJSBridge内置对象，存在则可以传入请求参数，然后再判断返回的支付信息。需要传入的参数跟上面的一样，一般需要发起支付请求给服务器，让服务器提供需要的参数，然后在去调用WeixinJSBridge内置对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 微信支付api相关配置文档</span><br><span class="line">onBridgeReady (data) &#123;</span><br><span class="line">    if (typeof WeixinJSBridge === &apos;undefined&apos;) &#123;</span><br><span class="line">    this.$toast(&#123;</span><br><span class="line">        message: &apos;请使用微信内置浏览器进行支付&apos;,</span><br><span class="line">        position: &apos;bottom&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        WeixinJSBridge.invoke(</span><br><span class="line">            &apos;getBrandWCPayRequest&apos;,</span><br><span class="line">            &#123;</span><br><span class="line">                appId: data.appId, // 公众号名称，由商户传入</span><br><span class="line">                timeStamp: data.timeStamp, // 时间戳，自1970年以来的秒数</span><br><span class="line">                nonceStr: data.nonceStr, // 随机串</span><br><span class="line">                package: data.package,</span><br><span class="line">                signType: data.signType, // 微信签名方式：</span><br><span class="line">                paySign: data.paySign // 微信签名</span><br><span class="line">            &#125;,</span><br><span class="line">            res =&gt; &#123;</span><br><span class="line">                if (res.err_msg === &apos;get_brand_wcpay_request:ok&apos;) &#123;</span><br><span class="line">                    this.$toast(&#123;</span><br><span class="line">                        message: &apos;支付成功&apos;,</span><br><span class="line">                        position: &apos;bottom&apos;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    /* ... */</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    this.$toast(&#123;</span><br><span class="line">                        message: &apos;支付失败&apos;,</span><br><span class="line">                        position: &apos;bottom&apos;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="微信地图"><a href="#微信地图" class="headerlink" title="微信地图"></a>微信地图</h3><p>在微信H5中调起微信地图也是一个常见的功能点，也是可以通过微信JS-SDK的接口来实现。</p>
<p>一般使用微信地图分两种情况：一种是需要打开已知地点的微信地图，方便用户对地点进行导航；另一种是需要打开用户所在位置的微信地图。</p>
<h4 id="已知地点的微信地图"><a href="#已知地点的微信地图" class="headerlink" title="已知地点的微信地图"></a>已知地点的微信地图</h4><p>这里使用的为微信JS-SDK 中的openLocation接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 官方文档</span><br><span class="line">wx.openLocation(&#123;</span><br><span class="line">    latitude: 0, // 纬度，浮点数，范围为90 ~ -90</span><br><span class="line">    longitude: 0, // 经度，浮点数，范围为180 ~ -180。</span><br><span class="line">    name: &apos;&apos;, // 位置名</span><br><span class="line">    address: &apos;&apos;, // 地址详情说明</span><br><span class="line">    scale: 1, // 地图缩放级别,整形值,范围从1~28。默认为最大</span><br><span class="line">    infoUrl: &apos;&apos; // 在查看位置界面底部显示的超链接,可点击跳转</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>根据官方文档，我们需要拿到已知地点的纬度，经度，位置名跟地址详情说明。我们可以通过以下网页获得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.gpsspg.com/maps.htm</span><br></pre></td></tr></table></figure>
<p>然后参考前面微信分享的封装进行开发。</p>
<h4 id="打开用户所在位置的微信地图"><a href="#打开用户所在位置的微信地图" class="headerlink" title="打开用户所在位置的微信地图"></a>打开用户所在位置的微信地图</h4><p>这里还需要使用另一个接口：getLocation接口。也很简单，这里直接贴代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wx.getLocation(&#123;</span><br><span class="line">    type: &apos;gcj02&apos;,</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">         wx.openLocation(&#123;</span><br><span class="line">            latitude: res.latitude,</span><br><span class="line">            longitude: res.longitude,</span><br><span class="line">            name: config.name,</span><br><span class="line">            address: config.address,</span><br><span class="line">            scale: 28,</span><br><span class="line">            infoUrl: &apos;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    cancel: function (res) &#123;</span><br><span class="line">        console.log(&apos;cancel: &apos;, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="微信H5的坑"><a href="#微信H5的坑" class="headerlink" title="微信H5的坑"></a>微信H5的坑</h3><h4 id="iOS中微信环境下页面有浮框软键盘隐藏后页面不能点击问题"><a href="#iOS中微信环境下页面有浮框软键盘隐藏后页面不能点击问题" class="headerlink" title="iOS中微信环境下页面有浮框软键盘隐藏后页面不能点击问题"></a>iOS中微信环境下页面有浮框软键盘隐藏后页面不能点击问题</h4><p>问题是这样的：浮框中有输入框，使用了fixed布局，可能在页面正中间，也可能出现在页面底部。当输入框失去焦点时，软键盘隐藏，但是页面所有点击事件都发生错乱。</p>
<p>其实和这个问题跟iOS系统有关，也跟微信有关。本身iOS系统下调出软键盘就会影响页面布局，然后滚动页面，然后微信内置浏览器会在软键盘隐藏时恢复页面布局，但是并没有恢复监听事件的位置。也就是在虽然有监听事件的标签元素恢复到原位了，但是监听的区域并没有恢复，因为受到页面滚动的影响。</p>
<p>如何处理？分两种情况：一种情况是浮框只出现在页面第一屏，这种情况下，在软键盘隐藏的同时，操作页面滚动到顶部，即可恢复正常的监听区域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollBack () &#123; // 绑定在blur事件上</span><br><span class="line">    window.scrollTo(0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种情况是浮框在底部，这种情况主要跟iOS系统有关，会单独放在下一篇工作总结中详细整理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/05/06/work-summary4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/work-summary4/" itemprop="url">工作总结(4)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T23:28:05+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结，会整理一些比较零散的开发内容。</p>
<h3 id="Element-UI相关"><a href="#Element-UI相关" class="headerlink" title="Element-UI相关"></a>Element-UI相关</h3><h4 id="el-scrollbar组件"><a href="#el-scrollbar组件" class="headerlink" title="el-scrollbar组件"></a>el-scrollbar组件</h4><p>在查ElementUI官方文档的时候，你会发现找不到滚动相关的组件，但实际上是有一个关于滚动相关的组件，只是没有文档。就是el-scrollbar组件。</p>
<p>这个组件可以在查官方文档页面元素的时候找到，我是因为官方文档左右独立滚动而发现的。我们可以查查它的源码。</p>
<p>源码中，在scrollbar/src下有main.js文件，这个文件中就有关于srollbar的实现源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    native: Boolean, // 是否显示滚动条</span><br><span class="line">    wrapStyle: &#123;&#125;, // 外层容器el-scrollbar__wrap同层的style样式</span><br><span class="line">    wrapClass: &#123;&#125;, // 外层容器el-scrollbar__view同层的class样式</span><br><span class="line">    viewClass: &#123;&#125;, // 内层容器el-scrollbar__view同层的style样式</span><br><span class="line">    viewStyle: &#123;&#125;, // 内层容器el-scrollbar__view同层的class样式</span><br><span class="line">    noresize: Boolean, // 如果 container 尺寸不会发生变化，最好设置它可以优化性能</span><br><span class="line">    tag: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &apos;div&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上面就是我们使用el-scrollbar组件时可以传入的prop：<code>native</code>是用于判断是否显示滚动条，从源码的实现来看，滚动条是ElementUI自己实现的，也就是如果需要显示滚动条，可以考虑使用这个组件；<code>noresize</code>是用于判断是否需要监听尺寸变化事件，如果滚动内容的长度固定不变，可以设置为true以优化性能；<code>tag</code>是用于指定内层容器渲染的标签。知道这些，我们就可以知道怎么使用el-scrollbar组件了。</p>
<p>我们再看看ElementUI官网是怎么使用它的：以官网导航栏为例，在<code>.el-scrollbar</code>的父类<code>.page-component</code>上设定了高度为100%，然后在<code>.el-scrollbar</code>同层增加<code>.page-component__nav</code>类实现导航栏的样式，最后在内层容器内使用<code>.side-nav</code>再设定100%的高度。</p>
<p>我自己使用的过程中是在内层容器内使用一个类设定固定的高度，然后就可以实现滚动效果。</p>
<h4 id="el-table-表头跟表格宽度不一致"><a href="#el-table-表头跟表格宽度不一致" class="headerlink" title="el-table 表头跟表格宽度不一致"></a>el-table 表头跟表格宽度不一致</h4><p>我在开发中发现了这个问题，在网上也发现有很多人遇到这个问题，目前我使用的解决方案是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 解决elementUI表头跟表格宽度不一致 */</span><br><span class="line">body .el-table th.gutter &#123;</span><br><span class="line">    display: table-cell!important;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">body .el-table colgroup.gutter &#123;</span><br><span class="line">    display: table-cell!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="安卓跟iOS的坑"><a href="#安卓跟iOS的坑" class="headerlink" title="安卓跟iOS的坑"></a>安卓跟iOS的坑</h3><h4 id="new-Date-转换时间戳"><a href="#new-Date-转换时间戳" class="headerlink" title="new Date()转换时间戳"></a>new Date()转换时间戳</h4><p>在iOS的微信H5开发中，使用<code>new Date(&#39;2019-5-4&#39;)</code>会出现报错，究其原因是iOS下不能使用<code>-</code>，应该使用<code>/</code>，即<code>new Date(&#39;2019/5/4&#39;)</code>。</p>
<h4 id="安卓非body标签无滚动条"><a href="#安卓非body标签无滚动条" class="headerlink" title="安卓非body标签无滚动条"></a>安卓非body标签无滚动条</h4><p>在开发的过程中，我们发现在安卓系统中，页面中除了body之外其他标签都无法传滚动条，但是iOS系统就会有。这种情况下我们可以自己实现或借助一些UI框架实现滚动条。如果选择借助的话，可以考虑ElementUI的el-scrollbar组件(前面在分析源码的时候就有这样一个prop)，也可以考虑better-scroll插件，通过配置来实现滚动条。</p>
<h3 id="前端开发的占位图"><a href="#前端开发的占位图" class="headerlink" title="前端开发的占位图"></a>前端开发的占位图</h3><p>其实开发中如果能考虑上占位图的话，对用户的使用体验是有很高的提升的。以往通过加载条来表示加载会让用户觉得加载时间很长，而使用占位图则会给用户一种页面逐渐加载完毕的效果。</p>
<p>网上有很多推荐的占位图实现方案，有给未加载数据的容器加占位图样式的，有在数据加载完毕前先画一些占位容器的。这里就不一一细讲，主要是找到一个觉得挺不错的插件可以方便占位图的实现的：vue-content-loader。</p>
<p>这个插件是通过实现SVG组件来完成占位图，看起来效果还不错，而且官方还给出一个页面可以通过拉拽，数据调整实现占位图组件。</p>
<p>另外，它还有一个React版本。虽然我还没有使用过，不知道效果如何，但是我觉得应该是很有尝试的必要的。</p>
<h3 id="vue中的图片懒加载"><a href="#vue中的图片懒加载" class="headerlink" title="vue中的图片懒加载"></a>vue中的图片懒加载</h3><p>除了占位图的加载优化，图片的懒加载也是前端开发中比较常见的加载优化点。在一个页面上，如果需要加载的图片很多，一般都会考虑优先加载第一版的图片，等用户滚动页面时，出现在窗口内的图片才会被加载。</p>
<p>这里可以使用vue-lazyload插件。这个插件使用起来非常简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// npm</span><br><span class="line">$ npm i vue-lazyload -S</span><br><span class="line"></span><br><span class="line">//main.js</span><br><span class="line">// 引入</span><br><span class="line">import VueLazyload from &apos;vue-lazyload&apos;</span><br><span class="line">// 注册</span><br><span class="line">Vue.use(VueLazyload)</span><br><span class="line">// 配置</span><br><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  preLoad: 1.3,</span><br><span class="line">  error: &apos;dist/error.png&apos;,</span><br><span class="line">  loading: &apos;dist/loading.gif&apos;,</span><br><span class="line">  attempt: 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;img in list&quot;&gt;</span><br><span class="line">        &lt;img v-lazy=&quot;img.src&quot; &gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>以上是截取官方文档的部分代码。这样就可以完成简单的图片懒加载了。还有很多配置可以使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/05/04/work-summary3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/work-summary3/" itemprop="url">工作总结(3)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-04T22:23:25+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/axios/" itemprop="url" rel="index">
                    <span itemprop="name">axios</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/axios/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇整理了一些关于vuejs的内容，这篇来整理一些axios的内容。</p>
<h3 id="axios请求状态拦截"><a href="#axios请求状态拦截" class="headerlink" title="axios请求状态拦截"></a>axios请求状态拦截</h3><p>axios是平时用的比较多的用于http请求的库，平时用的比较多的相信是<code>axios.get()</code>，<code>axios.post()</code>，拦截器<code>axios.interceptors.request.use</code>及<code>axios.interceptors.response.use</code>。其实axios还可以自定义很多配置(具体可以参考这里：<a href="http://www.axios-js.com/zh-cn/docs/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">http://www.axios-js.com/zh-cn/docs/#%E8%AF%B7%E6%B1%82%E9%85%8D%E7%BD%AE</a> ）。</p>
<p>我这里主要想说的是，axios在自定义配置上，可以自定义拦截的范围。下面是文档中给出的配置项<code>validateStatus</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 reject</span><br><span class="line">    validateStatus: function (status) &#123;</span><br><span class="line">        return status &gt;= 200 &amp;&amp; status &lt; 300; // default</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这项配置，可以让axios判断请求返回的内容根据状态码应该返回resolve还是reject。这个配置可以搭配axios拦截器使用比较好。</p>
<h3 id="axios请求取消"><a href="#axios请求取消" class="headerlink" title="axios请求取消"></a>axios请求取消</h3><p>实际开发中会有这样的需求：用户在快速操作中会发出很多请求，但其实有些请求已经不需要了或者因为用户的来回切换出现不必要的重新请求。这种情况下就要考虑能否取消掉已经发出的请求。</p>
<p>在axios中就可以通过方法<code>CancelToken.source</code>创建cancel token进行请求取消。在vue开发中，你可以先声明一个canceltoken的状态，然后在不需要请求的地方执行<code>source.cancel()</code>。</p>
<p>演示代码来源：<a href="http://www.axios-js.com/zh-cn/docs/#%E5%8F%96%E6%B6%88" target="_blank" rel="noopener">http://www.axios-js.com/zh-cn/docs/#%E5%8F%96%E6%B6%88</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const CancelToken = axios.CancelToken;</span><br><span class="line">const source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(&apos;/user/12345&apos;, &#123;</span><br><span class="line">    cancelToken: source.token</span><br><span class="line">&#125;).catch(function(thrown) &#123;</span><br><span class="line">    if (axios.isCancel(thrown)) &#123;</span><br><span class="line">        console.log(&apos;Request canceled&apos;, thrown.message);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 处理错误</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.post(&apos;/user/12345&apos;, &#123;</span><br><span class="line">    name: &apos;new name&apos;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    cancelToken: source.token</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 取消请求（message 参数是可选的）</span><br><span class="line">source.cancel(&apos;Operation canceled by the user.&apos;);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/05/04/work-summary2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/work-summary2/" itemprop="url">工作总结(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-04T22:21:47+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>忙了一段时间，刚好有一堆可以总结的内容。这里我会先整理一下vuejs相关的内容。</p>
<h3 id="关于vuejs的watch侦听器的用法"><a href="#关于vuejs的watch侦听器的用法" class="headerlink" title="关于vuejs的watch侦听器的用法"></a>关于vuejs的watch侦听器的用法</h3><p>一般都知道vuejs的watch侦听器的用法，watch就是用来响应数据的变化的。数据的每一次变化，都会调用相应的侦听回调。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 官方演示代码的部分截取</span><br><span class="line">watch: &#123;</span><br><span class="line">    // 如果 `question` 发生改变，这个函数就会运行</span><br><span class="line">    question: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">        this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class="line">        this.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>但是上面这种侦听器只能侦听数据变化，换句话说，数据的第一次赋值是不会触发这个侦听方法的。所以这里就需要用到<code>immediate</code>这个属性了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 上面部分官方演示代码的修改</span><br><span class="line">watch: &#123;</span><br><span class="line">  question: &#123;</span><br><span class="line">	  // 设置immediate为true之后，该回调将会在侦听开始之后被立即调用</span><br><span class="line">	  immediate: true,</span><br><span class="line">	  handler: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">      this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class="line">      this.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>还有一种情况是，需要侦听的数据是一个Object类型，上面的回调是不会被触发的，因为Vue的侦听默认情况下是handler 只监听这个Object对象它的引用的变化，不能侦听到Object内部属性的添加或删减，所以需要用到<code>deep</code>这个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 上面部分官方演示代码的修改，假定question是一个Object类型的数据</span><br><span class="line">watch: &#123;</span><br><span class="line">    question: &#123;</span><br><span class="line">	    // 设置deep为true之后，就能做深度侦听</span><br><span class="line">	    deep: true,</span><br><span class="line">	    handler: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="vue-router路由懒加载-组件按需引用"><a href="#vue-router路由懒加载-组件按需引用" class="headerlink" title="vue-router路由懒加载(组件按需引用)"></a>vue-router路由懒加载(组件按需引用)</h3><p>关于vue-router路由懒加载，应该是一个比较常规的操作，路由懒加载可以让项目在运行时减少不必要的代码加载，或者按运行时不同的需求加载部分代码，这样可以减少加载时间。</p>
<p>一开始用的方案是webpack的require.ensure()实现按需加载。webpack的中文文档叫代码分割（参考：<a href="https://webpack.js.org/api/module-methods/#requireensure" target="_blank" rel="noopener">https://webpack.js.org/api/module-methods/#requireensure</a> ）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require.ensure(dependencies: String[], callback: function(require), chunkName: String)</span><br></pre></td></tr></table></figure>
<p>这个方法传入三个参数：dependencies传入的是依赖的集合，在执行回调函数之前会声明集合中所有的依赖；callback传入的是回调函数，当所有依赖加载完毕之后，webpack就会执行这个回调函数；chunkName是提供给这个特定的 require.ensure() 的 chunk 的名称。通过提供 require.ensure() 不同执行点相同的名称，我们可以保证所有的依赖都会一起放进相同的 文件束(bundle)。</p>
<p>这样，就可以在vue-router中实现按需加载了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Login = resolve =&gt; &#123;</span><br><span class="line">    require.ensure([], () =&gt; &#123;</span><br><span class="line">        resolve(require(&apos;./views/Login/index.vue&apos;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const routes = [&#123;</span><br><span class="line">    path: &apos;/login&apos;,</span><br><span class="line">    name: &apos;login&apos;,</span><br><span class="line">    component: Login</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>vue-router官方文档也提供了一种方案，写法上更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 下面是一种特殊注释，可以在打包时说明打包到什么异步块中 */</span><br><span class="line">const routes = [&#123;</span><br><span class="line">    path: &apos;/login&apos;,</span><br><span class="line">    name: &apos;login&apos;,</span><br><span class="line">    component: () =&gt; import(/* webpackChunkName: &quot;login&quot; */ &apos;./views/Login/index.vue&apos;)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h3><p>我们都知道vue.use是用于注册安装插件的，一般用的比较多的地方是一些UI框架的按需引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    Upload,</span><br><span class="line">    Progress</span><br><span class="line">&#125; from &apos;element-ui&apos;;</span><br><span class="line">Vue.use(Upload);</span><br><span class="line">Vue.use(Progress);</span><br></pre></td></tr></table></figure>
<p>这里其实我只是想说一下，vue.use其实是可以链式使用的，因为源码中，vue.use在执行完之后会return this，而this指向的是vue本身，所以是可以链式使用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    Upload,</span><br><span class="line">    Progress</span><br><span class="line">&#125; from &apos;element-ui&apos;;</span><br><span class="line">Vue.use(Upload).use(Progress);</span><br></pre></td></tr></table></figure>
<h3 id="多个UI框架组件冲突"><a href="#多个UI框架组件冲突" class="headerlink" title="多个UI框架组件冲突"></a>多个UI框架组件冲突</h3><p>一般其实不会出现这种情况，但难不了会出现，需要有解决方案。比如在一个项目中，有一部分页面是公众号H5，而其他页面是手机端页面，他们因为需求不同导致需要用不同UI框架的同名组件，这种情况下，可以尝试在引入时使用不同的命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">  Dialog</span><br><span class="line">&#125; from &apos;vant&apos;;</span><br><span class="line">Vue.use(Dialog);</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    Dialog as muDialog</span><br><span class="line">&#125; from &apos;muse-ui&apos;;</span><br><span class="line">Vue.use(muDialog);</span><br></pre></td></tr></table></figure>
<p>延伸一下：如果是一个文件中有多个需要引入的方法，但同时这些方法都放在同一个文件中，在引入时可以直接写成<code>import { * as xxx } from &#39;./xxx.vue</code>，使用时就可以通过<code>xxx.xx</code>形式来使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/03/13/work-summary1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/13/work-summary1/" itemprop="url">工作总结(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-13T23:14:46+08:00">
                2019-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天来做点学习总结，这些学习总结都是从工作中整理来的，自然做了总结，就比较容易积累经验，提高以后的工作效率了。好吧，开始吧。</p>
<h3 id="Vuejs中图片的引入问题"><a href="#Vuejs中图片的引入问题" class="headerlink" title="Vuejs中图片的引入问题"></a>Vuejs中图片的引入问题</h3><p>这里指的图片引入问题是这样的： 一般开发使用比较多vue-cli脚手架，然后我在开发过程中遇到的是在项目其他位置存放的图片，虽然引入的路径是正确的，但是无法显示到页面上。我在网上搜索了不少这样的问题，有些是在打包后发现的。</p>
<p>目前有几个方案是可行的：</p>
<ol>
<li><p>把图片全部放到vue-cli脚手架生成的assets文件夹中，这个文件夹本身也放着vue-cli自带的图片。这个文件夹中的图片可以直接通过路径引入，而且能够正常的显示到页面上；</p>
</li>
<li><p>不改变图片的位置，直接通过<code>import imageXX from &#39;path&#39;</code>的方法引入到文件中。这种方式可以通过变量来引用图片的路径，也是可以正常的显示到页面上。但是在css样式中就实现不了，可能要在模板上直接通过<code>:style=&quot;background-image:...&quot;</code>来实现，比较麻烦；</p>
</li>
<li><p>同上方案，但是是通过<code>require(&#39;path&#39;)</code>的方法引入到文件中。问题一样，就是对于css的样式实现来说比较困难；</p>
</li>
<li><p>网上还有一种方案是在<code>build/utils.js</code>中找到<code>ExtractTextPlugin</code>位置在对象中加入这句<code>publicPath: &#39;../../&#39;</code>。这个方案没有试过，因为在vue-cli3中，文件结构有变化了，我猜测这个可能要写到<code>vue.config.js</code>中。以后有机会再测试。</p>
</li>
</ol>
<h3 id="关于手机号码的正则表达式"><a href="#关于手机号码的正则表达式" class="headerlink" title="关于手机号码的正则表达式"></a>关于手机号码的正则表达式</h3><p>这个简单带过，这个正则表达式就是<code>/^1(3|4|5|7|8)\d{9}$/</code>。</p>
<p>不过，有个地方需要关注的，就是在使用<code>reg.test(str)</code>时，reg正则表达式不要带<code>g</code>修饰符。我们都知道，<code>g</code>是匹配全部可匹配结果，比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;aaaaaaaa&apos;</span><br><span class="line">const reg1 = /a/</span><br><span class="line">const reg2 = /a/g</span><br><span class="line">str.match(reg1) // [&quot;a&quot;, index: 0, input: &quot;aaaaaaaa&quot;]</span><br><span class="line">str.match(reg2) // [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br></pre></td></tr></table></figure>
<p>不带<code>g</code>时，字符串从左到右匹配，只要匹配成功就停止匹配；带<code>g</code>时，同样的匹配方向，但是会一直匹配到整个字符串结束。<br>在使用<code>reg.test(str)</code>时，如果带修饰符<code>g</code>，在第一次验证时是从字符串第一位开始，但是如果有第二次验证时，就会从第一次验证结束的位置开始验证。这样就可能导致两次验证结果不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const reg=/\./g</span><br><span class="line">reg.test(0.5) // true，第一次验证从字符串第一位开始</span><br><span class="line">reg.test(0.5) // false,因为接着上一次的字符串位置查找，没找到正则匹配的内容，所以结果是false，false以后，index会自动归0</span><br><span class="line">reg.test(0.5) // true</span><br></pre></td></tr></table></figure>
<p>所以，在做<code>reg.test(str)</code>验证时，正则表达式最好不带修饰符<code>g</code>。</p>
<h3 id="关于CSS背景图片的设置"><a href="#关于CSS背景图片的设置" class="headerlink" title="关于CSS背景图片的设置"></a>关于CSS背景图片的设置</h3><p>这里要提的是，CSS背景图片是可以同时设置多张的，而且每张背景图片的样式都可以设置，但是我在开发中发现设置了repeat的背景图片会覆盖掉排在后面的图片，所以最好是把这张图片的顺序放在最后，参考如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-image: url(&quot;bg_top.jpg&quot;), url(&quot;bg_bottom.png&quot;), url(&quot;bg_middle.jpg&quot;);</span><br><span class="line">background-repeat: no-repeat, no-repeat, repeat;</span><br><span class="line">background-position: top, bottom, center;</span><br></pre></td></tr></table></figure>
<h3 id="关于rem布局"><a href="#关于rem布局" class="headerlink" title="关于rem布局"></a>关于rem布局</h3><p>rem布局其实还是挺不错的，可以动态的屏幕宽度来设置html的font-size，并且调整所所有元素的样式。可以参考网上关于网易rem布局的原理。</p>
<h3 id="关于axios跟promise"><a href="#关于axios跟promise" class="headerlink" title="关于axios跟promise"></a>关于axios跟promise</h3><p>这里留一个promise配合axios开发的参考代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// api</span><br><span class="line">export const submitApi = function (url, params, xxx) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    axios.post(url, params, &#123;</span><br><span class="line">      headers: &#123;</span><br><span class="line">        XXX: xxx</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).then(res =&gt; &#123;</span><br><span class="line">      resolve(res);</span><br><span class="line">    &#125;).catch(error =&gt; &#123;</span><br><span class="line">      reject(error);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">submitApi(url, params, xxx).then(res =&gt; &#123;</span><br><span class="line">  if (res.status === 200) &#123;</span><br><span class="line">    console.log(res.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line">  console.log(&apos;something wrong!&apos;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>先这些吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/03/10/NewJourney/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/10/NewJourney/" itemprop="url">新的开始</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-10T16:56:05+08:00">
                2019-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/other/" itemprop="url" rel="index">
                    <span itemprop="name">其他</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近家里来了新的小成员，所有事情都围着他团团转。这几天终于能放松一点点，想着为了以后在工作上能效率高一些，折腾了一下给电脑加个ssd，重装了系统，结果忘记备份写好的好几篇博客稿子……</p>
<p>都怪自己没有及时的安排发布，还好所有资料也就丢失了这几篇稿子，后面还可以找时间再补回来。</p>
<p>把自己的事情做好才是最重要的，整理好，准备迎接各种新的开始。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/02/09/Mouse-Event-Attributes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/09/Mouse-Event-Attributes/" itemprop="url">JavaScript鼠标事件中event的各种x/y属性梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-09T19:48:05+08:00">
                2019-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在敲代码的时候遇到关于JavaScript事件中求各种长宽，涉及到event中各种x/y，所以尝试做一些梳理。</p>
<p>这里说的event是指js中鼠标事件event的实例属性，而各种x/y就是指以下这些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e.clientX/e.clientY</span><br><span class="line">e.screenX/e.screenY</span><br><span class="line">e.offsetX/offsetY</span><br><span class="line">e.pageX/e.pageY</span><br><span class="line">e.layerX/e.layerX</span><br><span class="line">e.x/e.y</span><br></pre></td></tr></table></figure>
<h3 id="关于各种x-y属性的描述"><a href="#关于各种x-y属性的描述" class="headerlink" title="关于各种x/y属性的描述"></a>关于各种x/y属性的描述</h3><p>在网上找了一些资料，对于这些属性都有描述。<a href="http://www.w3school.com.cn" target="_blank" rel="noopener">http://www.w3school.com.cn</a> w3c给出了clientX/Y跟screenX/Y的描述，不过为了统一，我选择了阮一峰的一份JavaScript教程(<a href="https://wangdoc.com/javascript/events/mouse.html" target="_blank" rel="noopener">https://wangdoc.com/javascript/events/mouse.html</a>) 中的描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MouseEvent.clientX属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素）</span><br><span class="line">MouseEvent.clientY属性返回垂直坐标。这两个属性都是只读属性。</span><br><span class="line"></span><br><span class="line">MouseEvent.screenX属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），</span><br><span class="line">MouseEvent.screenY属性返回垂直坐标。这两个属性都是只读属性。</span><br><span class="line"></span><br><span class="line">MouseEvent.offsetX属性返回鼠标位置与目标节点左侧的padding边缘的水平距离（单位像素）</span><br><span class="line">MouseEvent.offsetY属性返回与目标节点上方的padding边缘的垂直距离。这两个属性都是只读属性。</span><br><span class="line"></span><br><span class="line">MouseEvent.pageX属性返回鼠标位置与文档左侧边缘的距离（单位像素），</span><br><span class="line">MouseEvent.pageY属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。这两个属性都是只读。</span><br></pre></td></tr></table></figure>
<p><code>layerX/e.layerX</code>跟<code>x/y</code>则没有找到比较权威的描述。</p>
<p>这些描述看完还是有点稀里糊涂的，不过可以看出，这些属性的值都是相对的，是有参考坐标的，比如浏览器，屏幕，目标节点，文档等。所以我们就试试在代码中获得更深入的理解。</p>
<h3 id="代码实现实例属性"><a href="#代码实现实例属性" class="headerlink" title="代码实现实例属性"></a>代码实现实例属性</h3><p>这里尝试做一个简单的演示项目，body中如下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;canvas-wrapper&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;canvas id=&quot;canvas&quot; height=&quot;2000&quot; width=&quot;2000&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><code>div#container</code>元素是作为鼠标事件的目标节点，而<code>canvas</code>画布则是用于绘出点击事件的坐标跟垂直线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  margin: 0px;</span><br><span class="line">  padding: 0px;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这几个实例属性中有一些是涉及页面可视，所以给<code>div#container</code>元素绝对定位，脱离文档流；为了页面可以上下左右滚动，所以<code>body</code>跟<code>canvas</code>元素的尺寸都很大。<br>而且为了减少盒模型的影响，所以设置了<code>box-sizing: border-box;</code></p>
<p>js逻辑部分，给<code>div#container</code>添加鼠标点击事件，回调函数中返回event，把event中的这些关于x/y的实例属性通过new传入一个位置构造函数的实例中，通过实例来绘出点击点跟各个x/y属性的线。</p>
<h3 id="x-y各属性的表现梳理"><a href="#x-y各属性的表现梳理" class="headerlink" title="x/y各属性的表现梳理"></a>x/y各属性的表现梳理</h3><p><img src="https://listentolife.cc/images/pos.PNG" alt="代码中各x/y属性的演示"></p>
<p>这张截图是在浏览器向左向下滚动后(浏览器的上边贴着绿色线，浏览器的左边贴着绿色线)，点击（点击点中心为黑点中心）触发事件得到的绘图。</p>
<h4 id="clientX-clientY-amp-x-y"><a href="#clientX-clientY-amp-x-y" class="headerlink" title="clientX/clientY &amp; x/y"></a><code>clientX</code>/<code>clientY</code> &amp; <code>x</code>/<code>y</code></h4><p><code>clientX</code>/<code>clientY</code>在点击事件触发时是等于点击点到浏览器的上边跟左边，说明 <strong><code>clientX</code>/<code>clientY</code>的参考坐标轴是沿着浏览器的上边为x轴，浏览器的左边为y轴</strong> 。跟目标节点的<code>border</code>，<code>margin</code>跟<code>padding</code>没有关系。<br>相同的<code>x</code>/<code>y</code>在表现上也一样。不过最好使用的时候使用前者。</p>
<h4 id="layerX-layerY"><a href="#layerX-layerY" class="headerlink" title="layerX/layerY"></a><code>layerX</code>/<code>layerY</code></h4><p><code>layerX</code>/<code>layerY</code>在点击事件触发之后显示出来是点击点到目标节点的边界，而且是在目标节点的边框上。目标节点的样式是有添加<code>border</code>跟<code>padding</code>样式的，而这个属性绘出的线跟目标节点的边框相交但不超出，说明 <strong><code>layerX</code>/<code>layerY</code>的参考坐标轴是沿着目标节点的上边界（有边框则是沿着上边框）为x轴，目标节点的左边界（有边框则是沿着左边框）为y轴</strong> 。跟目标节点的<code>margin</code>，页面的可视范围没有关系。</p>
<h4 id="offsetX-offsetY"><a href="#offsetX-offsetY" class="headerlink" title="offsetX/offsetY"></a><code>offsetX</code>/<code>offsetY</code></h4><p><code>offsetX</code>/<code>offsetY</code>跟<code>layerX</code>/<code>layerY</code>很接近，但是它跟目标节点的边框没有相交，也就是当目标节点没有边框的情况下，<code>offsetX</code>/<code>offsetY</code>跟<code>layerX</code>/<code>layerY</code>的值是相等的。<strong><code>offsetX</code>/<code>offsetY</code>的参考坐标轴是沿着目标节点的上边界为x轴，目标节点的左边界为y轴</strong> 。跟目标节点的<code>margin</code>，页面的可视范围没有关系。</p>
<h4 id="pageX-pageY"><a href="#pageX-pageY" class="headerlink" title="pageX/pageY"></a><code>pageX</code>/<code>pageY</code></h4><p><code>pageX</code>/<code>pageY</code>在点击事件触发之后显示出来是点击点到文档页面的边界，及时是页面发生了滚动，这个属性仍然显示的是点击点在文档页面的相对位置。所以 <strong><code>pageX</code>/<code>pageY</code>的参考坐标轴是沿着文档页面的上边界为x轴，文档页面的左边界为y轴</strong> 。跟目标节点，页面的可视范围没有关系。</p>
<h4 id="screenX-screenY"><a href="#screenX-screenY" class="headerlink" title="screenX/screenY"></a><code>screenX</code>/<code>screenY</code></h4><p><code>screenX</code>/<code>screenY</code>代码中没有绘制，原因在于这个属性的坐标是整个屏幕，跟浏览器无关，所以无法绘制展示出来。</p>
<p>上述就是鼠标事件event中关于x/y属性的梳理。文中的代码已上传github：<br><a href="https://github.com/listentolife/mouseEventPositionAttributes" target="_blank" rel="noopener">https://github.com/listentolife/mouseEventPositionAttributes</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/01/16/Vuejs-keepAlive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/16/Vuejs-keepAlive/" itemprop="url">Vue.js keep-alive组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T22:15:21+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有时候会觉得学习vue像在寻宝一样。因为vue中有很多很有用的组件，像之前写的关于插槽组件的那篇一样，我也是认为插槽组件很有用，可以更好的实现组件复用。这篇主要整理keep-alive组件的内容。</p>
<p>keep-alive组件是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p>
<p>keep-alive组件可以使用到动态组件<code>&lt;component&gt;</code>，也可以使用到路由组件<code>&lt;router-view&gt;</code>上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用到动态组件上</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;compunent :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">// 使用到路由组件上</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>keep-alive组件内可以由多个子组件，但是要求只能同时渲染一个子组件，也就是多子组件时，可以使用<code>v-if</code>，<code>v-else</code>，但不支持<code>v-for</code>。</p>
<p>它有三个props：<code>include</code>，<code>exclude</code>，<code>max</code>。</p>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a><code>include</code></h3><p><code>include</code>支持组件名匹配字符串或正则表达式的组件被缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;book&quot;&gt;</span><br><span class="line">  &lt;!-- 将缓存name为book的组件，name为movie的组件将不会被缓存 --&gt;</span><br><span class="line">  &lt;component&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive include=&quot;a,b&quot;&gt;</span><br><span class="line">  &lt;!-- 将缓存name为a或者b的组件，结合动态组件使用 --&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用正则表达式，需使用v-bind --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;/a|b/&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态匹配判断是否缓存 --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;[&apos;books&apos;, &apos;movies&apos;] &quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a><code>exclude</code></h3><p><code>exclude</code>跟<code>include</code>刚好相反，组件名不匹配字符串或正则表达式的组件才会被缓存。用法跟<code>include</code>一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude=&quot;book&quot;&gt;</span><br><span class="line">  &lt;!-- 除name为book的组件之外其他组件都会被缓存，如name为movie的组件 --&gt;</span><br><span class="line">  &lt;component&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive exclude=&quot;a,b&quot;&gt;</span><br><span class="line">  &lt;!-- 将不缓存name为a或者b的组件 --&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用正则表达式，需使用v-bind --&gt;</span><br><span class="line">&lt;keep-alive :exclude=&quot;/a|b/&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态匹配判断是否缓存 --&gt;</span><br><span class="line">&lt;keep-alive :exclude=&quot;[&apos;books&apos;, &apos;movies&apos;] &quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<h3 id="max"><a href="#max" class="headerlink" title="max"></a><code>max</code></h3><p><code>max</code>表示最多可以缓存多少个组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 最多只能缓存10个组件实例，而且是最新被访问的组件实例才会被缓存 --&gt;</span><br><span class="line">&lt;keep-alive :max=&quot;10&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/01/16/Vuejs-VueRouterII/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/16/Vuejs-VueRouterII/" itemprop="url">Vue Router学习(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T22:13:14+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇整理一下vue-router的两个部分：编程式导航及路由传值。</p>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>编程式导航其实是跟声明式导航相对的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明式路由导航</span><br><span class="line">&lt;router-link to=&apos;/books&apos;&gt;To Books List&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">// 编程式路由导航</span><br><span class="line">router.push(&#123;</span><br><span class="line">  path: &apos;/books&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>两种方式都可以实现路由导航，使用<code>&lt;router-link&gt;</code>相当于调用了<code>router.push</code>。不过编程式导航，还有<code>router.replace()</code>，<code>router.go()</code>，<code>router.back()</code>及<code>router.forward()</code>方法可以调用。</p>
<h4 id="router-push-amp-router-replace"><a href="#router-push-amp-router-replace" class="headerlink" title="router.push()&amp;router.replace()"></a><code>router.push()</code>&amp;<code>router.replace()</code></h4><p><code>router.push()</code>和<code>router.replace()</code>传参都是一样，分别是必须传值的<code>location</code>和可选的<code>onComplete</code>，<code>onAbort</code>回调。</p>
<p><code>location</code>传入的参数可以是字符串，直接指向路由地址，也可以是描述地址的对象，还可以是路由对象及带查询参数的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 官方文档的代码*/</span><br><span class="line">// 字符串</span><br><span class="line">router.push(&apos;home&apos;)</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">router.push(&#123; path: &apos;home&apos; &#125;)</span><br><span class="line"></span><br><span class="line">// 命名的路由</span><br><span class="line">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 带查询参数，变成 /register?plan=private</span><br><span class="line">router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>下面是实际项目中对编程式导航的实现及router.push()的运用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 项目中的实现 */</span><br><span class="line">&lt;!-- 监听点击事件，再使用编程式导航到新路由 --&gt;</span><br><span class="line">&lt;li</span><br><span class="line">  v-for=&quot;(movie,index) in movies&quot;</span><br><span class="line">  :key=&quot;index&quot;</span><br><span class="line">  class=&quot;movie-list&quot;</span><br><span class="line">  @click=&quot;selectMovie(movie)&quot;</span><br><span class="line">  &gt;...&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">// 这里使用的this.$router等同于router对象</span><br><span class="line">// 上一篇中说到在各个组件中都可以调用到this.$router</span><br><span class="line">selectMovie (movie) &#123;</span><br><span class="line">  this.$router.push(&#123;</span><br><span class="line">    name: &apos;movie-item&apos;,</span><br><span class="line">    params: &#123;</span><br><span class="line">      id: movie.title,</span><br><span class="line">      movie: movie</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>router.push()</code>实际上是在history栈添加一个新的记录，也就是用户点击浏览器后退时，是可以返回到上一个路由的。</p>
<p>官方文档中提醒了一句：<strong>如果提供了<code>path</code>，<code>params</code>会被忽略。</strong>如果要传入无法通过路径传入的值，或者传入值较多，建议使用parmas。</p>
<p>可选的<code>onComplete</code>，<code>onAbort</code>回调主要用在导航完成之后及导航终止的时候进行调用。目前我还没有看到网上有什么人有讲到这部分，所以了解就好，以后再深入。</p>
<p><code>router.replace()</code>跟<code>router.push()</code>有一个很大的区别，在于它不是在history栈添加一个新的记录，而是替换当前的记录，也就是无法返回上一个路由记录。其他使用方面都是一样的。</p>
<h4 id="router-go-，router-back-及router-forward"><a href="#router-go-，router-back-及router-forward" class="headerlink" title="router.go()，router.back()及router.forward()"></a><code>router.go()</code>，<code>router.back()</code>及<code>router.forward()</code></h4><p><code>router.go()</code>的参数是一个整数，表示在浏览器记录中向前或向后几步。如果是向前一步，就是<code>router.go(1)</code>，即<code>router.back()</code>；如果是向后一步，就是<code>router.go(-1)</code>，即<code>router.forward()</code>。</p>
<h3 id="路由传值"><a href="#路由传值" class="headerlink" title="路由传值"></a>路由传值</h3><p>其实前面的篇幅中，多少已经涉及到路由传值了。路由传值主要是在<code>&lt;router-link&gt;</code>的<code>to</code>属性中跟<code>router.push()</code>中使用，传值也分<code>params</code>跟<code>query</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 使用动态路由时，在to属性中使用params对象传值</span><br><span class="line">&lt;router-link</span><br><span class="line">  class=&quot;music-list&quot;</span><br><span class="line">  tag=&quot;li&quot;</span><br><span class="line">  :to=&quot;&#123;name:&apos;music-item&apos;,params:&#123;id:music.title,music:music&#125;&#125;&quot;</span><br><span class="line">  v-for=&quot;music in musics&quot;</span><br><span class="line">  :key=&quot;music.title&quot;</span><br><span class="line">&gt;...&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">// 使用编程式导航时，直接在location参数中写入params传值</span><br><span class="line">// query的写法一样</span><br><span class="line">selectMovie (movie) &#123;</span><br><span class="line">  this.$router.push(&#123;</span><br><span class="line">    name: &apos;movie-item&apos;,</span><br><span class="line">    params: &#123;</span><br><span class="line">      id: movie.title,</span><br><span class="line">      movie: movie</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有提到，如果提供了<code>path</code>，<code>params</code>会被忽略，所以一般使用params时，就需要传入name指明路由名，如果使用query时，就可以直接传入路由路径。</p>
<p>传值在组件内可以通过<code>this.$route.params</code>及<code>this.$route.query</code>获得。</p>
<p>使用<code>path</code>，<code>params</code>时有一点需要注意，使用<code>path</code>传值，刷新页面参数会丢失；使用<code>params</code>查询参数，刷新页面参数就不会丢失。</p>
<p>vue-router的这两篇内容算入门内容，简单做整理，加深理解。vue-router的其他内容也会在深入学习使用之后再整理出来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Listentolife</p>
              <p class="site-description motion-element" itemprop="description">Listentolife's Blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archive">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/listentolife" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:listentolife@qq.com" target="_blank" title="E-Mail">
                      E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Listentolife</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




<span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;</span>
<span id="showDays"></span>

<script>
	var birthDay = new Date('04/23/2018');
	var now = new Date();
	var duration = now.getTime() - birthDay.getTime();
	var total= Math.floor(duration / (1000 * 60 * 60 * 24));
	document.getElementById('showDays').innerHTML='本站已运行' + total + '天';
</script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
