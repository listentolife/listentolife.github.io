<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Listentolife&apos;s Blog">
<meta name="keywords" content="HTML CSS JavaScript">
<meta property="og:type" content="website">
<meta property="og:title" content="Listentolife">
<meta property="og:url" content="http://listentolife.github.io/index.html">
<meta property="og:site_name" content="Listentolife">
<meta property="og:description" content="Listentolife&apos;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Listentolife">
<meta name="twitter:description" content="Listentolife&apos;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://listentolife.github.io/"/>





  <title>Listentolife</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Listentolife</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">简单就好</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archive" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/30/axios-source-analysis1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/30/axios-source-analysis1/" itemprop="url">axios源码学习(一)：通过axios有多少种方法可以发起请求？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-30T21:27:10+08:00">
                2020-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/axios/" itemprop="url" rel="index">
                    <span itemprop="name">axios</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>花了两天时间读了一遍axios源码，终于理解了axios内部是怎么运行的，这期间学习到了很多，所以想分享一下。想了很久，决定用一些问题来作为引子，一点点的整理一下我对axios源码的理解。下面我会用到一些官方文档的用例来说明。</p>
<p>用过axios的童鞋应该都知道，axios有很多请求的api，用起来是非常方便的。那么大家知道axios有多少种方法方式可以发起请求吗？为什么这些方法方式都可以发起请求？内部是怎么实现的。</p>
<p>这里我会先整理一下有哪些方法api，然后最后来整理一下源码中是如果实现这些方法的。</p>
<h2 id="axios发起请求的方法"><a href="#axios发起请求的方法" class="headerlink" title="axios发起请求的方法"></a>axios发起请求的方法</h2><p>我们现在说说有哪些方法。首先要说明一下，我们一般都是这样引入axios的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br></pre></td></tr></table></figure>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios()"></a>axios()</h3><p><code>axios()</code>是可以直接作为函数调用的。本身就是一个请求函数，可以直接传入请求的url，请求数据及请求配置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  method: <span class="string">'post'</span>,</span><br><span class="line">  url: <span class="string">'/user/12345'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Fred'</span>,</span><br><span class="line">    lastName: <span class="string">'Flintstone'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其实内部相当于调用了<code>createInstance(config)</code>方法。</p>
<h3 id="axios-create"><a href="#axios-create" class="headerlink" title="axios.create()"></a>axios.create()</h3><p>这个方法不是能直接发起请求的，而是创建一个Axios实例，然后在通过实例的<code>request()</code>方法或者其他实例上的方法去发起请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an instance using the config defaults provided by the library</span></span><br><span class="line"><span class="comment">// At this point the timeout config value is `0` as is the default for the library</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create();</span><br><span class="line"></span><br><span class="line">instance.get(<span class="string">'/longRequest'</span>, &#123;</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="axios-method"><a href="#axios-method" class="headerlink" title="axios[method]()"></a><code>axios[method]()</code></h3><p>这个方法比较直观，根据请求的<code>method</code>，可以选择对应的请求方法，比如get请求可以使用<code>axios.get</code>，post请求可以使用<code>axios.post</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">'/user/12345'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>这些方法其实都是封装了<code>axios.request()</code>方法的，只是把传入的参数中<code>method</code>固定下来。</p>
<h3 id="new-axios-Axios"><a href="#new-axios-Axios" class="headerlink" title="new axios.Axios"></a>new axios.Axios</h3><p>这个也是用来创建axios实例的，然后再用axios实例去调方法实现调起请求。</p>
<h3 id="axios-request"><a href="#axios-request" class="headerlink" title="axios.request()"></a>axios.request()</h3><p><code>request()</code>是axios中最重要的方法之一，上面所有的调起请求的方式都是基于这个方法，也是我们下面学习源码最先解读的内容。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><h3 id="关键函数request-的实现"><a href="#关键函数request-的实现" class="headerlink" title="关键函数request()的实现"></a>关键函数request()的实现</h3><p>其实<code>request()</code>方法的源码非常少，很容易理解。主要分成两个部分，第一部分是整理合并<code>config</code>，第二部分是将拦截器的函数入栈<code>chain</code>，然后用<code>Promise</code>来执行。</p>
<p>这两个部分虽然没有提到发请求，但显而易见的是用<code>Promise</code>来执行时肯定是发了请求的。我们一步步来解读。</p>
<p>首先，第一部分是整理合并<code>config</code>。在这里，请求的配置除了传参进来的<code>config</code>之外，还有在<code>axios.defaults</code>中的配置。所以，需要先拿到<code>config</code>，然后跟<code>axios.defaults</code>得到本次请求的配置。</p>
<p><code>request()</code>方法的源码中，对<code>config</code>做了统一格式的处理。因为我们知道<code>request()</code>方法的传参其实支持不止一个。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种传参方式</span></span><br><span class="line">axios.request(&#123;</span><br><span class="line">  url: <span class="string">'/api'</span>,</span><br><span class="line">  method: <span class="string">'get'</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种传参方式</span></span><br><span class="line">axios.request(<span class="string">'/api'</span>, &#123;</span><br><span class="line">  method: <span class="string">'get'</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>所以会先判断<code>config</code>是否是<code>String</code>类型，如果是，则判断为传入<code>url</code>，第二个传参才是<code>config</code>，否则第一个传参就是<code>config</code>。同时也要判断没有传<code>config</code>的可能</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios.request 源码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> config === <span class="string">'string'</span>) &#123;</span><br><span class="line">  config = <span class="built_in">arguments</span>[<span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">  config.url = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  config = config || &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以合并请求配置了。源码中使用了<code>mergeConfig()</code>这个方法来处理两个配置对象的合并。这个方法内部其实是针对axios的所有配置做了专门的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config = mergeConfig(<span class="keyword">this</span>.defaults, config);</span><br></pre></td></tr></table></figure>
<h4 id="合并配置方法mergeConfig"><a href="#合并配置方法mergeConfig" class="headerlink" title="合并配置方法mergeConfig()"></a>合并配置方法<code>mergeConfig()</code></h4><p>这个方法传参只有两个，<code>config1</code>和<code>config2</code>。内部处理的流程是声明了三类配置属性的数组<code>valueFromConfig2Keys</code>, <code>mergeDeepPropertiesKeys</code>, <code>defaultToConfig2Keys</code>，然后针对这三类做针对性的浅拷贝，深拷贝，默认值处理，接着再处理除这三类配置属性外其他配置属性的赋值，最后返回最终完整配置对象。</p>
<p>从整个处理流程来说，我认为方法中主要处理的三类配置属性应该是比较主要的配置，而且因为各自配置的不同需要分别处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios mergeConfig 源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * valueFromConfig2Keys这个数组保存有需要从用户获得的配置项</span></span><br><span class="line"><span class="comment">  * mergeDeepPropertiesKeys这个数组保存有需要深拷贝的配置项</span></span><br><span class="line"><span class="comment">  * defaultToConfig2Keys这个数组保存有axios已有默认值的配置项</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">var</span> valueFromConfig2Keys = [<span class="string">'url'</span>, <span class="string">'method'</span>, <span class="string">'data'</span>];</span><br><span class="line"><span class="keyword">var</span> mergeDeepPropertiesKeys = [<span class="string">'headers'</span>, <span class="string">'auth'</span>, <span class="string">'proxy'</span>, <span class="string">'params'</span>];</span><br><span class="line"><span class="keyword">var</span> defaultToConfig2Keys = [</span><br><span class="line">  <span class="string">'baseURL'</span>, <span class="string">'url'</span>, <span class="string">'transformRequest'</span>, <span class="string">'transformResponse'</span>, <span class="string">'paramsSerializer'</span>,</span><br><span class="line">  <span class="string">'timeout'</span>, <span class="string">'withCredentials'</span>, <span class="string">'adapter'</span>, <span class="string">'responseType'</span>, <span class="string">'xsrfCookieName'</span>,</span><br><span class="line">  <span class="string">'xsrfHeaderName'</span>, <span class="string">'onUploadProgress'</span>, <span class="string">'onDownloadProgress'</span>,</span><br><span class="line">  <span class="string">'maxContentLength'</span>, <span class="string">'maxBodyLength'</span>, <span class="string">'validateStatus'</span>, <span class="string">'maxRedirects'</span>, <span class="string">'httpAgent'</span>,</span><br><span class="line">  <span class="string">'httpsAgent'</span>, <span class="string">'cancelToken'</span>, <span class="string">'socketPath'</span>, <span class="string">'responseEncoding'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p><code>valueFromConfig2Keys</code>这类比较简单，但需要用户提供的，直接赋值即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios mergeConfig 源码</span></span><br><span class="line"><span class="comment">// 利用utils.forEach处理需要从用户获得的配置项</span></span><br><span class="line">utils.forEach(valueFromConfig2Keys, <span class="function"><span class="keyword">function</span> <span class="title">valueFromConfig2</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> config2[prop] !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    config[prop] = config2[prop];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>mergeDeepPropertiesKeys</code>这类配置的值类型可能是对象，需要做深拷贝：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios mergeConfig 源码</span></span><br><span class="line"><span class="comment">// 利用utils.forEach处理可能需要深拷贝的配置项</span></span><br><span class="line">utils.forEach(mergeDeepPropertiesKeys, <span class="function"><span class="keyword">function</span> <span class="title">mergeDeepProperties</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (utils.isObject(config2[prop])) &#123; <span class="comment">// 如果config2配置项值为对象，则使用深拷贝赋值</span></span><br><span class="line">    config[prop] = utils.deepMerge(config1[prop], config2[prop]);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> config2[prop] !== <span class="string">'undefined'</span>) &#123; <span class="comment">// 如果 config2配置项不为undefined，则直接赋值</span></span><br><span class="line">    config[prop] = config2[prop];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (utils.isObject(config1[prop])) &#123; <span class="comment">// 以上判断完config2，就判断config1的配置值是否为Object，是着使用深拷贝赋值</span></span><br><span class="line">    config[prop] = utils.deepMerge(config1[prop]);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> config1[prop] !== <span class="string">'undefined'</span>) &#123; <span class="comment">// 否则判断不为undefined就直接赋值</span></span><br><span class="line">    config[prop] = config1[prop];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>defaultToConfig2Keys</code>这类配置是已有默认配置，所以可以使用默认值赋值。但内部还是做了<code>undefined</code>的判断，因为<code>axios.default</code>的配置值用户是可以修改的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios mergeConfig 源码</span></span><br><span class="line"><span class="comment">// 利用utils.forEach来处理其他axios已有默认值的配置项</span></span><br><span class="line">utils.forEach(defaultToConfig2Keys, <span class="function"><span class="keyword">function</span> <span class="title">defaultToConfig2</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> config2[prop] !== <span class="string">'undefined'</span>) &#123; <span class="comment">// 如果config2中有配置且不为undefined，则赋值</span></span><br><span class="line">    config[prop] = config2[prop];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> config1[prop] !== <span class="string">'undefined'</span>) &#123; <span class="comment">// 否则判断config1中配置不为undefined，则赋值</span></span><br><span class="line">    config[prop] = config1[prop];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最后的部分就是集合三个分类的配置属性，去筛选出不在这其中的用户配置属性，再去处理赋值，只做浅拷贝。这些配置可能用户也会在<code>axios.default</code>上设置默认值，所以也要考虑处理默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios mergeConfig 源码</span></span><br><span class="line"><span class="comment">// 合并所有前面已处理赋值的配置属性</span></span><br><span class="line"><span class="keyword">var</span> axiosKeys = valueFromConfig2Keys</span><br><span class="line">  .concat(mergeDeepPropertiesKeys)</span><br><span class="line">  .concat(defaultToConfig2Keys);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选出前面未处理到的用户配置属性</span></span><br><span class="line"><span class="keyword">var</span> otherKeys = <span class="built_in">Object</span></span><br><span class="line">  .keys(config2)</span><br><span class="line">  .filter(<span class="function"><span class="keyword">function</span> <span class="title">filterAxiosKeys</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> axiosKeys.indexOf(key) === <span class="number">-1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理前面未处理到的用户配置属性赋值</span></span><br><span class="line">utils.forEach(otherKeys, <span class="function"><span class="keyword">function</span> <span class="title">otherKeysDefaultToConfig2</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> config2[prop] !== <span class="string">'undefined'</span>) &#123; <span class="comment">// 判断config2中配置非undefined则赋值</span></span><br><span class="line">    config[prop] = config2[prop];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> config1[prop] !== <span class="string">'undefined'</span>) &#123; <span class="comment">// 否则再判断config1中是否有默认非undefined值，有则赋值</span></span><br><span class="line">    config[prop] = config1[prop];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="处理拦截器及请求"><a href="#处理拦截器及请求" class="headerlink" title="处理拦截器及请求"></a>处理拦截器及请求</h4><p>在这之前，先处理了请求的<code>method</code>，如果用户有传就将值改全小写，都没有就默认为<code>get</code>。</p>
<p>接下来的部分我认为很精巧。在调请求之前，因为axios还支持请求拦截器跟响应拦截器，所以这里使用类栈的方案。</p>
<p>先设置一个数组，这个数组默认有两个元素，一个是<code>dispatchRequest</code>，就是发送请求的方法，另一个是<code>undefined</code>。然后遍历请求拦截器，把其中的两个函数从数组的头部插入，再遍历响应拦截器，把两个函数从数组的尾部插入。这样一来，数组的结构就是从头到尾为就是按照请求的过程排好了请求拦截器一对对函数，然后是请求函数跟<code>undefined</code>，然后是响应拦截器一对对函数。</p>
<p>然后声明一个<code>Promise.resolve()</code>后返回的<code>promise</code>, 把数组中从头部开始一对对函数的传入<code>promise.then()</code>中。</p>
<p>这个操作可以利用<code>promise.then()</code>的特点，自动通过promise链去调用方法。如果请求拦截器中有报错，则最后不会调<code>dispatchRequest</code>方法并断掉。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios.request 源码</span></span><br><span class="line"><span class="comment">// Hook up interceptors middleware</span></span><br><span class="line"><span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.interceptors.request.forEach(<span class="function"><span class="keyword">function</span> <span class="title">unshiftRequestInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">  chain.unshift(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.interceptors.response.forEach(<span class="function"><span class="keyword">function</span> <span class="title">pushResponseInterceptors</span>(<span class="params">interceptor</span>) </span>&#123;</span><br><span class="line">  chain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">  promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后返回这个<code>promise</code>使得我们调请求时可以用promise的方法继续处理。</p>
<h3 id="其他请求方法的实现"><a href="#其他请求方法的实现" class="headerlink" title="其他请求方法的实现"></a>其他请求方法的实现</h3><p>那么<code>request()</code>这个方法是怎么演变出这么多种调用方式的呢？</p>
<p>首先，在<code>Axios</code>这个类下，提供了一堆<code>axios[method]()</code>的方法，作者是通过两个<code>forEach</code>来实现的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Axios 源码</span></span><br><span class="line"><span class="comment">// Provide aliases for supported request methods</span></span><br><span class="line"><span class="comment">// 这里提供了methods方法，是通过封装request来实现的，换言之所有逻辑都在request中</span></span><br><span class="line">utils.forEach([<span class="string">'delete'</span>, <span class="string">'get'</span>, <span class="string">'head'</span>, <span class="string">'options'</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodNoData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*eslint func-names:0*/</span></span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">url, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(utils.merge(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">utils.forEach([<span class="string">'post'</span>, <span class="string">'put'</span>, <span class="string">'patch'</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodWithData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*eslint func-names:0*/</span></span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span>(<span class="params">url, data, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.request(utils.merge(config || &#123;&#125;, &#123;</span><br><span class="line">      method: method,</span><br><span class="line">      url: url,</span><br><span class="line">      data: data</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后引入的<code>axios</code>，实际是先调用了<code>createInstance()</code>方法，这个方法里声明一个<code>instance</code>的变量，通过<code>bind</code>方法得到了一个上下文为<code>Axios</code>实例的<code>Axios.prototype.request()</code>方法，最后返回<code>instance</code>。所以我们可以直接调用<code>axios</code>方法发请求。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios 源码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">defaultConfig</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个Axios实例</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">new</span> Axios(defaultConfig);</span><br><span class="line">  <span class="comment">// 返回一个function，this指向context，即Axios实例</span></span><br><span class="line">  <span class="comment">// 相当于instance(args)会变成Axios.prototype.request.apply(context, args)</span></span><br><span class="line">  <span class="keyword">var</span> instance = bind(Axios.prototype.request, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy axios.prototype to instance</span></span><br><span class="line">  <span class="comment">// 把Axios.prototype上的属性方法复制到instance上，this指向context</span></span><br><span class="line">  utils.extend(instance, Axios.prototype, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy context to instance</span></span><br><span class="line">  <span class="comment">// 把context复制到instance</span></span><br><span class="line">  utils.extend(instance, context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的instance上有Axios类上的方法，有Axios实例上所有属性跟方法</span></span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the default instance to be exported</span></span><br><span class="line"><span class="keyword">var</span> axios = createInstance(defaults);</span><br></pre></td></tr></table></figure>
<p>而<code>axios.create()</code>方法内部就是直接使用了<code>createInstance()</code>, <code>axios.Axios</code>就是直接暴露<code>Axios</code>类。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>关于axios请求的源码分析就整理完了，下一篇会来了解一下axios是怎么实现请求取消的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/30/webpack-summary6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/30/webpack-summary6/" itemprop="url">webpack4配置总结(六)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-30T21:25:37+08:00">
                2020-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇整理了<code>plugins</code>的配置。这篇开始整理webpack其他的一些配置项。</p>
<h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a><code>resolve</code></h3><p><code>resolve</code>是指定webpack打包构建过程中模块如何解析的相关配置。比如代码中的模块路径怎么解析，文件名怎么解析。这里简单整理一下两个配置项<code>extensions</code>及<code>alias</code>。</p>
<h4 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a><code>extensions</code></h4><p><code>extensions</code>是用来解析文件名的。我们一般会在引用文件是省略掉一些文件的扩展名，那么配置这一项可以告诉webpack，在解析省略扩展名的文件时，去匹配什么扩展名。这个配置项接受一个数组，这个数组列举了需要匹配的扩展名。匹配上顺序是数组从左到右，即优先匹配数组左侧的元素。如配置了<code>[&#39;.js&#39;, &#39;.vue&#39;]</code>，则当遇到<code>/src/main</code>这个文件名时，会先在<code>src</code>目录下匹配是否存在<code>main.js</code>文件，有则解析这个文件，没有则继续匹配判断是否存在<code>main.vue</code>文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>], <span class="comment">// 自动解析确定的扩展名</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a><code>alias</code></h4><p><code>alias</code>是用来创建<code>import</code>或<code>require</code>的别名，换言之，我们可以通过别名来压缩长路径。比如说，我们需要在文件中引入一个<code>src</code>目录下另一个目录中的文件，如果文件的层级很深，可能会写出<code>import xxx from &#39;../../../components/btn.vue&#39;</code>。通过配置别名，我们可以把<code>@</code>作为<code>src</code>目录的别名，这样就可以把前面的代码改写成<code>import xxx from &#39;@/components/btn.vue&#39;</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123; <span class="comment">// 配置模块引入中的别名</span></span><br><span class="line">    <span class="string">'vue'</span>: <span class="string">'vue/dist/vue.esm.js'</span>,</span><br><span class="line">    <span class="string">'@'</span>: path.join(__dirname, <span class="string">"../src"</span>),</span><br><span class="line">    <span class="string">'@images'</span>: path.join(__dirname, <span class="string">"../src/common/images"</span>),</span><br><span class="line">    <span class="string">'@components'</span>: path.join(__dirname, <span class="string">"../src/components"</span>),</span><br><span class="line">    <span class="string">'@common'</span>: path.join(__dirname, <span class="string">"../src/common"</span>),</span><br><span class="line">    <span class="string">'@api'</span>: path.join(__dirname, <span class="string">"../src/api"</span>),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a><code>devServer</code></h3><p><code>devServer</code>这个配置项是需要安装<code>webpack-dev-server</code>来启用的，用来配置本地服务器的。只要安装了<code>webpack-dev-server</code>就可以使用它来在本地启动服务器进行项目本地调试。不过还是有一些可配置的选项的。</p>
<p><code>port</code>可以配置端口，默认是8080，如果有多个本地项目运行占用了8080端口，会自动后移端口号。<code>compress</code>为配置是否启用gzip压缩，可以提升返回页面的速度。<code>contentBase</code>为配置webpack启动在哪个目录下启动服务。<code>historyApiFallback</code>为配置是否启用HTML5 History API，当出现404响应时会被替代为<code>index.html</code>，这一项可以配置布尔值，也可以进一步配置选项。还有其他的选项可以到官网上查看。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  <span class="comment">// 开发服务的配置</span></span><br><span class="line">  <span class="comment">// port: 8080, // 不配置默认为8080，如果同时有多个本地项目运行且占用8080端口，会自动改端口</span></span><br><span class="line">  compress: <span class="literal">true</span>, <span class="comment">// 启用gzip压缩 可以提升返回页面的速度</span></span><br><span class="line">  contentBase: path.resolve(__dirname, <span class="string">'../dist'</span>), <span class="comment">// webpack 启动服务会在dist目录下 </span></span><br><span class="line">  historyApiFallback: <span class="literal">true</span> <span class="comment">// 当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a><code>optimization</code></h3><p><code>optimization</code>是webpack的优化配置项，从webpack4开始，用来根据不同的打包环境（设置<code>mode</code>）对打包进行优化，而且支持手动配置及重写的。<code>optimization</code>的可选配置项，有些是设置值，有些是通过引入插件来实现的，所以这里会结合实际情况来整理一些配置项的使用方法。</p>
<h4 id="minimizer"><a href="#minimizer" class="headerlink" title="minimizer"></a><code>minimizer</code></h4><p><code>minimizer</code>支持用户自定义打包压缩的插件，并替换掉webpack默认的压缩插件。一方面，用户可以自行选择压缩js代码的插件，另一方面，项目中还有其他编程语言需要使用压缩插件。webpack打包压缩默认只压缩js代码，但是css代码并没有压缩。而如果指定了压缩css代码的插件，那么原有的压缩js代码的功能就会被覆盖掉，所以同时也需要指定压缩js代码的插件。这里就使用到了<code>optimize-css-assets-webpack-plugin</code>及<code>terser-webpack-plugin</code>。</p>
<h5 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a><code>optimize-css-assets-webpack-plugin</code></h5><p><code>optimize-css-assets-webpack-plugin</code>是用来压缩优化css代码的插件，默认使用<code>cssnano</code>来压缩优化。它接收5个配置项，分别是：<code>assetnameRegExp</code>（一个匹配文件的正则表达式），<code>cssProcessor</code>（自定义用于优化压缩css的处理器），<code>cssProcessorOptions</code>（传递给css处理器的选项）， <code>cssProcessorPluginOptions</code>（传递给css处理器的插件选项）及<code>canPrint</code>（一个布尔值，指定是否可以将信息打印到控制台）。</p>
<h5 id="terser-webpack-plugin"><a href="#terser-webpack-plugin" class="headerlink" title="terser-webpack-plugin"></a><code>terser-webpack-plugin</code></h5><p><code>terser-webpack-plugin</code>是用来压缩js代码的插件。因为配置了<code>minimizer</code>，覆盖了默认的压缩功能，所以也需要配置压缩js的插件。这个插件有比较多的配置项，不过不配置也可以达到最佳的优化效果，所以需要配置可以去看官方文档。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  minimizer: [</span><br><span class="line">    <span class="keyword">new</span> OptimizeCSSAssetsPlugin(), <span class="comment">// 压缩css，但使用之后js文件也需要手动压缩</span></span><br><span class="line">    <span class="keyword">new</span> TerserWebpackPlugin(), <span class="comment">// 压缩js</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="runtimeChunk"><a href="#runtimeChunk" class="headerlink" title="runtimeChunk"></a><code>runtimeChunk</code></h4><p><code>runtimeChunk</code>是用来优化持久化缓存的。从我的理解来说，<code>runtimeChunk</code>默认是<code>false</code>，意思是webpack打包构建之后，会各个模块之间的引用和加载的逻辑内嵌到模块中，如果某个模块发生改变时，会导致除了除此之外引用及加载的模块一并发生改变，导致缓存失败。</p>
<p>如果设置为<code>true</code>（也可以是一个<code>object</code>配置对象来表示启用）或者<code>multiple</code>，会在打包构建之后，给每个入口文件都生成一个对应的<code>runtime</code>文件，里面会存放有生成一个包含chunk映射关系的表。一旦某个模块发生改变时，只会修改该模块跟对应的<code>runtime</code>文档，不会影响到引用及加载的模块，实现持久化缓存。</p>
<p>如果设置<code>single</code>，则表示在打包构建之后，只生成一个<code>runtime</code>文件，存放项目所有chunk映射关系表。</p>
<p>如果是一个<code>object</code>配置对象，里面可以配置<code>name</code>来指定生成的<code>runtime</code>文件的命名。</p>
<h4 id="splitChunks"><a href="#splitChunks" class="headerlink" title="splitChunks"></a><code>splitChunks</code></h4><p><code>splitChunks</code>这个配置项是用来定义使用什么策略拆分打包模块。里面有非常多的可配置选项来制定你的拆分打包策略。下面来一个个的介绍配置项：</p>
<h5 id="chunks"><a href="#chunks" class="headerlink" title="chunks"></a><code>chunks</code></h5><p><code>chunks</code>用来指定哪些模块会应用优化。支持配置三个值<code>all</code>，<code>async</code>，<code>initial</code>。<code>all</code>是指同时拆分同步和异步代码，<code>async</code>是默认值，指只拆分异步代码，<code>initial</code>虽然也会同时拆分同步和异步代码，但是异步代码内容不会再拆分。</p>
<h5 id="minSize"><a href="#minSize" class="headerlink" title="minSize"></a><code>minSize</code></h5><p><code>minSize</code>用来指定文件超过<code>minSize</code>值则会启用抽离。</p>
<h5 id="maxSize"><a href="#maxSize" class="headerlink" title="maxSize"></a><code>maxSize</code></h5><p><code>maxSize</code>用来指定拆分的模块最大尺寸，不过有些模块即使大小超过<code>maxSize</code>，但是拆分不一定是最佳选择。</p>
<h5 id="minChunks"><a href="#minChunks" class="headerlink" title="minChunks"></a><code>minChunks</code></h5><p><code>minChunks</code>指定模块至少达到<code>minChunks</code>引用次数才会启用抽离。</p>
<h5 id="maxAsyncRequests"><a href="#maxAsyncRequests" class="headerlink" title="maxAsyncRequests"></a><code>maxAsyncRequests</code></h5><p><code>maxAsyncRequests</code>指定并行请求数量</p>
<h5 id="maxInitialRequests"><a href="#maxInitialRequests" class="headerlink" title="maxInitialRequests"></a><code>maxInitialRequests</code></h5><p><code>maxInitialRequests</code>指定首屏并行请求数量</p>
<h5 id="automaticNameDelimiter"><a href="#automaticNameDelimiter" class="headerlink" title="automaticNameDelimiter"></a><code>automaticNameDelimiter</code></h5><p><code>automaticNameDelimiter</code>指定拆分模块的命名的界定符。webpack默认拆分模块的命名会使用模块的来源和名称使用界定符来生成。默认界定符为<code>~</code>。</p>
<h5 id="automaticNameMaxLength"><a href="#automaticNameMaxLength" class="headerlink" title="automaticNameMaxLength"></a><code>automaticNameMaxLength</code></h5><p><code>automaticNameMaxLength</code>指定拆分模块的命名的最大长度。</p>
<h5 id="cacheGroups"><a href="#cacheGroups" class="headerlink" title="cacheGroups"></a><code>cacheGroups</code></h5><p><code>cacheGroups</code>用来自定义缓存组。<code>cacheGroups</code>接受一个对象，这个对象的键名为缓存组组名，值是一个对象，可以设置一系列相关配置。如果需要禁用默认缓存组，可以在<code>cacheGroups</code>下设置<code>default: false</code>。缓存组有以下配置项：</p>
<p><code>priority</code>是用来设定缓存组的优先级。因为一个模块可以属于多个缓存组，所以模块会根据缓存组的优先级来选定放在哪个缓存组中。</p>
<p><code>reuseExistingChunk</code>是用来指定当前模块包含从主模块中拆分出来的模块，是否重用该模块。</p>
<p><code>test</code>是用来指定缓存组选择的模块，接受一个正则表达式来匹配模块名或路径。</p>
<p><code>filename</code>指定缓存组模块的文件名占位符</p>
<p><code>enforce</code>指定webpack是否忽略<code>splitChunks.minSize</code>，<code>splitChunks.minChunks</code>，<code>splitChunks.maxAsyncRequests</code>和<code>splitChunks.maxInitialRequests</code>，只创建缓存组模块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">  splitChunks: &#123;</span><br><span class="line">    chunks: <span class="string">'all'</span>, <span class="comment">// 'async' 默认支持异步的代码分割 如import()</span></span><br><span class="line">    minSize: <span class="number">30000</span>, <span class="comment">// 文件超过30k，就会抽离</span></span><br><span class="line">    maxSize: <span class="number">0</span>,</span><br><span class="line">    minChunks: <span class="number">1</span>, <span class="comment">// 最少模块引用1次才抽离</span></span><br><span class="line">    maxAsyncRequests: <span class="number">6</span>, <span class="comment">// 最多6个请求</span></span><br><span class="line">    maxInitialRequests: <span class="number">4</span>, <span class="comment">// 最多首屏加载4个请求</span></span><br><span class="line">    automaticNameDelimiter: <span class="string">'~'</span>, <span class="comment">// 抽离文件名***~a~b，代表a,b都有引用，使用~来分隔</span></span><br><span class="line">    automaticNameMaxLength: <span class="number">30</span>, <span class="comment">// 最长名字大小</span></span><br><span class="line">    cacheGroups: &#123; <span class="comment">// 缓存组</span></span><br><span class="line">      vues: &#123;</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]\/vue|vue-router|vuex/</span>,</span><br><span class="line">        priority: <span class="number">1</span> <span class="comment">// 优先级</span></span><br><span class="line">      &#125;,</span><br><span class="line">      vendors: &#123;</span><br><span class="line">        test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        priority: <span class="number">-10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">default</span>: &#123;</span><br><span class="line">        minChunks: <span class="number">1</span>, <span class="comment">// 至少引用1次</span></span><br><span class="line">        priority: <span class="number">-20</span>,</span><br><span class="line">        reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>至此，整理完了我的模板项目的webpack配置。</p>
<p>这套webpack配置我也尝试改成基于React的项目，也能成功的跑通。当然，webpack的配置不一定每个项目都相同，都是有不同的需求跟优化的空间。目前我这个模板项目还是有一些地方可以再优化，或者在我更深入了解webpack之后可能又会有更好的配置。之后还有webpack5，也是以后需要去研究应用的内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/30/webpack-summary5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/30/webpack-summary5/" itemprop="url">webpack4配置总结(五)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-30T21:24:53+08:00">
                2020-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇整理了<code>babel</code>跟<code>postcss-loader</code>的配置，结束了webpack的<code>loader</code>部分。这边开始整理<code>plugins</code>。</p>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a><code>plugins</code></h3><p><code>plugins</code>插件是用来拓展webpack功能的。他们会在整个webpack打包构建过程中生效，执行相关的任务。插件与<code>laoder</code>不同，<code>loader</code>主要是处理某一些源文件的，用完就不需要了，但是插件是在一直作用于构建中。</p>
<p>使用插件时，需要先<code>npm</code>安装插件，然后在<code>plugins</code>属性下添加插件的实例。<code>plugins</code>属性接受的值是一个数组。</p>
<p>插件有很多，根据项目的需求使用的插件也不一样，不像loader那种可能比较固定。所以这里就结合项目需求来整理插件。</p>
<h4 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a><code>DefinePlugin</code></h4><p>我们一般会需要在项目全局上设置一些常量，比如不同环境下，可能需要设定版本，不同的请求域名，可能需要标识常量来区分测试环境跟生产环境。但是在开发项目时，这些值可能需要在打包前根据打包的环境不同手动修改。如果常量不多还好，如果很多，容易改错，或者忘记修改，导致项目上线不正常。</p>
<p><code>DefinePlugin</code>是webapck官方插件，这个插件允许创建一个在编译时可以配置的全局常量。这个插件就可以很好的解决这个问题。</p>
<p>这个插件允许用户自定义键值对，其中对键值有四个判断处理：</p>
<blockquote>
<ol>
<li>如果这个值是一个字符串，它会被当作一个代码片段来使用。   </li>
<li>如果这个值不是字符串，它会被转化为字符串(包括函数)。   </li>
<li>如果这个值是一个对象，它所有的 key 会被同样的方式定义。   </li>
<li>如果在一个 key 前面加了 typeof,它会被定义为 typeof 调用。</li>
</ol>
</blockquote>
<p>使用时，直接使用常量即可，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack配置</span></span><br><span class="line"><span class="keyword">const</span> webpack =  <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">let</span> isDev = env.development;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="comment">// 可以在项目中拿到当前环境变量</span></span><br><span class="line">    <span class="string">'NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(isDev ? <span class="string">'dev'</span> : <span class="string">'prod'</span>),</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 项目中业务代码</span></span><br><span class="line"><span class="keyword">if</span> (NODE_ENV === <span class="string">'dev'</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="vue-loader-plugin"><a href="#vue-loader-plugin" class="headerlink" title="vue-loader plugin"></a>vue-loader plugin</h4><p>当项目是基于Vuejs开发时，webpack就需要配置vue-loader plugin。通过官方文档可以知道，这个插件就是用来处理.vue文件中各个模块匹配不同<code>loader</code>。如前面.js文件配置的loader会应用到.vue文件中的script模块，.css文件，.scss文件配置的loader会应用到.vue文件中的style模块。</p>
<p>这个插件不是独立的，是配置<code>vue-loader</code>的时候同时需要使用到的，在<code>vue-loader/lib/plugin</code>目录下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> VueLoaderPlugin(), <span class="comment">// 作用是处理匹配.vue文件的rule</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a><code>html-webpack-plugin</code></h4><p>前面写了这么一系列的配置，但是有个关键的问题，就是打包后的文件会从哪里引用。因为是网页，所以一定需要用一个html文件来引用。但是手动创建一个比较麻烦。这里就可以使用<code>html-webpack-plugin</code>这个插件。</p>
<p>这个插件可以自动生成一个html文件，并使用<code>script</code>标签引入打包后的文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>上面就是最简单的配置，打包之后会生成一个<code>index.html</code>。</p>
<p>这个插件也支持配置。详细的配置项可以通过官网查看。这里简单介绍几个配置项：</p>
<p><code>template</code>用来配置生成<code>index.html</code>基于的模板，值是模板在项目中的相对路径或者绝对路径。</p>
<p><code>filename</code>用来配置生成html文件的命名，默认为<code>index.html</code>。</p>
<p><code>minify</code>用来配置在打包生产环境时生成的html文件压缩设置。这个配置项默认在生成环境下为true，也可以手动配置压缩哪些，比如去除空白，删除注释等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">let</span> isDev = env.development;</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="comment">// 自动生成html文件</span></span><br><span class="line">    template: path.resolve(__dirname, <span class="string">'../public/index.html'</span>), <span class="comment">// 配置生成HTML文件的模板</span></span><br><span class="line">    filename: <span class="string">'index.html'</span>, <span class="comment">// 生成html文件的命名</span></span><br><span class="line">    minify: !isDev &amp;&amp; &#123;</span><br><span class="line">      removeComments: !isDev, <span class="comment">// 移除注释</span></span><br><span class="line">      removeAttributeQuotes: !isDev, <span class="comment">// 移除引号</span></span><br><span class="line">      collapseWhitespace: !isDev <span class="comment">// 折叠空白</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="html-webpack-tags-plugin"><a href="#html-webpack-tags-plugin" class="headerlink" title="html-webpack-tags-plugin"></a><code>html-webpack-tags-plugin</code></h4><p>我们在项目中不免会需要在html文件中直接引入一些文件，比如用来重写标签一般样式的css文件，项目中涉及微信api时需要引入相关的js文件。这些文件我们当然可以直接利用<code>html-webpack-plugin</code>，把需要引入文件写到html模板文件中，然后打包的时候直接生成。不过这样肯定有些人觉得不够优雅。那么就可以试试使用<code>html-webpack-tags-plugin</code>这个插件。</p>
<p><code>html-webpack-tags-plugin</code>这个插件支持在打包的时候把配置文件自动引入到html文件中。这样我们就可以在webpack配置中对引入的文件一目了然。</p>
<p><code>html-webpack-tags-plugin</code>也有很多配置项，我这里也只是对几个用上的配置项做介绍，其他配置项可以根据项目需求使用。</p>
<p><code>tags</code>用来指定需要插入的文件列表。这个配置项接受一个数组，这个数据的元素可以是字符串，表示引入的文件地址，也可以是一个json格式，可以配置除了引入文件的地址<code>path</code>之外其他配置。如<code>type</code>指定文件类型，<code>publicPath</code>指定文件路径前是否需要应用<code>publicPath</code>。</p>
<p><code>append</code>用来指定是否将<code>tags</code>中列出的文件在打包文件位置前引入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackTagsPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-tags-plugin'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackTagsPlugin(&#123; <span class="comment">// 在html文件中插入引用文件</span></span><br><span class="line">    tags: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">'//res.wx.qq.com/open/js/jweixin-1.4.0.js'</span>,</span><br><span class="line">        type: <span class="string">'js'</span>,</span><br><span class="line">        publicPath: <span class="literal">false</span>, <span class="comment">//不在路径面前应用publicPath </span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    append: <span class="literal">false</span>, <span class="comment">//插入顺序在打包文件前面</span></span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a><code>clean-webpack-plugin</code></h4><p><code>clean-webpack-plugin</code>这个插件是用来在打包输出文件之前，清理打包输出目录文件的工具。一般我们配置的打包输出目录是固定的，每次打包如果不清除目录内的文件，会导致目录内的文件越来越多。在这种情况下，我们可以使用这个插件来清除。</p>
<p>这里有一个实际使用的问题。旧版本的<code>clean-webpack-plugin</code>不会清除隐藏文件及目录，但是新版本中会完全清除。这就导致出现一个问题。在实际业务中，打包目录有可能就是远程仓库对应的目录，那么目录中是会有被隐藏的.git目录。如果直接使用新版的插件，打包时也会把.git目录清除，导致无法使用推送代码。</p>
<p>我查了官方文档及很多博客，也没有找到比较合适的解决方案，但是还是找到了<code>cleanOnceBeforeBuildPatterns</code>这个配置项。这个配置项可以指定哪些文件需要清除的。它接受一个数组，数组的每一项都是一个正则。默认为全部清除。我就使用这个配置项来排除.git目录。最后是得到使用以下配置可以达到保留.git目录，其他文件清除的效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin(&#123; <span class="comment">// 输出打包文件前清除旧的打包文件</span></span><br><span class="line">    cleanOnceBeforeBuildPatterns: [<span class="string">'**/*'</span>, <span class="string">'!\.git'</span>, <span class="string">'!\.git/**/*'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a><code>mini-css-extract-plugin</code></h4><p>这个插件用来抽离css代码到一个单独的style文件。官方介绍有以下特点：1. 异步加载；2. 无重复编译；3. 使用简便；4. 针对css。</p>
<p>使用的时候，除了需要在<code>plugins</code>中new一个插件的实例，还需要在<code>loader</code>上配置对css打包上使用插件对应的loader。</p>
<p><code>mini-css-extract-plugin</code>也有一些配置项，最常用的就是<code>filename</code>及<code>chunkFilename</code>，用来配置css文件的命名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">let</span> isDev = env.development;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">          isDev ? <span class="string">'style-loader'</span> : MiniCssExtractPlugin.loader, <span class="comment">// 一般使用MiniCssExtractPlugin就不使用style-loader</span></span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    !isDev &amp;&amp; <span class="keyword">new</span> MiniCssExtractPlugin(&#123; <span class="comment">// 将css单独打包成一个文件的插件，它为每个包含css的js文件都创建一个css文件。它支持css和sourceMaps的按需加载。</span></span><br><span class="line">      filename: <span class="string">'main.css'</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ].filter(<span class="built_in">Boolean</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a><code>webpack-bundle-analyzer</code></h4><p>这个插件是用来分析打包文件的，目的是让打包的项目以图表的形式展示给开发者，可以直观的分析项目打包文件的情况，为优化做判断。配置这个插件后，在打包完成之后，会启动http服务器打开一个页面来显示打包文件的情况。</p>
<p>使用也比较简单，也有一些配置项，这里项目中没有用到，就简单略过：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> BundleAnalyzerPlugin() <span class="comment">// 打包代码分析</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>接下来将整理剩下的webpack配置中剩下的部分。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/30/webpack-summary4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/30/webpack-summary4/" itemprop="url">webpack4配置总结(四)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-30T21:24:09+08:00">
                2020-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇整理了loader的使用，这篇整理一下<code>babel</code>跟<code>postcss-loader</code>的配置。</p>
<h3 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a><code>.babelrc</code></h3><h4 id="插件跟预设"><a href="#插件跟预设" class="headerlink" title="插件跟预设"></a>插件跟预设</h4><p>其实，<code>.babelrc</code>配置文件是用来支持我们在使用babel解析编译代码时，使用一些插件来处理高版本语法或者提案语法。插件跟预设的区别在于，预设其实是一些插件的组合，它方便我们处理一类语法的打包编译问题，不需要我们手动配置一系列插件。<code>.babelrc</code>里只需要写成一个JSON格式。</p>
<h4 id="预设-babel-preset-env"><a href="#预设-babel-preset-env" class="headerlink" title="预设@babel/preset-env"></a>预设@babel/preset-env</h4><p>按照官网的说法，<code>@babel/preset-env</code>是一个智能的预设，它可以解析编译最新的js语法。它可以根据目标浏览器环境情况编译合适的插件列表，使编译打包后的项目能在目标浏览器环境中正常运行。</p>
<p>而目标浏览器的罗列，可以在<code>package.json</code>中使用<code>browserslist</code>属性设置，也可以设置预设属性<code>targets</code>，还可以在项目根目录上创建<code>.browserslistrc</code>来设置，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .browserslistrc</span></span><br><span class="line">cover <span class="number">95</span>%</span><br></pre></td></tr></table></figure>
<p><code>@babel/preset-env</code>除了上面提到的<code>targets</code>配置项外，还有两个配置项是在我的项目中使用到的。一个是<code>useBuiltIns</code>，另一个是<code>corejs</code>，两个配置项有关联。</p>
<p><code>useBuiltIns</code>有三个值，其中默认值为<code>false</code>，意思是不引入babel编译的结果，把引入的位置，引入那些polyfill交给用户处理。之前的做法是安装<code>@bable/polyfill</code>，然后在入口文件中引入，但其实这样会引入很多用不着的polyfill。</p>
<blockquote>
<p>这里说明一下，polyfill在MDN上有定义解释，我这里就摘一下：</p>
<blockquote>
<p>Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。<br>比如说 polyfill 可以让 IE7 使用 Silverlight 插件来模拟 HTML Canvas 元素的功能，或模拟 CSS 实现 rem 单位的支持，或 text-shadow，或其他任何你想要的功能。</p>
</blockquote>
</blockquote>
<p>如果设置值为<code>entry</code>，则会将文件中<code>import &#39;@babel/polyfilll&#39;</code>语句结合<code>targets</code>，转换为一系列引入语句，去掉目标浏览器已支持的polyfilll模块，不管代码里有没有用到，只要目标浏览器不支持都会引入对应的polyfilll 模块。虽然要比全部引入要好，但是使用不到的polyfill还是会有。</p>
<p>而且现在babel也废弃了<code>@bable/polyfill</code>，所以需要我们自己选择使用哪个兼容库。那么这里的<code>useBuiltIns</code>也就最好设置为<code>usage</code>。</p>
<p>设置<code>usage</code>，则不需要手动在代码中引入<code>@babel/polyfill</code>，而且打包的时候会根据实际代码的需要引入实际用上的polyfill模块。同时，因为<code>@babel/polyfill</code>已经不建议用，被废弃了，所以我们需要通过设置<code>corejs</code>来指明使用的那个版本的<code>core-js</code>。</p>
<blockquote>
<p>其实<code>@babel/polyfill</code>是对<code>core-js</code>(<code>core-js/stable</code>)做了封装，而且引用了<code>regenerator-runtime/runtime</code>。<br><code>core-js</code>其实是把所有新语法通过ES6之前的语法实现（现在已经支持到ES2019）。</p>
</blockquote>
<p>这里可以设置为<code>2</code>或<code>3</code>，指定使用<code>core-js</code>哪个版本。关于<code>core-js</code>到底使用<code>2</code>还是<code>3</code>，怎么选择，原因是什么，我也还没有搞得很明白，网上关于这方面的说法不多，目前自己的项目中用的是<code>2</code>，而且版本是<a href="mailto:`core-js@2.6.11" target="_blank" rel="noopener">`core-js@2.6.11</a>`，安装版本不同可能还会报错。所以这部分需要等以后了解了再整理出来。</p>
<p>所以最终预设的配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [ <span class="comment">// 预设，从下到上执行</span></span><br><span class="line">    [<span class="string">"@babel/preset-env"</span>, &#123;</span><br><span class="line">      <span class="string">"useBuiltIns"</span>: <span class="string">"usage"</span>, <span class="comment">// 使用的api 会自动转化 并且是按需加载</span></span><br><span class="line">      <span class="string">"corejs"</span>: <span class="number">2</span> <span class="comment">// 替换掉babel-polyfill，babel-polyfill已不建议使用</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>转回来我们来了解一下什么是插件。因为babel是一个编译器，虽然有解析，转换和打印输出三个步骤，但实际在转换上并不会做什么处理，也就是什么的不做就到打印输出了。但它支持插件，可以通过插件来进行代码转换。所以，所谓的插件，就是可以对babel解析的代码进行转换的编译工具（自己理解）。</p>
<p>配置插件，是通过<code>plugins</code>这个配置属性来配置的。<code>plugins</code>接受一个数组，这个数组用来列举插件。执行的顺序是从上到下。如果插件需要进一步配置，则写成数组。数组的第一项是插件名，第二项是配置json。</p>
<p>这里简单介绍一下我项目中使用到的插件：</p>
<p><code>@babel/plugin-proposal-decorators</code>插件是用来解析支持装饰器草案语法的，按babel的举例演示，实际上是把装饰器语法转换为高级函数，用来返回类或者函数。这个插件有两个可选配置，一个是<code>decoratorsBeforeExport</code>，用来指定是否支持<code>export</code>语法前使用装饰器。值为<code>true</code>和<code>false</code>。另一个是<code>legacy</code>，用来指定是否支持旧式装饰器的语法和行为，默认值为<code>false</code>。</p>
<p><code>@babel/plugin-proposal-class-properties</code>插件是用来解析支持class草案语法。这个插件有一个可选配置<code>loose</code>，这个配置默认为<code>false</code>，即</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  x = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中<code>x</code>会使用<code>Object.defineProperty</code>来严格定义。如果<code>loose</code>设置为<code>true</code>，则为宽松处理，<code>x</code>将直接使用赋值表达式来处理。</p>
<p>上面两个插件如果同时使用时，官网有对配置上有明确的说明，<code>@babel/plugin-proposal-decorators</code>必须要在<code>@babel/plugin-proposal-class-properties</code>前面调用，而且如果<code>@babel/plugin-proposal-decorators</code>的<code>legacy</code>设置了<code>true</code>，则要求<code>@babel/plugin-proposal-class-properties</code>的<code>loose</code>设置为<code>true</code>。</p>
<p>最后一个插件是<code>@babel/plugin-transform-runtime</code>。这个插件还需要安装<code>@babel/runtime</code>，是用例使用帮助函数来压缩代码。插件的功能是将编译后代码中把重复的代码块用过帮助函数来处理，使得代码量得以减少。</p>
<p>最后列一下配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [ <span class="comment">// 插件 从上到下执行</span></span><br><span class="line">    [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123;<span class="string">"legacy"</span>: <span class="literal">true</span>&#125;], <span class="comment">// 支持解析装饰器草案语法，legacy表示保留装饰器语法，需要@babel/plugin-proposal-class-properties的loose配置为true</span></span><br><span class="line">    [<span class="string">"@babel/plugin-proposal-class-properties"</span>, &#123;<span class="string">"loose"</span>: <span class="literal">true</span>&#125;], <span class="comment">// 支持解析class草案语法，loose表示宽松处理，即class A&#123;a = 1&#125;会转化为class A&#123;this.a = 1&#125;</span></span><br><span class="line">    <span class="string">"@babel/plugin-transform-runtime"</span> <span class="comment">// 需要安装@babel/runtime，使用帮助函数压缩代码</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="postcss-config-js"><a href="#postcss-config-js" class="headerlink" title="postcss.config.js"></a><code>postcss.config.js</code></h3><p>上篇说到，<code>postcss</code>是一个用来转化css代码的js工具，它支持配置插件来转化css代码，可以直接在webpack配置中配置<code>option</code>，也可以通过<code>postcss.config.js</code>来配置。</p>
<p>跟<code>.babelrc</code>的最外层写法不一样，<code>postcss.config.js</code>需要写成一个模块导出。里面的结构好像也不一样，只有一个<code>plugins</code>的配置项，这个配置项需要传入一个数组，这个数组的每一项就是需要使用的插件，通过<code>require</code>引入。</p>
<p>官方文档上列了很多插件，这里就不细细展开，只简单整理一下项目中使用的两个插件。</p>
<p><code>autoprefixer</code>插件是用来添加浏览器前缀。这个插件方便我们在打包的时候生成不同浏览器不同前缀的样式。</p>
<p><code>postcss-pxtorem</code>是用来把<code>px</code>单位转化为<code>rem</code>的插件。这个插件主要使用在移动端。移动端的屏幕尺寸有很多种，尺寸比例也各不相同。一般我们会使用<code>rem</code>的写法，只是一套经典的解决方案。这里使用<code>postcss-pxtorem</code>，配置的时候可以配置<code>rootValue</code>，用来指定一单位rem等于多少px。这样可以让你在开发时只要使用<code>px</code>，打包的时候会以375px视窗宽度换算宽度的rem值，然后项目上线后会以这个值来计算其他宽度的比例。比如<code>rootValue</code>设置37.5，则视窗宽度将固定为10rem，其他尺寸均以这个为标准。</p>
<p>这个插件让我们不需要关注怎么实现移动端屏幕适配问题。当然，如还有有些配置项还是需要注意的，如<code>propList</code>可以配置那些样式属性不需要转化，<code>unitPrecision</code>为转换成rem后保留的小数点位数，<code>exclude</code>为排除转化的目录。</p>
<p>还有一个问题，如果有需要不转化<code>px</code>，还可以写成<code>PX</code>。</p>
<p>最后，附上配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>),</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'postcss-pxtorem'</span>)(&#123;</span><br><span class="line">      rootValue: <span class="number">30.1932367</span>, <span class="comment">// body宽折算为12.42rem。如果这里设置37.5，则宽折算为10rem</span></span><br><span class="line">      unitPrecision: <span class="number">5</span>,</span><br><span class="line">      propList: [<span class="string">'*'</span>],</span><br><span class="line">      <span class="comment">// exclude: /node_modules/i</span></span><br><span class="line">    &#125;) </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来将整理webpack配置中的插件<code>plugins</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/30/webpack-summary3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/30/webpack-summary3/" itemprop="url">webpack4配置总结(三)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-30T21:23:13+08:00">
                2020-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇整理了webpack配置的四大配置概念。这篇来整理loader的使用。</p>
<h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>因为我的项目是基于Vue全家桶及sass的，所以<code>loader</code>部分会有偏向这方面的介绍，使用TS，React全家桶及less的可以找一下相应的<code>loader</code>。</p>
<p>webpack打包模块时，会把模块拿到<code>module</code>这里的<code>rules</code>中做匹配，如果匹配到，则使用对应的loader进行解析。</p>
<p>因为<code>loader</code>有很多，不好整理，所以我这里就按照项目中不同文件模块所需要的<code>loader</code>来整理说明。</p>
<h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><p>我们一般在基于vue全家桶项目目录中都会使用.vue文件来开发vue组件，所以.vue文件模块需要单独解析。而vue本身就有一个专门解析.vue文件的loader</p>
<h5 id="vue-loader"><a href="#vue-loader" class="headerlink" title="vue-loader"></a>vue-loader</h5><p><code>vue-loader</code>是一个专门解析.vue文件的loader，顾名思义，只是解析.vue文件，并不能解析内部的写法。因为.vue文件一般会有三个部分，一个是template模块，用来写模板语言；一个是script模块，用来写组件的js部分；一个是style模块，用来写组件的css部分。template模块是通过vue的一个plugin插件来解析处理的，script模块跟style模块则提供出来自定义loader进行解析。</p>
<p>所以在loader的配置上也比较简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: <span class="string">'vue-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><p>我们的项目中最多的代码就是js代码了，而且现在js的标准已经到了ES2020，很多ES6及以上的标准都需要编译成ES5才能在各种浏览器中使用，所以在webpack打包中，我们也需要解析项目中的js代码。这里就需要使用<code>babel-loader</code>。</p>
<h5 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h5><p>讲到babel，我们在webpack中使用的时候，其实有很多复杂的使用方式。这里先写一下在<code>module</code>中的内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单单只是这样配置是不足以完成js代码的解析的。实际上，如果你的代码中使用了es6及以上标准的语法，还需要配合<code>.babelrc</code>配置文件。这个配置文件的配置内容也是可以直接卸载 <code>rules</code>中，但是因为配置内容比较多，所以最好独立出来。</p>
<p>实际上，这里配置使用的<code>babel-loader</code>在解析代码时是调用了<code>@babel/core</code>，然后由<code>@babel/core</code>来转换代码。转换的过程中会调<code>.babelrc</code>配置文件中的配置。</p>
<p>关于<code>.babelrc</code>文件中的配置介绍，我会另起一篇来做详细介绍。</p>
<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><p>css也是项目中非常重要的一部分。我的项目中使用了sass来开发css。这里就需要安装使用以下loader：</p>
<h5 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h5><p><code>sass-loader</code>是用于解析sass语法的loader，使用这个loader时还需要安装<code>node-sass</code>依赖包。这个包是用于让sass可以在node端进行编译。</p>
<p>安装<code>node-sass</code>也有一些比较麻烦的地方。因为这个包是为了sass能在node端进行编译，所以它的版本要求比较高，不同版本对应不同的node版本范围，需要根据自己的node环境进行选择。同时，安装也不太顺利，一般的依赖包可以直接使用npm进行下载安装，而<code>node-sass</code>直接使用npm下载容易失败，需要考虑更换淘宝源或者使用cnpm安装。</p>
<h5 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h5><p><code>postcss-loader</code>简单的理解就是一个js工具，用来转化css代码，为css样式处理适配，抹平差异。因为不同浏览器的内核不一样，导致一些样式在各个浏览器中实现不一样。<code>postcss-loader</code>就是用来抹平浏览器之间的差异而出现的。可以让我们在开发时无需考虑这些问题。不过，为css样式加处理实际上不是这个loader本身实现的，而是通过如<code>autoprefixer</code>， <code>postcss-pxtorem</code>配合实现的，所以需要安装并配置。配置上也可以新建一个<code>postcss.config.js</code>。这个后面再单独整理。</p>
<h5 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h5><p><code>css-loader</code>主要是用于解释<code>@import</code>和<code>url()</code>，会在<code>import/require()</code>后再解析它们。loader有比较多的配置项，这里因为我的项目中只需要使用要<code>importLoaders</code>这个配置项，所以就只介绍这个，其他的配置项可以在webpack官网上查看。<code>importLoaders</code>是用来指定在<code>css-loader</code>之前使用loader的数量。如下配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="string">'vue-style-loader'</span>,</span><br><span class="line">    <span class="string">'style-loader'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'css-loader'</span>, <span class="comment">// 用于编译@import和url()跟解析css</span></span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="comment">// 在 loader 前应用的 loader 的数量，意思是解析css时需要用到'postcss-loader','sass-loader'</span></span><br><span class="line">        <span class="comment">// 因为引入的css文件中可能是sass文件</span></span><br><span class="line">        <span class="comment">// 如配置1，则应用'postcss-loader'，如配置2，则应用'postcss-loader','sass-loader'</span></span><br><span class="line">        importLoaders: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'postcss-loader'</span>,</span><br><span class="line">    <span class="string">'sass-loader'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上面配置中，<code>importLoaders</code>设置了<code>2</code>，指定在<code>css-loader</code>之前使用2个loader，而且指定的loader就是<code>postcss-loader</code>跟<code>sass-loader</code>，即指定的loader位于<code>css-loader</code>右侧（下方）最近的数个loader。</p>
<h5 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h5><p><code>style-loader</code>的作用是在DOM里插入<code>&lt;style&gt;</code>标签，并将css写入这个标签内。这个loader跟抽离css的插件<code>mini-css-extract-plugin</code>中的内置loader会冲突，所以当使用<code>mini-css-extract-plugin</code>插件时，因为需要用到其loader，所以需要分别使用，比如因为<code>mini-css-extract-plugin</code>插件只能在正式环境使用，需要使用其loader来辅助编译打包时处理抽离，所以正式环境下就不能使用<code>style-loader</code>了。</p>
<h5 id="vue-style-loader"><a href="#vue-style-loader" class="headerlink" title="vue-style-loader"></a>vue-style-loader</h5><p><code>vue-style-loader</code>是配合<code>vue-loader</code>使用的。上面说到，<code>vue-loader</code>是用来解析.vue文件的，但是三个模块是需要分别解析的，而<code>vue-style-loader</code>就是用来解析.vue文件中的style模块的。官方文档介绍到，其实<code>vue-style-loader</code>是从<code>style-loader</code>fork并基于这个loader开发的，所以作用也跟<code>style-loader</code>一样。但是也有一些区别，增加了对ssr的支持，去掉了一些<code>style-loader</code>支持的功能，所以基于我们项目的需要，还是需要同时使用这两个loader。</p>
<h5 id="css及sass打包配置"><a href="#css及sass打包配置" class="headerlink" title="css及sass打包配置"></a>css及sass打包配置</h5><p>基于这些loader，我们就可以进行配置，如sass需要通过<code>scss-loader</code>先做转化为css，然后再用<code>postcss-loader</code>处理加前缀，转单位，然后在使用<code>css-loader</code>处理<code>import/require()</code>语句，处理这些语句是对引入的文件又根据文件类型再使用<code>scss-loader</code>及<code>postcss-loader</code>进行处理。最后再把处理好的css代码通过<code>style-loader</code>，<code>vue-style-loader</code>插入到DOM中。</p>
<p>如果是在正式环境打包，则不使用<code>style-loader</code>，而是使用<code>mini-css-extract-plugin</code>插件配合压缩css代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="string">'vue-style-loader'</span>, <span class="comment">// 用于编译.vue文件中css部分</span></span><br><span class="line">    isDev ? <span class="string">'style-loader'</span> : MiniCssExtractPlugin.loader, <span class="comment">// 一般使用MiniCssExtractPlugin就不使用style-loader</span></span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'css-loader'</span>, <span class="comment">// 用于编译@import和url()跟解析css</span></span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="comment">// 在 loader 前应用的 loader 的数量，意思是解析css时需要用到'postcss-loader','sass-loader'</span></span><br><span class="line">        <span class="comment">// 因为引入的css文件中可能是sass文件</span></span><br><span class="line">        <span class="comment">// 如配置1，则应用'postcss-loader'，如配置2，则应用'postcss-loader','sass-loader'</span></span><br><span class="line">        importLoaders: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'postcss-loader'</span>, <span class="comment">// 支持增加声明前缀，需要安装autoprefixer，并在postcss.config.js中配置</span></span><br><span class="line">    <span class="string">'sass-loader'</span> <span class="comment">// sass编译，还需要安装node-sass依赖。安装node-sass建议使用cnpm</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    <span class="string">'vue-style-loader'</span>,</span><br><span class="line">    isDev ? <span class="string">'style-loader'</span> : MiniCssExtractPlugin.loader, </span><br><span class="line">    <span class="string">'css-loader'</span>,</span><br><span class="line">    <span class="string">'postcss-loader'</span>,</span><br><span class="line">    <span class="string">'sass-loader'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h4><p>项目中通常还需要使用各种其他格式的文件，如文字图标会使用到<code>woff</code>，<code>ttf</code>，<code>eot</code>，<code>svg</code>这些格式的文件，图片文件一般有<code>jpg</code>，<code>jpeg</code>，<code>png</code>，<code>gif</code>，<code>svg</code>等格式。一般我们会考虑使用外部链接或者本地文件的形式引入。这里我们主要需要打包处理的是本地文件，所以就需要用到以下这些loader。</p>
<h5 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h5><p><code>file-loader</code>就是打包文件时会默认使用文件内容生成MD5哈希值然后使用这个哈希值作为这个文件名字保存到打包目录中，并且不会修改扩展名。<code>file-loader</code>也要一些配置可以使用，这里简单介绍几个：<code>name</code>可以指定打包文件的命名，自定义的命名跟前面打包文件命名类似，可以使用<code>[name]</code>(原文件名),<code>[ext]</code>(原扩展名),<code>[hash]</code>(哈希值),<code>[path]</code>(原路径),<code>[N]</code>(正则匹配第N个)；<code>publicPath</code>指定路径前缀，方便使用CDN；<code>outputPath</code>指定打包目录。</p>
<h5 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h5><p><code>url-loader</code>功能类似于<code>file-loader</code>，但是它有一个特点，就是可以根据文件的大小进行不用的打包处理，如小于一个特定的大小，则会打包返回一个DataURL的格式。比如一张图片小于10k，则直接转成DataURL打包存放在调用的文件中，这样会不需要再引用文件了。对于线上使用来说，客户端不需要为这个小文件发多一次请求。当然，这个需要配置<code>limit</code>属性。</p>
<h5 id="其他文件的打包配置"><a href="#其他文件的打包配置" class="headerlink" title="其他文件的打包配置"></a>其他文件的打包配置</h5><p><code>file-loader</code>跟<code>url-loader</code>各有不同，可以根据不同文件使用不同的loader，比如字体文件可以直接使用<code>file-loader</code>，图片类文件可以使用<code>url-loader</code>来分类处理：大小较小的图片可以直接打包进文件中，较大的图片可以打包引入文件中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(woff|ttf|eot|svg)$/</span>,</span><br><span class="line">  use: <span class="string">'file-loader'</span> <span class="comment">// 用于解析通过import/require()引入的文件或外部链接</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(jpe?g|png|gif|svg)$/</span>,</span><br><span class="line">  use: &#123;</span><br><span class="line">    loader: <span class="string">'url-loader'</span>, <span class="comment">// 用于把文件编译为base64格式</span></span><br><span class="line">    options: &#123;</span><br><span class="line">      name: <span class="string">"image/[contentHash].[ext]"</span>, <span class="comment">// 超过大小将使用file-loader解析，name为file-loader的配置，contentHash为图片的hash戳，ext是后缀</span></span><br><span class="line">      limit: <span class="number">100</span> * <span class="number">1024</span>, <span class="comment">// 尺寸限制</span></span><br><span class="line">      esModule: <span class="literal">false</span> <span class="comment">// 启用CommonJS模块语法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一篇整理一下<code>babel</code>跟<code>postcss-loader</code>的配置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/30/webpack-summary2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/30/webpack-summary2/" itemprop="url">webpack4配置总结(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-30T21:22:19+08:00">
                2020-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇整理了构建webpack项目的前置准备。根据这些准备，安装依赖，建好目录跟文件，就可以考虑写webpack配置了。</p>
<h3 id="webpack配置的结构"><a href="#webpack配置的结构" class="headerlink" title="webpack配置的结构"></a>webpack配置的结构</h3><p>首先，由于要分测试环境跟生产环境，所以webpack配置需要区分开测试跟生产环境的打包配置。但总是有一部分配置是相同的，所以把相同的配置整理在base配置文件中，然后对测试跟生产环境单独建配置文件。这里就需要用到<code>webpack-merge</code>插件。</p>
<h4 id="webpack-merge"><a href="#webpack-merge" class="headerlink" title="webpack-merge"></a>webpack-merge</h4><p><code>webpack-merge</code>插件可以把array合并起来，也可以把多个对象进行合并。这种合并是有深度的，即会对数组的每个元素，对对象的每个属性进行深度合并。合并的原则是遇到数组有相同的元素会保留，遇到对象属性不同会保留后者，遇到函数会先执行函数得到结果再合并。另外会有包括webpack配置中某些值才参数的，会用后者覆盖。</p>
<p>所以webpack-merge非常适合适用于合并webpack配置。我们可以先在base文件中配置一份基础配置内容，然后再引入到测试环境跟生产环境的配置文件中，使用<code>webpack-merge</code>将其合并。也可以考虑把测试环境跟生产环境的配置引入到base文件中，根据环境变量不同来合并配置。</p>
<h4 id="配置方案"><a href="#配置方案" class="headerlink" title="配置方案"></a>配置方案</h4><p>这里选择的合并配置方案是把测试环境跟生产环境的配置引入到base文件中，根据环境变量不同来合并配置。这样做法可以在写script命令时把所有打包都指向base配置文件，只需要通过环境变量来区分。当然这个选择因人而异，把base配置引入到测试跟生产环境配置文件中也可以必须要在script命令上写明环境变量。</p>
<h3 id="webpack基础配置"><a href="#webpack基础配置" class="headerlink" title="webpack基础配置"></a>webpack基础配置</h3><p>由于确定了配置方案，那么在base文件中，就需要区分不同的打包环境。区分的变量问<code>isDev</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDev = env.development;</span><br></pre></td></tr></table></figure>
<p><code>env.development</code>是通过script命令传入的环境变量，可以用来区分打包环境。这个变量将影响我们在一些相同的配置属性上根据不同打包环境做不同的处理。</p>
<h4 id="webpack配置结构"><a href="#webpack配置结构" class="headerlink" title="webpack配置结构"></a>webpack配置结构</h4><p>这里先简单的整理一下webpack配置结构。这里介绍的配置结构不是完整的，最好是看webpack官方文档的介绍比较好。</p>
<p>在webpack官网上，官方重点列举了四个核心概念，分别是前面说到的<code>entry</code>，<code>output</code>，还有<code>loader</code>跟<code>plugins</code>。而且base文件中主要也是这四个部分的配置，所以我也会按这四个方面进行整理说明。</p>
<h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><p><code>entry</code>是用来配置打包入口文件的配置属性。这里可以使用数组或者对象。使用数组说明打包入口有多于一个，这种情况比较适合多页面入口或者打包一个单页面加vendor文件。而使用对象则一般为打包入口只有一个，这种情况比较多为单页面应用。每个入口文件可以配置入口命名，入口路径，前者是用于标识入口，后者是用于执行入口文件的位置。</p>
<p>这里只配置一个入口文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: resolve(<span class="string">'../src/main.js'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><p><code>output</code>是用来配置打包的出口的配置属性。这里只能配置一个输出配置，也即只能使用对象。对象中可以有以下属性：</p>
<p><code>filename</code>: 这个属性是配置打包后文件的命名。可以是String类型，也可以是带动态生成的命名写法(如<code>[name]</code>,<code>[chunk]</code>,<code>[hash]</code>等这类写法将会在打包后命名文件名是被替换成指定的文件名，chunk值及hash戳)。</p>
<p><code>chunkFilename</code>: 这个属性是在针对非入口文件，但需要单独打包的文件的文件命名。只要是针对使用<code>require.ensure</code>和<code>import</code>异步加载模块打包后的文件命名。</p>
<p><code>path</code>: 这个属性是配置打包后文件保存的目录路径。一般我们会指定在根目录的dist目录下。</p>
<p><code>publicPath</code>: 这个属性是配置最终文件的相对路径的前缀。因为我们一般打包后可以考虑将打包后的文件放到CDN上，在引用时需要要带上相应的CDN路径。配置这一项属性将可以让打包后的文件在引用时自动加上这个前缀。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: isDev ? <span class="string">'[name].js'</span> : <span class="string">'[name].js?v=[chunkhash]'</span>,</span><br><span class="line">    chunkFilename: isDev ? <span class="string">'[chunkhash].js'</span> : <span class="string">'[id]-chunk.js?v=[chunkhash]'</span>,</span><br><span class="line">    path: resolve(<span class="string">'../dist'</span>),</span><br><span class="line">    publicPath: <span class="string">'/'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p><code>loader</code>是webpack打包中非常重要的一项，而是webpack之所以能实现项目打包的核心部分配置。<code>loader</code>就是打包插件，我们使用一系列打包插件，对项目相应的源代码进行转换，它可以处理项目中通过各种方式引入的JavaScript代码，css代码，文件类型文件等等，可以转译es6，TypeScript，scss等等。</p>
<p>配置<code>loader</code>也不难。一般<code>loader</code>需要先安装，然后在webpack配置中<code>module</code>属性里配置，webpack提供了<code>rules</code>这个属性用于配置。因为常见我们需要对多种不同的代码模块进行打包编译转换，所以<code>rules</code>这个属性需要使用一个数组来配置；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: <span class="string">'vue-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组的每一项都是一个对象，都会有基础的两种属性：<code>test</code>是用来匹配对应的模块，一般会匹配一个个文件名（因为我们理解的模块一般是一个文件为一个模块）。匹配文件名可以是一个String类型，或者一个正则等。<code>use</code>是用来指定打包编译转换的<code>loader</code>。如果只使用一个<code>loader</code>，则可以只写<code>loader</code>的名字，如果需要使用多个<code>loader</code>，则需要使用一个数组来列举<code>loader</code>，而数组的每个元素可以是一个String类型，可以是一个JSON格式（有些<code>loader</code>支持配置属性）。数组中<code>loader</code>的执行顺序是从右往左。</p>
<p>这里就先不详细整理一些<code>loader</code>的用法，后面单独整理。</p>
<h4 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h4><p><code>plugins</code>是用来配置webpack打包过程中使用的插件列表。这些插件可以让你自定义webpack打包过程，比如<code>webpack.DefinePlugin</code>插件可以让你在打包后的代码项目全局上定义一些常量；<code>vue-loader</code>内置了一个插件，是用于配置<code>vue-loader</code>打包编译的。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他配置项如<code>resolve</code>,<code>devServer</code>,<code>mode</code>和<code>optimization</code>等会在之后的篇章中做说明。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>下一篇将会详细列举一些<code>loader</code>跟<code>plugin</code>的介绍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/30/webpack-summary1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/30/webpack-summary1/" itemprop="url">webpack4配置总结(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-30T21:21:07+08:00">
                2020-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近学习了一下webpack，结合工作中的项目，自己搭建了一套基础的webpack脚手架<code>@listentolife/ll-cli</code>，已经发布到npm上。目前只有一个模板，为基础模板。支持自定义项目初始化信息。</p>
<p>这里也按照这个webpack项目的配置，顺便来做一下学习的总结。</p>
<h3 id="项目配置的目标"><a href="#项目配置的目标" class="headerlink" title="项目配置的目标"></a>项目配置的目标</h3><p>整个webpack项目配置完，目标是实现一个基于webpack实现代码打包，基于vue全家桶实现业务开发的项目模板。</p>
<p>项目模板通过脚手架初始化后可以开箱即用，支持本地调试(基于webpack-dev-server)，支持打包测试版及正式版(基于webpack-marge)。</p>
<h3 id="基础依赖"><a href="#基础依赖" class="headerlink" title="基础依赖"></a>基础依赖</h3><p>这里先把所有涉及的基础依赖，列表列出来。</p>
<h4 id="打包依赖列表"><a href="#打包依赖列表" class="headerlink" title="打包依赖列表"></a>打包依赖列表</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">  <span class="string">"@babel/core"</span>: <span class="string">"^7.9.0"</span>, <span class="comment">// babel核心库</span></span><br><span class="line">  <span class="string">"@babel/plugin-proposal-class-properties"</span>: <span class="string">"^7.8.3"</span>, <span class="comment">// 转化class类</span></span><br><span class="line">  <span class="string">"@babel/plugin-proposal-decorators"</span>: <span class="string">"^7.8.3"</span>, <span class="comment">// 转化装饰器</span></span><br><span class="line">  <span class="string">"@babel/plugin-transform-runtime"</span>: <span class="string">"^7.9.0"</span>, <span class="comment">// 使用babel的helper代码来压缩项目代码</span></span><br><span class="line">  <span class="string">"@babel/preset-env"</span>: <span class="string">"^7.9.0"</span>, <span class="comment">// babel预设，根据开发者的配置按需加载插件</span></span><br><span class="line">  <span class="string">"@babel/runtime"</span>: <span class="string">"^7.9.2"</span>, <span class="comment">// 使用@babel/plugin-transform-runtime需要安装此依赖，包含Babel模块化运行时帮助函数</span></span><br><span class="line">  <span class="string">"autoprefixer"</span>: <span class="string">"^9.7.5"</span>, <span class="comment">// 自动添加css前缀</span></span><br><span class="line">  <span class="string">"babel-loader"</span>: <span class="string">"^8.1.0"</span>, <span class="comment">// babel转译js语法的loader</span></span><br><span class="line">  <span class="string">"clean-webpack-plugin"</span>: <span class="string">"^3.0.0"</span>, <span class="comment">// 打包清理旧打包文件的plugin</span></span><br><span class="line">  <span class="string">"copy-webpack-plugin"</span>: <span class="string">"^5.1.1"</span>, <span class="comment">// 打包时复制文件的plugin</span></span><br><span class="line">  <span class="string">"core-js"</span>: <span class="string">"^2.6.11"</span>, <span class="comment">// js的模块化标准库，babel的底层依赖，目前这个项目使用的是core-js2</span></span><br><span class="line">  <span class="string">"css-loader"</span>: <span class="string">"^3.4.2"</span>, <span class="comment">// 打包css的loader</span></span><br><span class="line">  <span class="string">"file-loader"</span>: <span class="string">"^6.0.0"</span>, <span class="comment">// 打包文件类型的loader</span></span><br><span class="line">  <span class="string">"html-webpack-plugin"</span>: <span class="string">"^4.0.1"</span>, <span class="comment">// 打包html文件的plugin</span></span><br><span class="line">  <span class="string">"html-webpack-tags-plugin"</span>: <span class="string">"^2.0.17"</span>, <span class="comment">// 在html文件中插入js和css文件的plugin</span></span><br><span class="line">  <span class="string">"mini-css-extract-plugin"</span>: <span class="string">"^0.9.0"</span>, <span class="comment">// 将css单独打包成一个文件的插件，它为每个包含css的js文件都创建一个css文件。它支持css和sourceMaps的按需加载。</span></span><br><span class="line">  <span class="string">"node-sass"</span>: <span class="string">"^4.13.1"</span>, <span class="comment">// sass-loader的前置依赖，安装非常麻烦</span></span><br><span class="line">  <span class="string">"optimize-css-assets-webpack-plugin"</span>: <span class="string">"^5.0.3"</span>, <span class="comment">// 手动压缩css的plugin</span></span><br><span class="line">  <span class="string">"postcss-loader"</span>: <span class="string">"^3.0.0"</span>, <span class="comment">// 用js来处理css。负责把CSS解析成抽象语法树结构，在提供给其他插件处理</span></span><br><span class="line">  <span class="string">"postcss-pxtorem"</span>: <span class="string">"^5.1.1"</span>, <span class="comment">// 把px转为rem</span></span><br><span class="line">  <span class="string">"sass-loader"</span>: <span class="string">"^8.0.2"</span>, <span class="comment">// 处理sass的loader</span></span><br><span class="line">  <span class="string">"style-loader"</span>: <span class="string">"^1.1.3"</span>, <span class="comment">// 处理标签中style的loader</span></span><br><span class="line">  <span class="string">"terser-webpack-plugin"</span>: <span class="string">"^2.3.5"</span>, <span class="comment">// 手动压缩js的plugin</span></span><br><span class="line">  <span class="string">"url-loader"</span>: <span class="string">"^4.0.0"</span>, <span class="comment">// 处理url的loader</span></span><br><span class="line">  <span class="string">"vue-loader"</span>: <span class="string">"^15.9.1"</span>, <span class="comment">// 处理vue文件的loader</span></span><br><span class="line">  <span class="string">"vue-style-loader"</span>: <span class="string">"^4.1.2"</span>, <span class="comment">// 处理vue文件中style标签中的css的loader</span></span><br><span class="line">  <span class="string">"vue-template-compiler"</span>: <span class="string">"^2.6.11"</span>, <span class="comment">// 处理vue文件中模板编译</span></span><br><span class="line">  <span class="string">"webpack"</span>: <span class="string">"^4.42.0"</span>, <span class="comment">// 打包工具，webpack本体</span></span><br><span class="line">  <span class="string">"webpack-bundle-analyzer"</span>: <span class="string">"^3.6.1"</span>, <span class="comment">// 打包后分析工具</span></span><br><span class="line">  <span class="string">"webpack-cli"</span>: <span class="string">"^3.3.11"</span>, <span class="comment">// webpack打包命令行工具包</span></span><br><span class="line">  <span class="string">"webpack-dev-server"</span>: <span class="string">"^3.10.3"</span>, <span class="comment">// 开启本地服务器调试的工具</span></span><br><span class="line">  <span class="string">"webpack-merge"</span>: <span class="string">"^4.2.2"</span> <span class="comment">// 合并webpack配置的工具</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="项目依赖包列表"><a href="#项目依赖包列表" class="headerlink" title="项目依赖包列表"></a>项目依赖包列表</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"dependencies"</span>: &#123;</span><br><span class="line">  <span class="string">"axios"</span>: <span class="string">"^0.19.2"</span>, <span class="comment">// 处理请求的工具</span></span><br><span class="line">  <span class="string">"eruda"</span>: <span class="string">"^2.2.1"</span>, <span class="comment">// 移动端调试工具</span></span><br><span class="line">  <span class="string">"good-storage"</span>: <span class="string">"^1.1.1"</span>, <span class="comment">// 处理使用storage缓存的工具</span></span><br><span class="line">  <span class="string">"nprogress"</span>: <span class="string">"^0.2.0"</span>, <span class="comment">// 附着在页面顶部的进度条</span></span><br><span class="line">  <span class="string">"vue"</span>: <span class="string">"^2.6.11"</span>, <span class="comment">// vue本体</span></span><br><span class="line">  <span class="string">"vue-router"</span>: <span class="string">"^3.1.6"</span>, <span class="comment">// vue路由</span></span><br><span class="line">  <span class="string">"vuex"</span>: <span class="string">"^3.1.3"</span> <span class="comment">// vue的状态管理树</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="build目录"><a href="#build目录" class="headerlink" title="build目录"></a>build目录</h4><p>存放webpack配置。分基础配置文件webpack.base.js，测试环境配置文件webpack.dev.js，生产环境配置文件webpack.prod.js</p>
<h4 id="public目录"><a href="#public目录" class="headerlink" title="public目录"></a>public目录</h4><p>存放index.html文件</p>
<h4 id="src目录"><a href="#src目录" class="headerlink" title="src目录"></a>src目录</h4><p>存放项目主业务代码：api目录存放请求相关代码；common目录存放js，字体，图片，样式公共文件；components目录存放vue组件；mixins目录存放mixins文件；router目录存放router文件；store存放vuex文件；views目录存放页面级vue组件；App.vue跟main.js是常见的文件，不做说明；</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>.babelrc：babel配置文件<br>.browserslistrc：配置浏览器适配<br>.gitignore：配置git忽略文件或目录<br>.postcss.config.js：postcss配置文件<br>package-lock.json，package.json及README.md不做介绍了。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>下一篇开始讲webpack配置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/05/promise-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/05/promise-test/" itemprop="url">关于promise题目的打印</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T15:53:36+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Promise/" itemprop="url" rel="index">
                    <span itemprop="name">Promise</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原题，请问打印顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"1"</span>)</span><br><span class="line">      resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"2"</span>)</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"3"</span>)</span><br><span class="line">          resolve()</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"4"</span>)</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"5"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"6"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"7"</span>)</span><br><span class="line">      resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"8"</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>下面是我自己的理解分析过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"1"</span>) <span class="comment">// -&gt; 同步走到7</span></span><br><span class="line">      resolve() <span class="comment">// 存入2的promise</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"2"</span>) <span class="comment">// -&gt; 同步走到3</span></span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"3"</span>) <span class="comment">// -&gt; 同步走到9</span></span><br><span class="line">          resolve() <span class="comment">// 存入4的promise，但是同步未走完，要走到9那里</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"4"</span>) <span class="comment">// -&gt; 同步走完，出栈6</span></span><br><span class="line">          <span class="comment">// resolve() // 4先于6存入，所以先执行4，后执行6，然后存入5</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"5"</span>) <span class="comment">// -&gt; end</span></span><br><span class="line">          <span class="comment">// resolve() // 没有then不需要存入</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// console.log("9") // 同步走完，出栈8</span></span><br><span class="line">      <span class="comment">// resolve() // 存入6。</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 其实实现promise的时候，每个then都是Promise，也就是可以考虑每* 个then执行完都会执行一次resolve，把后面的then入栈</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      </span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"6"</span>) <span class="comment">// -&gt; 同步走完，出栈5</span></span><br><span class="line">      <span class="comment">// resolve() // 没有then不需要存入</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"7"</span>) <span class="comment">// -&gt; 同步走完，出栈2</span></span><br><span class="line">      resolve() <span class="comment">// 存入8的promise</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"8"</span>) <span class="comment">// -&gt; 同步走完，出栈4</span></span><br><span class="line">      <span class="comment">// resolve() // 没有then不需要存入</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/05/work-summary12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/05/work-summary12/" itemprop="url">工作总结(12)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T15:50:44+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结将整理一下几个工作中遇到的问题。</p>
<h3 id="webpack插件CleanWebpackPlugin的排除配置"><a href="#webpack插件CleanWebpackPlugin的排除配置" class="headerlink" title="webpack插件CleanWebpackPlugin的排除配置"></a>webpack插件CleanWebpackPlugin的排除配置</h3><p>我们一般都知道webpack的CleanWebpackPlugin插件是用在打包时删除之前打包的文件，这样可以帮我们自动清理打包文件。我之所以配置CleanWebpackPlugin插件的排除配置是因为我希望打包完之后dist目录可以保留git仓库的信息，方便我在打包之后直接上传打包文件。但是如果没有做任何配置的话，这个插件是会直接删除整个目录下的文件的，所以需要配置。</p>
<p>（听说原来这个插件没有这个问题，我遇到这个问题是在3.0.0版本，所以不排除是版本的原因）</p>
<p>这个配置我自己找了很久，因为需要排除的不是某几个文件，而且.git目录，但是没有找到有人尝试排除目录，所以一开始只找到配置项<code>cleanOnceBeforeBuildPatterns</code>。这个配置项是配置打包之前删除文件，默认为<code>[&#39;**/*&#39;]</code>。只要在加上正则匹配非.git目录及目录内文件即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">  <span class="comment">// 必须加这两个目录匹配，前一个是匹配不是.git的目录，后一个是匹配不是.git目录下的文件</span></span><br><span class="line">  cleanOnceBeforeBuildPatterns: [<span class="string">'**/*'</span>, <span class="string">'!\.git'</span>, <span class="string">'!\.git/**/*'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="处理图片防盗链的方案"><a href="#处理图片防盗链的方案" class="headerlink" title="处理图片防盗链的方案"></a>处理图片防盗链的方案</h3><p>公司的项目有需要抓取文章的内容并需要把图片单独列出来提供使用，但是在这期间遇到一个问题是，因为图片是有防盗链处理的，所以当需要单独列出来的时候图片会报错无法显示。究其原因，是因为请求图片的时候请求的header会自动带上页面的相关信息，服务器就是通过对这部分的判断来选择是否返回图片数据。因此，最好的方案是在当前页面加上下面这个meta属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"never"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个mate属性能禁止header发送页面相关信息，可以绕过图片防盗链的检查。</p>
<p>不过这样做也是有缺点的，一是影响页面跳转，比如<code>history.back()</code>会找不到上一个页面，二是一些第三方的统计代码失效。</p>
<p>如果项目是单页面项目(如Vue构建的项目)只是某些页面有处理防盗链图片的话，建议最好是在进入页面时加上这个mate属性，再退出这个页面时再把这个属性置为<code>default</code>。</p>
<h3 id="页面的部分涉及router-view的刷新"><a href="#页面的部分涉及router-view的刷新" class="headerlink" title="页面的部分涉及router-view的刷新"></a>页面的部分涉及router-view的刷新</h3><p>一般来说，我们在使用Vue开发项目的时候，一个页面一般会把一些功能模块拆分出来，变成一个个组件，这些组件是被解耦出来的，所以功能也比较独立。但是如果需要根据其中一个组件中数据的变化让另一个组件的数据也随之变化，就会出现一些问题，特别是如果一个组件的数据变化，在<code>router-view</code>中渲染的路由也要刷新。</p>
<p>我遇到的问题就是这种，<code>router-view</code>中渲染的路由需要根据其他组件数据的变化来刷新。</p>
<p>首先，考虑在父组件上通过<code>this.$root.$on</code>来增加一个监听，然后当子组件中数据变化需要让router-view中渲染的路由重新刷新，则可以调用<code>this.$root.$emit</code>来触发监听事件，还可以传入参数。这一步就完成子组件数据变化的监听。</p>
<p>因为需要刷新渲染的路由，所以可以考虑直接在<code>router-view</code>上使用<code>v-if</code>，<code>v-if</code>在切换真假值时，会直接卸载组件（所以这里不能使用<code>v-show</code>），然后当dom渲染完之后再将重新挂载组件，这样就相当于刷新了一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view v-<span class="keyword">if</span>=<span class="string">"isRouterAlive"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">created() &#123;</span></span><br><span class="line"><span class="xml">  console.log("allcontainer created")</span></span><br><span class="line"><span class="xml">  this.$root.$on('reload', this.reload);</span></span><br><span class="line"><span class="xml">&#125;,</span></span><br><span class="line"><span class="xml">methods: &#123;</span></span><br><span class="line"><span class="xml">  reload () &#123;</span></span><br><span class="line"><span class="xml">    this.isRouterAlive = false</span></span><br><span class="line"><span class="xml">    this.$nextTick(function() &#123;</span></span><br><span class="line"><span class="xml">      this.isRouterAlive = true</span></span><br><span class="line"><span class="xml">      console.log('reload')</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="canvas渲染跨域图片的方案"><a href="#canvas渲染跨域图片的方案" class="headerlink" title="canvas渲染跨域图片的方案"></a>canvas渲染跨域图片的方案</h3><p>这里有一个需求可能会经常需要做，就是分享的时候生成一张图片，而这张图片一般是通过页面的显示生成的。之前的工作总结中是有整理过的，可以用<code>html2canvas</code>来实现。但是这里有个问题，就是如果dom结构中如果有跨域的图片，则最后生成的图片将不会出现这些跨域的图片。所以这个问题需要处理。</p>
<p>我现在的处理方案是需要后端返回这张图的Blob对象，然后将这个Blob对象转换为本地地址，显示到页面上。转为本地地址的方案可以使用window上自带的方法<code>window.URL.createObjectURL</code>，这个方法传入一个Blob对象，返回一个url，这个url可以在页面上显示图片。这样就可以使跨域图片转为本地图片。</p>
<p>以上就是这次总结的内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/05/work-summary11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/05/work-summary11/" itemprop="url">工作总结(11) - 图片压缩</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T15:49:05+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结将整理一下如何实现图片压缩。</p>
<p>之所以需要处理图片压缩，是因为现在很多时候从用户那获得图片并上传，其实对图片的质量要求大部分情况下都不高，而各个客户端的硬件能力也比较强，用户能提供比较高质量的图片，但对要求不高的服务端来说却是一种压力，所以在处理上传图片之前，如果能对图片做一步压缩可以减轻用户的流量负担，也可以减轻服务端的压力。</p>
<p>因为从用户那获得的是一个file对象，所以压缩的对象也是file对象。然后压缩可以通过图片的清晰度，尺寸来压缩。最后，因为图片压缩是一个异步处理，需要有一个回调函数来处理，当然，后面可以改成promise的方式。所以实现图片压缩方法，需要传入的参数就是这四个<code>file</code>，<code>option</code>（包含<code>quality</code>和<code>scale</code>）和<code>callback</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> photoCompress = <span class="function"><span class="keyword">function</span> (<span class="params">file, options, callback</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，file对象需要转成data:URL格式的Base64字符串，这样图片才能被canvas渲染到画布上。这里用到<code>FileReader</code>对象。它能让Web应用程序异步读取存储在用户计算机上的文件，得到几种格式的文件内容。这里用到<code>FileReader.readAsDataURL()</code>来转格式，然后需要调用<code>FileReader.onload</code>在读取操作完成后执行之后的操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> photoCompress = <span class="function"><span class="keyword">function</span> (<span class="params">file, options, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ready = <span class="keyword">new</span> FileReader()</span><br><span class="line">  <span class="comment">/*调用ready.readAsDataURL()来读取指定的Blob对象或File对象中的内容。当读取操作完成时，readyState属性的值会成为DONE，如果设置了onload事件处理程序,则调用之.同时,result属性中将包含一个data:URL格式的字符串以表示所读取文件的内容.*/</span></span><br><span class="line">  ready.readAsDataURL(file)</span><br><span class="line">  ready.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取读取后的文件内容</span></span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">this</span>.result</span><br><span class="line">    <span class="comment">// 进行下一步的处理</span></span><br><span class="line">    canvasDataURL(re, options, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得文件内容之后，就可以来生成一个canvas画布，渲染图片了。先把图片文件加载好，然后在生成canvas标签，宽高直接取图片的宽高，然后生成画布，再把图片渲染到画布上，最后再获得压缩后的图片内容。尺寸的压缩可以在取宽高之后直接使用，得到压缩尺寸后的宽高，而清晰度则在最后获取压缩图片的时候调用<code>canvas.toDataURL()</code>时传入。这一步可以封装一个<code>canvasDataURL()</code>来实现，传入文件内容<code>path</code>，<code>option</code>（包含<code>quality</code>和<code>scale</code>）和<code>callback</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvasDataURL = <span class="function"><span class="keyword">function</span> (<span class="params">path, options, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">  img.src = path</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> imgScale = options.scale &amp;&amp; options.scale &lt;= <span class="number">1</span> &amp;&amp; options.scale &gt; <span class="number">0</span> ? options.scale : <span class="number">1</span></span><br><span class="line">    <span class="comment">// 默认按比例压缩</span></span><br><span class="line">    <span class="keyword">let</span> w = that.width * imgScale</span><br><span class="line">    <span class="keyword">let</span> h = that.height * imgScale</span><br><span class="line">    <span class="keyword">let</span> scale = w / h</span><br><span class="line">    w = options.width || w</span><br><span class="line">    h = options.height || (w / scale)</span><br><span class="line">    <span class="keyword">let</span> quality = options.quality &amp;&amp; options.quality &lt;= <span class="number">1</span> &amp;&amp; options.quality &gt; <span class="number">0</span> ? options.quality : <span class="number">0.7</span>  <span class="comment">// 默认图片质量为0.7</span></span><br><span class="line">    <span class="comment">//生成canvas</span></span><br><span class="line">    <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">    <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">    <span class="comment">// 创建属性节点</span></span><br><span class="line">    <span class="keyword">let</span> anw = <span class="built_in">document</span>.createAttribute(<span class="string">"width"</span>)</span><br><span class="line">    anw.nodeValue = w</span><br><span class="line">    <span class="keyword">let</span> anh = <span class="built_in">document</span>.createAttribute(<span class="string">"height"</span>)</span><br><span class="line">    anh.nodeValue = h</span><br><span class="line">    canvas.setAttributeNode(anw)</span><br><span class="line">    canvas.setAttributeNode(anh)</span><br><span class="line">    ctx.drawImage(that, <span class="number">0</span>, <span class="number">0</span>, w, h)</span><br><span class="line">    <span class="comment">// quality值越小，所绘制出的图像越模糊</span></span><br><span class="line">    <span class="keyword">let</span> base64 = canvas.toDataURL(<span class="string">'image/jpeg'</span>, quality)</span><br><span class="line">    <span class="comment">// 回调函数返回base64的值</span></span><br><span class="line">    callback(base64)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以通过<code>callback</code>获得压缩后的<code>data URI</code>。但是这样的内容还需要转成file对象，才能用做上传或者其他用。</p>
<p>所以，在调用<code>photoCompress</code>方法时传入的<code>callback</code>中，需要做一步转化。首先要先将<code>data URI</code>中的base64编码截出来，转成blob对象，然后在用blob对象转成file对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将base64编码转成blob对象</span></span><br><span class="line"><span class="keyword">const</span> ConvertBase64UrlToBlob = <span class="function">(<span class="params">urlData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 分离类型跟base64 data</span></span><br><span class="line">  <span class="keyword">let</span> arr = urlData.split(<span class="string">','</span>)</span><br><span class="line">  <span class="comment">// 分离出图片类型</span></span><br><span class="line">  <span class="keyword">let</span> mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> bstr = atob(arr[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">let</span> n = bstr.length</span><br><span class="line">  <span class="keyword">let</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n)</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([u8arr], &#123;<span class="attr">type</span>: mime&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了外部调用使用时是处理同步状态，所以在调用<code>photoCompress</code>方法时会用一个函数包装，利用promise来处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">compress (file) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    photoCompress(file, &#123;</span><br><span class="line">      quality: <span class="number">0.6</span>,</span><br><span class="line">      scale: <span class="number">1</span></span><br><span class="line">    &#125;, (dataUrl) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> item = ConvertBase64UrlToBlob(dataUrl);</span><br><span class="line">      <span class="keyword">let</span> newFile = <span class="keyword">new</span> File([item], file.name, &#123;<span class="attr">type</span>: item.type&#125;);</span><br><span class="line">      resolve(newFile);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样调用的时候，就可以通过<code>then</code>或者<code>async await</code>来拿到压缩后的file文件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Listentolife</p>
              <p class="site-description motion-element" itemprop="description">Listentolife's Blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archive">
              
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/listentolife" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:listentolife@qq.com" target="_blank" title="E-Mail">
                      E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Listentolife</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




<span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;</span>
<span id="showDays"></span>

<script>
	var birthDay = new Date('04/23/2018');
	var now = new Date();
	var duration = now.getTime() - birthDay.getTime();
	var total= Math.floor(duration / (1000 * 60 * 60 * 24));
	document.getElementById('showDays').innerHTML='本站已运行' + total + '天';
</script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
