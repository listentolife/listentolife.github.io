<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Listentolife&apos;s Blog">
<meta name="keywords" content="HTML CSS JavaScript">
<meta property="og:type" content="website">
<meta property="og:title" content="Listentolife">
<meta property="og:url" content="http://listentolife.github.io/index.html">
<meta property="og:site_name" content="Listentolife">
<meta property="og:description" content="Listentolife&apos;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Listentolife">
<meta name="twitter:description" content="Listentolife&apos;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://listentolife.github.io/"/>





  <title>Listentolife</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Listentolife</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">简单就好</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archive" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/05/promise-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/05/promise-test/" itemprop="url">关于promise题目的打印</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T15:53:36+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Promise/" itemprop="url" rel="index">
                    <span itemprop="name">Promise</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原题，请问打印顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"1"</span>)</span><br><span class="line">      resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"2"</span>)</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"3"</span>)</span><br><span class="line">          resolve()</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"4"</span>)</span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"5"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"6"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"7"</span>)</span><br><span class="line">      resolve()</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"8"</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>下面是我自己的理解分析过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"1"</span>) <span class="comment">// -&gt; 同步走到7</span></span><br><span class="line">      resolve() <span class="comment">// 存入2的promise</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"2"</span>) <span class="comment">// -&gt; 同步走到3</span></span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"3"</span>) <span class="comment">// -&gt; 同步走到9</span></span><br><span class="line">          resolve() <span class="comment">// 存入4的promise，但是同步未走完，要走到9那里</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"4"</span>) <span class="comment">// -&gt; 同步走完，出栈6</span></span><br><span class="line">          <span class="comment">// resolve() // 4先于6存入，所以先执行4，后执行6，然后存入5</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"5"</span>) <span class="comment">// -&gt; end</span></span><br><span class="line">          <span class="comment">// resolve() // 没有then不需要存入</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// console.log("9") // 同步走完，出栈8</span></span><br><span class="line">      <span class="comment">// resolve() // 存入6。</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 其实实现promise的时候，每个then都是Promise，也就是可以考虑每* 个then执行完都会执行一次resolve，把后面的then入栈</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      </span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"6"</span>) <span class="comment">// -&gt; 同步走完，出栈5</span></span><br><span class="line">      <span class="comment">// resolve() // 没有then不需要存入</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"7"</span>) <span class="comment">// -&gt; 同步走完，出栈2</span></span><br><span class="line">      resolve() <span class="comment">// 存入8的promise</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"8"</span>) <span class="comment">// -&gt; 同步走完，出栈4</span></span><br><span class="line">      <span class="comment">// resolve() // 没有then不需要存入</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/05/work-summary12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/05/work-summary12/" itemprop="url">工作总结(12)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T15:50:44+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结将整理一下几个工作中遇到的问题。</p>
<h3 id="webpack插件CleanWebpackPlugin的排除配置"><a href="#webpack插件CleanWebpackPlugin的排除配置" class="headerlink" title="webpack插件CleanWebpackPlugin的排除配置"></a>webpack插件CleanWebpackPlugin的排除配置</h3><p>我们一般都知道webpack的CleanWebpackPlugin插件是用在打包时删除之前打包的文件，这样可以帮我们自动清理打包文件。我之所以配置CleanWebpackPlugin插件的排除配置是因为我希望打包完之后dist目录可以保留git仓库的信息，方便我在打包之后直接上传打包文件。但是如果没有做任何配置的话，这个插件是会直接删除整个目录下的文件的，所以需要配置。</p>
<p>（听说原来这个插件没有这个问题，我遇到这个问题是在3.0.0版本，所以不排除是版本的原因）</p>
<p>这个配置我自己找了很久，因为需要排除的不是某几个文件，而且.git目录，但是没有找到有人尝试排除目录，所以一开始只找到配置项<code>cleanOnceBeforeBuildPatterns</code>。这个配置项是配置打包之前删除文件，默认为<code>[&#39;**/*&#39;]</code>。只要在加上正则匹配非.git目录及目录内文件即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">  <span class="comment">// 必须加这两个目录匹配，前一个是匹配不是.git的目录，后一个是匹配不是.git目录下的文件</span></span><br><span class="line">  cleanOnceBeforeBuildPatterns: [<span class="string">'**/*'</span>, <span class="string">'!\.git'</span>, <span class="string">'!\.git/**/*'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="处理图片防盗链的方案"><a href="#处理图片防盗链的方案" class="headerlink" title="处理图片防盗链的方案"></a>处理图片防盗链的方案</h3><p>公司的项目有需要抓取文章的内容并需要把图片单独列出来提供使用，但是在这期间遇到一个问题是，因为图片是有防盗链处理的，所以当需要单独列出来的时候图片会报错无法显示。究其原因，是因为请求图片的时候请求的header会自动带上页面的相关信息，服务器就是通过对这部分的判断来选择是否返回图片数据。因此，最好的方案是在当前页面加上下面这个meta属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"never"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个mate属性能禁止header发送页面相关信息，可以绕过图片防盗链的检查。</p>
<p>不过这样做也是有缺点的，一是影响页面跳转，比如<code>history.back()</code>会找不到上一个页面，二是一些第三方的统计代码失效。</p>
<p>如果项目是单页面项目(如Vue构建的项目)只是某些页面有处理防盗链图片的话，建议最好是在进入页面时加上这个mate属性，再退出这个页面时再把这个属性置为<code>default</code>。</p>
<h3 id="页面的部分涉及router-view的刷新"><a href="#页面的部分涉及router-view的刷新" class="headerlink" title="页面的部分涉及router-view的刷新"></a>页面的部分涉及router-view的刷新</h3><p>一般来说，我们在使用Vue开发项目的时候，一个页面一般会把一些功能模块拆分出来，变成一个个组件，这些组件是被解耦出来的，所以功能也比较独立。但是如果需要根据其中一个组件中数据的变化让另一个组件的数据也随之变化，就会出现一些问题，特别是如果一个组件的数据变化，在<code>router-view</code>中渲染的路由也要刷新。</p>
<p>我遇到的问题就是这种，<code>router-view</code>中渲染的路由需要根据其他组件数据的变化来刷新。</p>
<p>首先，考虑在父组件上通过<code>this.$root.$on</code>来增加一个监听，然后当子组件中数据变化需要让router-view中渲染的路由重新刷新，则可以调用<code>this.$root.$emit</code>来触发监听事件，还可以传入参数。这一步就完成子组件数据变化的监听。</p>
<p>因为需要刷新渲染的路由，所以可以考虑直接在<code>router-view</code>上使用<code>v-if</code>，<code>v-if</code>在切换真假值时，会直接卸载组件（所以这里不能使用<code>v-show</code>），然后当dom渲染完之后再将重新挂载组件，这样就相当于刷新了一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view v-<span class="keyword">if</span>=<span class="string">"isRouterAlive"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">created() &#123;</span></span><br><span class="line"><span class="xml">  console.log("allcontainer created")</span></span><br><span class="line"><span class="xml">  this.$root.$on('reload', this.reload);</span></span><br><span class="line"><span class="xml">&#125;,</span></span><br><span class="line"><span class="xml">methods: &#123;</span></span><br><span class="line"><span class="xml">  reload () &#123;</span></span><br><span class="line"><span class="xml">    this.isRouterAlive = false</span></span><br><span class="line"><span class="xml">    this.$nextTick(function() &#123;</span></span><br><span class="line"><span class="xml">      this.isRouterAlive = true</span></span><br><span class="line"><span class="xml">      console.log('reload')</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="canvas渲染跨域图片的方案"><a href="#canvas渲染跨域图片的方案" class="headerlink" title="canvas渲染跨域图片的方案"></a>canvas渲染跨域图片的方案</h3><p>这里有一个需求可能会经常需要做，就是分享的时候生成一张图片，而这张图片一般是通过页面的显示生成的。之前的工作总结中是有整理过的，可以用<code>html2canvas</code>来实现。但是这里有个问题，就是如果dom结构中如果有跨域的图片，则最后生成的图片将不会出现这些跨域的图片。所以这个问题需要处理。</p>
<p>我现在的处理方案是需要后端返回这张图的Blob对象，然后将这个Blob对象转换为本地地址，显示到页面上。转为本地地址的方案可以使用window上自带的方法<code>window.URL.createObjectURL</code>，这个方法传入一个Blob对象，返回一个url，这个url可以在页面上显示图片。这样就可以使跨域图片转为本地图片。</p>
<p>以上就是这次总结的内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/05/work-summary11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/05/work-summary11/" itemprop="url">工作总结(11) - 图片压缩</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T15:49:05+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结将整理一下如何实现图片压缩。</p>
<p>之所以需要处理图片压缩，是因为现在很多时候从用户那获得图片并上传，其实对图片的质量要求大部分情况下都不高，而各个客户端的硬件能力也比较强，用户能提供比较高质量的图片，但对要求不高的服务端来说却是一种压力，所以在处理上传图片之前，如果能对图片做一步压缩可以减轻用户的流量负担，也可以减轻服务端的压力。</p>
<p>因为从用户那获得的是一个file对象，所以压缩的对象也是file对象。然后压缩可以通过图片的清晰度，尺寸来压缩。最后，因为图片压缩是一个异步处理，需要有一个回调函数来处理，当然，后面可以改成promise的方式。所以实现图片压缩方法，需要传入的参数就是这四个<code>file</code>，<code>option</code>（包含<code>quality</code>和<code>scale</code>）和<code>callback</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> photoCompress = <span class="function"><span class="keyword">function</span> (<span class="params">file, options, callback</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，file对象需要转成data:URL格式的Base64字符串，这样图片才能被canvas渲染到画布上。这里用到<code>FileReader</code>对象。它能让Web应用程序异步读取存储在用户计算机上的文件，得到几种格式的文件内容。这里用到<code>FileReader.readAsDataURL()</code>来转格式，然后需要调用<code>FileReader.onload</code>在读取操作完成后执行之后的操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> photoCompress = <span class="function"><span class="keyword">function</span> (<span class="params">file, options, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ready = <span class="keyword">new</span> FileReader()</span><br><span class="line">  <span class="comment">/*调用ready.readAsDataURL()来读取指定的Blob对象或File对象中的内容。当读取操作完成时，readyState属性的值会成为DONE，如果设置了onload事件处理程序,则调用之.同时,result属性中将包含一个data:URL格式的字符串以表示所读取文件的内容.*/</span></span><br><span class="line">  ready.readAsDataURL(file)</span><br><span class="line">  ready.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取读取后的文件内容</span></span><br><span class="line">    <span class="keyword">let</span> re = <span class="keyword">this</span>.result</span><br><span class="line">    <span class="comment">// 进行下一步的处理</span></span><br><span class="line">    canvasDataURL(re, options, callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得文件内容之后，就可以来生成一个canvas画布，渲染图片了。先把图片文件加载好，然后在生成canvas标签，宽高直接取图片的宽高，然后生成画布，再把图片渲染到画布上，最后再获得压缩后的图片内容。尺寸的压缩可以在取宽高之后直接使用，得到压缩尺寸后的宽高，而清晰度则在最后获取压缩图片的时候调用<code>canvas.toDataURL()</code>时传入。这一步可以封装一个<code>canvasDataURL()</code>来实现，传入文件内容<code>path</code>，<code>option</code>（包含<code>quality</code>和<code>scale</code>）和<code>callback</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvasDataURL = <span class="function"><span class="keyword">function</span> (<span class="params">path, options, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">  img.src = path</span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">let</span> imgScale = options.scale &amp;&amp; options.scale &lt;= <span class="number">1</span> &amp;&amp; options.scale &gt; <span class="number">0</span> ? options.scale : <span class="number">1</span></span><br><span class="line">    <span class="comment">// 默认按比例压缩</span></span><br><span class="line">    <span class="keyword">let</span> w = that.width * imgScale</span><br><span class="line">    <span class="keyword">let</span> h = that.height * imgScale</span><br><span class="line">    <span class="keyword">let</span> scale = w / h</span><br><span class="line">    w = options.width || w</span><br><span class="line">    h = options.height || (w / scale)</span><br><span class="line">    <span class="keyword">let</span> quality = options.quality &amp;&amp; options.quality &lt;= <span class="number">1</span> &amp;&amp; options.quality &gt; <span class="number">0</span> ? options.quality : <span class="number">0.7</span>  <span class="comment">// 默认图片质量为0.7</span></span><br><span class="line">    <span class="comment">//生成canvas</span></span><br><span class="line">    <span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">    <span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">    <span class="comment">// 创建属性节点</span></span><br><span class="line">    <span class="keyword">let</span> anw = <span class="built_in">document</span>.createAttribute(<span class="string">"width"</span>)</span><br><span class="line">    anw.nodeValue = w</span><br><span class="line">    <span class="keyword">let</span> anh = <span class="built_in">document</span>.createAttribute(<span class="string">"height"</span>)</span><br><span class="line">    anh.nodeValue = h</span><br><span class="line">    canvas.setAttributeNode(anw)</span><br><span class="line">    canvas.setAttributeNode(anh)</span><br><span class="line">    ctx.drawImage(that, <span class="number">0</span>, <span class="number">0</span>, w, h)</span><br><span class="line">    <span class="comment">// quality值越小，所绘制出的图像越模糊</span></span><br><span class="line">    <span class="keyword">let</span> base64 = canvas.toDataURL(<span class="string">'image/jpeg'</span>, quality)</span><br><span class="line">    <span class="comment">// 回调函数返回base64的值</span></span><br><span class="line">    callback(base64)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以通过<code>callback</code>获得压缩后的<code>data URI</code>。但是这样的内容还需要转成file对象，才能用做上传或者其他用。</p>
<p>所以，在调用<code>photoCompress</code>方法时传入的<code>callback</code>中，需要做一步转化。首先要先将<code>data URI</code>中的base64编码截出来，转成blob对象，然后在用blob对象转成file对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将base64编码转成blob对象</span></span><br><span class="line"><span class="keyword">const</span> ConvertBase64UrlToBlob = <span class="function">(<span class="params">urlData</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 分离类型跟base64 data</span></span><br><span class="line">  <span class="keyword">let</span> arr = urlData.split(<span class="string">','</span>)</span><br><span class="line">  <span class="comment">// 分离出图片类型</span></span><br><span class="line">  <span class="keyword">let</span> mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> bstr = atob(arr[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">let</span> n = bstr.length</span><br><span class="line">  <span class="keyword">let</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n)</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([u8arr], &#123;<span class="attr">type</span>: mime&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了外部调用使用时是处理同步状态，所以在调用<code>photoCompress</code>方法时会用一个函数包装，利用promise来处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">compress (file) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    photoCompress(file, &#123;</span><br><span class="line">      quality: <span class="number">0.6</span>,</span><br><span class="line">      scale: <span class="number">1</span></span><br><span class="line">    &#125;, (dataUrl) =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> item = ConvertBase64UrlToBlob(dataUrl);</span><br><span class="line">      <span class="keyword">let</span> newFile = <span class="keyword">new</span> File([item], file.name, &#123;<span class="attr">type</span>: item.type&#125;);</span><br><span class="line">      resolve(newFile);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样调用的时候，就可以通过<code>then</code>或者<code>async await</code>来拿到压缩后的file文件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2020/05/05/work-summary10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/05/work-summary10/" itemprop="url">工作总结(10) - 处理文件流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T15:46:58+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结将整理一下如何处理文件流。</p>
<ul>
<li>图片blob对象转为本地地址</li>
</ul>
<p>一般图片blob对象转为本地地址的需求场景是需要后端生成一个二维码，一般返回是一个blob对象，然后前端需要通过这个blob对象生成一张图片展示出来。</p>
<p>这个实现的方案比较简单，主要依靠web API <code>URL.createObjectURL()</code>。所以首先需要判断浏览器是否支持<code>URL.createObjectURL()</code>方法。</p>
<p>发请求的时候，因为需要后端返回一个blob类型，所以请求头需要设置<code>responseType</code>为<code>blob</code>，返回就是blob对象。</p>
<p>然后调用<code>URL.createObjectURL()</code>方法，把blob对象传入，这个方法将创建并返回一个URL对象，这个url就可以用于页面上图片的显示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用axios来演示</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.URL.createObjectURL) &#123;</span><br><span class="line">  <span class="keyword">this</span>.axios.post(api, &#123;</span><br><span class="line">    url: url</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    responseType: <span class="string">'blob'</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="built_in">window</span>.URL.createObjectURL(response.data)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过MDN上有提示到如果不需要这些URL对象的时候，最好通过<code>URL.revokeObjectURL()</code>方法来释放掉，虽然浏览器在document卸载的时候会自动释放这些URL对象。这个情况需要根据业务需要进行处理了。</p>
<ul>
<li>文档blob对象转为文档文件下载</li>
</ul>
<p>处理文档blob对象转文档文件也是要涉及到图片blob对象转图片地址的处理，不过因为文档文件的格式各有不同，下载的文件还有文件名，而且转出来的文档文件还需要实现下载，所以实现的步骤就比较多。</p>
<p>首先，发请求的时候仍然需要按照上述请求图片blob对象一样，请求头需要设置<code>responseType</code>为<code>blob</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用axios来演示</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.URL.createObjectURL) &#123;</span><br><span class="line">  <span class="keyword">this</span>.axios.post(api, &#123;</span><br><span class="line">    url: url</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    responseType: <span class="string">'blob'</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>响应返回之后，响应头中有一个值需要用到，<code>Content-Disposition</code>。<code>Content-Disposition</code>中提供了文件的默认文件名，一般格式为<code>attachment;filename=FileName.txt</code>。所以我们需要先获取到文件的文件名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fileName = res.headers[<span class="string">'content-disposition'</span>].split(<span class="string">';'</span>)[<span class="number">1</span>].split(<span class="string">'='</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 如果涉及到文件名为中文，以上代码最后得到的字符串可能是一串乱码，所以才要再做一步处理</span></span><br><span class="line"><span class="comment">// decodeURIComponent方法传入一个编码后的部分URI，返回一个解码后URI字符串</span></span><br><span class="line"><span class="comment">// escape方法可以生成新的由十六进制转义序列替换的字符串，但方法已经被Web标准废弃，MDN建议使用 encodeURI 或 encodeURIComponent 代替</span></span><br><span class="line"><span class="comment">// decodeURI方法返回一个给定编码统一资源标识符(URI)的未编码版本的新字符串</span></span><br><span class="line">fileName = <span class="built_in">decodeURI</span>(<span class="built_in">escape</span>(<span class="built_in">decodeURIComponent</span>(fileName)));</span><br></pre></td></tr></table></figure>
<p>下一步就是要把blob对象转化为文档文件。因为不同文件的文件类型不同，如果返回的blob对象的文档类型不是对应的文件类型（可以通过blob对象中的<code>type</code>或者响应头的<code>Content-Type</code>获得），则需要把blob对象先转为对应文件类型的blob对象，然后调用<code>URL.createObjectURL()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是转为xlxs格式，'application/vnd.ms-excel;charset=utf-8'是xlxs的固定写法</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="built_in">window</span>.URL.createObjectURL(<span class="keyword">new</span> Blob([res.data], &#123;<span class="attr">type</span>: <span class="string">'application/vnd.ms-excel;charset=utf-8'</span>&#125;));</span><br></pre></td></tr></table></figure>
<p>因为还要实现自动下载，所以可以生成一个a标签，link属性指向上述生成的url，然后js控制点击，就可以实现下载:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> link = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">link.style.display = <span class="string">'none'</span>;</span><br><span class="line">link.href = url;</span><br><span class="line">link.setAttribute(<span class="string">'download'</span>, filename);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(link);</span><br><span class="line">link.click();</span><br></pre></td></tr></table></figure>
<p>完整代码就不贴了，基本实现流程就是这样。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/12/06/Axios-Encapsulation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/Axios-Encapsulation/" itemprop="url">封装axios</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T22:15:03+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/Axios/" itemprop="url" rel="index">
                    <span itemprop="name">Axios</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近做项目中，我尝试对axios做封装，以简化操作逻辑。所以这篇主要整理一下在项目中封装axios。</p>
<p>axios本身有create方法，可以处理各种请求，有拦截器，有cancelToken，可以根据请求的不同做不同的处理。封装的目的，就是让请求独立，的拦截可以分类，同时需要使用cancelToken的请求可以很方便的使用，把axios封装到一个类中，把axios的功能集中起来，调用的时候只要创建一个实例就可以了。</p>
<p>因此，这里封装就声明了一个<code>Ajaxquest</code>类，引入的时候其实是引入一个<code>Ajaxquest</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Ajaxquest &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default new Ajaxquest()</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>一般我们在使用axios的时候，有一些属性是可以设置固定的，比如timeout，baseURL等等，这里我把这些属性放在constructor中来初始化化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor () &#123;</span><br><span class="line">    this.baseURL = baseUrl</span><br><span class="line">    this.withCredentials = true</span><br><span class="line">    this.timeout = 60000</span><br><span class="line">    this.cancelToken = null // 关于cancelToken后面会单独整理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>这个<code>Ajaxquest</code>类在外部使用的时候是直接使用它的实例的，所以实际是调用实例的方法来使用，而且一般我们调用axios都是设置一些配置，所以我们需要有一个<code>request</code>的方法，这个方法支持传入axios的配置，然后在方法里面处理请求跟拦截。</p>
<p>axios的请求方法比较多，比如<code>axios.create(options)</code>，<code>axios.get(options)</code>等。这里我们直接使用<code>axios.create(options)</code>，因为它的灵活性更高，可以配置methods：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">request (config) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    const service = axios.create(&#123;</span><br><span class="line">        baseURL: this.baseURL,</span><br><span class="line">        withCredentials: this.withCredentials,</span><br><span class="line">        timeout: this.timeout</span><br><span class="line">    &#125;)</span><br><span class="line">    // ...</span><br><span class="line">    return service(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>return service(config)</code>之前，我们还要处理一步拦截，因为很多时候，一些请求是需要在头部添加一些信息的，而这些信息有些是通用的，有些是个别请求要求携带的，所以可以通过<code>config</code>传进来，然后再传到拦截器中处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">request (config) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    const service = axios.create(&#123;</span><br><span class="line">        baseURL: this.baseURL,</span><br><span class="line">        withCredentials: this.withCredentials,</span><br><span class="line">        timeout: this.timeout</span><br><span class="line">    &#125;)</span><br><span class="line">    service.interceptors.request.use(config =&gt; this._interceptorsRequest(config), error =&gt; &#123;</span><br><span class="line">        console.log(&apos;service error: &apos;, error)</span><br><span class="line">        // Do something with request error</span><br><span class="line">        return Promise.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">    service.interceptors.response.use(response =&gt; this._interceptorsResponse(response), error =&gt; this._interceptorsReject(error))</span><br><span class="line">    return service(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面拦截器中的callback，除了请求发送前拦截错误的callback，其他都写成内部方法。这些callback的作用是对所有请求的共性拦截处理。</p>
<h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><p>拦截器有请求前的拦截跟请求完毕后的拦截，每个拦截都会处理两个callback，因为请求前报错的处理比较少，只是打印报错信息跟返回Promise reject，所以只简单写了callback函数，没有写成内部方法。</p>
<p>请求前的拦截一般是为了配置头部信息，不在<code>request</code>方法的<code>axios.create()</code>中处理只是为了分开处理，是可以放在一起处理的。一些请求不需要配置头部信息，直接过滤掉，然后定义一些配置头部字段的，判断请求配置中是否带有这些属性，有则配置对应的头部信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_interceptorsRequest (config) &#123;</span><br><span class="line">    //当url为/admin/Image ,/admin/File, 不设置X-token请求头,图片和文件上传接口特殊要求</span><br><span class="line">    if (/*判断哪些请求不需要配置头部信息*/) &#123;</span><br><span class="line">        return config</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    // 自定义配置头部信息的属性，判断带有这些属性，就配置</span><br><span class="line">    if (config.areaID) &#123;</span><br><span class="line">        config.headers[&apos;x-area-id&apos;] = config.areaID</span><br><span class="line">        delete config.areaID</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;service config: &apos;, config)</span><br><span class="line">    return config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求完成之后，也做拦截，把请求成功跟失败后的共性处理分别独立放到一个callback中。</p>
<p>请求成功之后，一些全局性的信息就可以在拦截器中处理。比如用户的信息更新，就可以在拦截器中直接处理；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_interceptorsResponse (response) &#123;</span><br><span class="line">    console.log(&apos;response success: &apos;, response)</span><br><span class="line">    const config = response.config</span><br><span class="line">    // 处理全局信息</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果请求失败了，拦截就可以做一些请求失败的报错信息打印。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 这里用了vant的Toast组件</span><br><span class="line">_interceptorsReject (error) &#123;</span><br><span class="line">    console.log(&apos;response fail response: &apos;, error.response)</span><br><span class="line"></span><br><span class="line">    if (error.message === &apos;cancel a request&apos;) return Promise.reject(error)</span><br><span class="line"></span><br><span class="line">    // 打印错误信息</span><br><span class="line">    let errorMessage = &apos;服务器繁忙，请刷新页面重试！&apos;</span><br><span class="line">    if (error.response &amp;&amp; error.response.headers[&apos;x-info&apos;] !== undefined &amp;&amp; error.response.headers[&apos;x-info&apos;] !== &apos;&apos;) &#123;</span><br><span class="line">        errorMessage = decodeURIComponent(error.response.headers[&apos;x-info&apos;])</span><br><span class="line">    &#125; else if (error.message) &#123;</span><br><span class="line">        errorMessage = error.message.toLowerCase()</span><br><span class="line">        if (errorMessage.indexOf(&apos;timeout&apos;) &gt; -1) &#123;</span><br><span class="line">            errorMessage = &apos;服务器长时间未响应，请刷新页面重试！&apos;</span><br><span class="line">        &#125; else if (errorMessage.indexOf(&apos;abort&apos;) &gt; -1) &#123;</span><br><span class="line">            errorMessage = &apos;服务器连接中断 abort！&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Toast.fail(errorMessage)</span><br><span class="line"></span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cancelToken"><a href="#cancelToken" class="headerlink" title="cancelToken"></a>cancelToken</h3><p>axios提供了cancelToken来处理取消请求。这里我们也来实现cancelToken的封装。</p>
<p>因为我们导出的是实例，写请求方法的时候只是调用了<code>request()</code>方法，所以需要提供另一个方法来处理取消请求。另外，因为cancelToken的处理是需要在请求的时候先创建一个cancel token，所以就是说需要在调用<code>request()</code>方法时提出需要创建cancel token，所以在<code>request()</code>方法需要增加一个逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request (config) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    if (config.cancelToken) &#123;</span><br><span class="line">        this.cancelToken = axios.CancelToken.source()</span><br><span class="line">    &#125;</span><br><span class="line">    // 接着再处理service跟拦截器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样外部传入一个<code>cancelToken</code>的布尔值，方法内部判断是否为真，是则创建cancelToken。</p>
<p>使用的时候，当需要取消请求，就可以直接调用<code>abort()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abort (notice = &apos;cancel a request&apos;) &#123;</span><br><span class="line">    console.log(&apos;abort&apos;)</span><br><span class="line">    if (this.cancelToken) &#123;</span><br><span class="line">        this.cancelToken.cancel(notice)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这个封装其实只是一个结构的封装，内部的配置可以根据不同的项目，不同的请求分类去做差异化的处理。封装的功能也主要是一些常用的请求处理，有其他需求还可以在这个基础上继续封装。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/12/06/work-summary9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/work-summary9/" itemprop="url">工作总结(9) - 关于移动端底部评论框效果的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T22:11:05+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前在工作总结(六)中就整理了自己实现的移动端底部评论框的方案。这个方案整体效果可以，但是还是有些细节不够好。最近项目中再次遇到同样的需求，重新做了分析，用另一种不那么复杂的方案又实现了一次。这里就来总结一下这次实现方案。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>这次的需求跟上次的一样，只是因为考虑到可能有多个地方复用，所以打算做成一个底部评论框组件。需求是底部有一个假的评论栏，点击之后会弹出真的评论栏，并附着在底部和软键盘。</p>
<p>这个需求之前实现的思路是切换评论栏的布局，然后短时间内监听距离视窗顶部的高度来调整。这个方案能实现效果，但是在软键盘升起的时候会出现抖动现象。所以这次改变思路，直接使用绝对定位布局处理。</p>
<p>之前其实也考虑过这个思路，但是因为只考虑了评论框做绝对定位，所以那种处理的方案需要一直计算位置。这次思路的实现，是把整个页面的布局做调整：body元素直接限定高度为视窗高度，内容分块也全部使用绝对定位，内容的滚动是在内容块内处理。这样，评论框是相对于body做绝对定位，位置一定在视窗的底部。</p>
<p>这次还是用vue来实现。</p>
<h3 id="页面处理"><a href="#页面处理" class="headerlink" title="页面处理"></a>页面处理</h3><p>页面有几个需要处理的地方。因为每个页面都是一个vue组件，所以只要组件最外层限定为视窗的高度，body的高度就跟视窗高度一致，同时设置为相对定位：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后<code>.wrapper</code>内的所有子节点都要使用绝对定位。内容块如果高度超过视窗高度，一般可以使用<code>overflow:auto</code>来处理，不过在移动端的效果有个不太好的情况的滑动不流畅，这个问题可以使用下面的写法处理：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line"><span class="attribute">overflow</span>: auto;</span><br><span class="line">-webkit-<span class="attribute">overflow</span>-scrolling : touch;</span><br><span class="line"></span><br><span class="line">&amp;::-webkit-scrollbar &#123; /* WebKit的浏览器隐藏滚动条 */</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遮罩层的设计"><a href="#遮罩层的设计" class="headerlink" title="遮罩层的设计"></a>遮罩层的设计</h3><p>一般评论框弹起是需要用户避免操作其他功能，所以这里在评论组件上增加一个全屏的遮罩层。而且增加一个点击隐藏的功能。这个功能必须要点击遮罩层才能触发，所以用vue开发就是使用<a href="mailto:`@click.self" target="_blank" rel="noopener">`@click.self</a>`来设计点击事件。</p>
<h3 id="评论框的设计"><a href="#评论框的设计" class="headerlink" title="评论框的设计"></a>评论框的设计</h3><p>因为这个页面的效果先是视窗底部有一个假的评论框，点击之后这个假的评论框会隐藏，真的评论框会弹出来，所以实际上是需要做两个，但是这个假的评论框并不影响这些评论框的设计，所以只要保证它的布局时绝对定位就可以了。</p>
<p>首先，这个评论框的布局一样是绝对定位，定位在组件最外层元素的底部，也即在视窗的底部，这样当软键盘弹起的时候，整个页面被顶起，评论框依然能固定在页面的底部，贴着软键盘的顶部，而且不需要做任何计算高度的处理。</p>
<p>这里需要注意的是，评论框的绝对定位必须使用<code>bottom</code>属性来定位，而不能用<code>top</code>属性，因为使用<code>top</code>属性的情况下，因为软键盘弹起，视窗高度被压缩，会导致评论框还是按<code>top</code>属性的设置隐藏到软键盘后面，而用<code>bottom</code>属性可以使评论框一直定位在视窗的底部，所以不会被隐藏。</p>
<p>还有一个会影响效果的，是需要设计评论框的高度。因为在iOS上，当H5的input标签获得聚焦，弹出软键盘时，iOS会先把页面所有fixed定位改成绝对定位，然后判断输入框的位置，根据判断滚动页面。一方面软键盘的弹出会导致视窗高度变小，这会影响使用vh布局的样式，另一方面是滚动页面也会让从fixed定位改绝对定位的容器上移，而且高度不确定。所以最后会导致本身输入框会上移，然后视窗缩小也是顶起，最后效果就会变成输入框偏移更多，显示不全或各种难堪的页面显示。因此可以先设定一个高度，然后在输入框获得聚焦时把高度改高一些，这样在经历视窗缩小跟滚动之后，评论框的显示效果也不会差。这里就不上代码了，思路已经整理了。</p>
<p>实际开发出来的效果还是可以的。这里说的效果是安卓跟iOS13版本之前。安卓效果最好，而且其实在输入框获得聚焦的时候也不需要调整评论框高度的。但因为自iOS13出来之后，这个方案实现的效果跟实际效果又有了新的偏差：软键盘弹起后，当输入框失焦时，软键盘虽然隐藏了，但是视窗竟然没有恢复，导致页面下方原来软键盘的部分空白。这个原因目前不明，当然我只在我们公司的app上测试出来，并没有在其他地方测试过，可能跟webview有关。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/12/06/work-summary8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/work-summary8/" itemprop="url">工作总结(8)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T22:08:23+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结将整理一下如何实现html生成图片。</p>
<p>生成图片一般的思路都是将需要生成图片的dom绘制到canvas中，再调用<code>canvas.toDataURL()</code>将绘制好的canvas转成file对象，然后再上传服务器，拿到线上地址，再显示出来。</p>
<p>最麻烦的就是将dom绘制到canvas，摘自网上的说法，需要先遍历需要生成图片区域的所有元素，提取DOM数，然后获取渲染之后的每个DOM节点的内联、外链CSS属性，最后将样式转换成canvas的属性，利用offset等属性辅助摆放位置，将节点对应到canvas上。所以更多人实现的方案是使用第三方库<code>html2canvas</code>。</p>
<p><code>html2canvas</code>用法也很简单，就是一个<code>html2canvas()</code>方法，传入需要生成图片的dom跟配置，然后这个方法支持Promise，可以使用<code>html2canvas(dom).then</code>方法写入一个回调函数，拿到绘制完成的<code>canvas</code>，就可以完成接下来的处理了。</p>
<p>这里整理一下开发中遇到的需求跟处理。一般生成的图片会跟页面显示不同，因为可能会加一些内容。这样就需要在调用<code>html2canvas()</code>方法先调整需要生成图片的dom的样式，改成需要的样式效果。然后在回调函数中，等拿到<code>canvas</code>之后，再把dom的样式恢复。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用vue开发</span></span><br><span class="line"><span class="comment">// 先引入html2canvas</span></span><br><span class="line">htmlToImage () &#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise，调用的时候可以知道什么时候结束，支持异步处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 保存需要修改的样式的当前值</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置需要打印的样式的宽高</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 调用$nextTick确保样式已经更新</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 调用html2canvas，传入需要生成图片的dom跟配置，配置可以参考官网</span></span><br><span class="line">      html2canvas(<span class="keyword">this</span>.$refs.print, &#123;</span><br><span class="line">        allowTaint: <span class="literal">true</span>, <span class="comment">// 不允许跨域图片污染画布</span></span><br><span class="line">        useCORS: <span class="literal">true</span>,  <span class="comment">// 允许加载跨域图片</span></span><br><span class="line">        width: <span class="keyword">this</span>.$refs.print.offsetWidth, <span class="comment">// canvas宽度</span></span><br><span class="line">        height: <span class="keyword">this</span>.$refs.print.offsetHeight, <span class="comment">// canvas高度</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到的就是绘制了dom的canvas</span></span><br><span class="line">        <span class="comment">// 恢复修改前的样式</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="关于图片模糊的问题"><a href="#关于图片模糊的问题" class="headerlink" title="关于图片模糊的问题"></a>关于图片模糊的问题</h3><p>上面的操作可以拿到canvas，然后就可以转file对象，上传，拿到服务端链接，然后打开一看，图片很模糊。</p>
<p>这个问题也很常见，一方面跟设备的dpi有关，另一方面跟生成的图片太小，拉伸之后也会出现这个问题。所以解决的方案是在调用<code>html2canvas()</code>方法先把需要生成图片的dom的整体样式放大数倍，然后再生成图片，同时在调用方法时设置<code>dpi</code>跟<code>scale</code>两个配置，这样能保证图片效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">htmlToImage () &#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise，调用的时候可以知道什么时候结束，支持异步处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// //保存需要修改的样式的当前值</span></span><br><span class="line">    <span class="keyword">let</span> height = <span class="keyword">this</span>.$refs.print.offsetHeight;</span><br><span class="line">    <span class="keyword">let</span> width = <span class="keyword">this</span>.$refs.print.offsetWidth;</span><br><span class="line">    <span class="comment">// //设置需要打印的样式的宽高</span></span><br><span class="line">    <span class="keyword">this</span>.$refs.print.style.height = height * <span class="number">2</span> + <span class="string">'px'</span>;</span><br><span class="line">    <span class="keyword">this</span>.$refs.print.style.width = width * <span class="number">2</span> + <span class="string">'px'</span>;</span><br><span class="line">    <span class="comment">// 调用$nextTick确保样式已经更新</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 调用html2canvas，传入需要生成图片的dom跟配置，配置可以参考官网</span></span><br><span class="line">      html2canvas(<span class="keyword">this</span>.$refs.print, &#123;</span><br><span class="line">        dpi: <span class="built_in">window</span>.devicePixelRatio * <span class="number">2</span>, <span class="comment">// dpi设置 每英寸的像素</span></span><br><span class="line">        scale: <span class="number">2</span>, <span class="comment">// 放大倍数</span></span><br><span class="line">        allowTaint: <span class="literal">true</span>, <span class="comment">// 不允许跨域图片污染画布</span></span><br><span class="line">        useCORS: <span class="literal">true</span>,  <span class="comment">// 允许加载跨域图片</span></span><br><span class="line">        width: <span class="keyword">this</span>.$refs.print.offsetWidth, <span class="comment">// canvas宽度</span></span><br><span class="line">        height: <span class="keyword">this</span>.$refs.print.offsetHeight, <span class="comment">// canvas高度</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到的就是绘制了dom的canvas</span></span><br><span class="line">        <span class="comment">// 恢复修改前的样式</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="关于跨域图片不显示的问题"><a href="#关于跨域图片不显示的问题" class="headerlink" title="关于跨域图片不显示的问题"></a>关于跨域图片不显示的问题</h3><p>所以又按照上面的思路改了一下，图片是终于清晰了，但是还有一个问题没解决，就是本来应该显示的图片没有出现。这个问题我搜索过之后才知道原来是图片跨域的问题。</p>
<p>一般图片跨域没什么问题，但是在canvas上，跨域图片会导致画布被污染，所以跨域图片不会被绘制到canvas上，最终生成的图片也没有正常显示该图片。</p>
<p>解决这个问题，我试过一些网上的简单的处理，都无效，所以只能把跨域图片转为本地图片，再设置<code>html2canvas()</code>的<code>useCORS</code>为<code>true</code>。</p>
<p>跨域图片转为本地图片，目前我的解决方案是让服务器返回二进制数据，然后转成Blob对象，再调用window下的<code>createObjectURL()</code>方法转成本地图片url。</p>
<h3 id="关于base64转Blob对象转file对象"><a href="#关于base64转Blob对象转file对象" class="headerlink" title="关于base64转Blob对象转file对象"></a>关于base64转Blob对象转file对象</h3><p>这个问题打算单独整理，就不再这里写了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/12/06/work-summary7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/work-summary7/" itemprop="url">工作总结(7)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T22:06:58+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结会整理一下使用Canvas实现随机生成验证码。</p>
<p>随机生成验证码是基于canvas绘制而成的，最基本的实现是随机生成多位验证码，然后验证码的每一位码按不同的颜色，大小，倾斜角度跟位置来绘制到画布上。更上一层是增加干扰项，比如划线，非验证码范围字符，验证码扭曲，定时更新验证码等等。这里实现的验证码只是增加了干扰项跟点击更新，定时更新可以实现，但这里就不整理了。</p>
<p>这里的代码实现基于vue实现的。</p>
<h3 id="初始化工作"><a href="#初始化工作" class="headerlink" title="初始化工作"></a>初始化工作</h3><p>要实现随机验证码，有两个基本要素：canvas画布，随机生成的验证码(这里演示4位验证码)字符范围。</p>
<p>canvas绘制不难，主要是使用绘制的方法，这个后面整理。先要在页面上获得canvas画布，这一步需要在<code>mounted</code>中执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- html template --&gt;</span><br><span class="line">&lt;canvas id=&quot;verCode&quot;&gt;&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">data () &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">mounted () &#123;</span><br><span class="line">  this.initCanvas();</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  initCanvas () &#123;</span><br><span class="line">    this.container = document.querySelector(&apos;#verCode&apos;);</span><br><span class="line">    this.width = this.container.width;</span><br><span class="line">    this.height = this.container.height;</span><br><span class="line">    this.ctx = this.container.getContext(&apos;2d&apos;);</span><br><span class="line">    this.ctx.textBaseline = &apos;bottom&apos;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面通过<code>.getContext(&#39;2d&#39;)</code>获取了画布，然后在获得画布的宽高，设置了画布的文字基线。</p>
<h3 id="生成code"><a href="#生成code" class="headerlink" title="生成code"></a>生成code</h3><p>接下来就是生成code。生成code是比较简单的，思路是从特定的字符集合中随机取出字符组成code。这里把特定的字符放到一个字符串中，然后随机生成数组下标，取出字符串。随机生成的code的长度可以从外部传进来，也可以使用默认的四位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getCode () &#123;</span><br><span class="line">    let chars = &apos;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos;.split(&apos;&apos;);</span><br><span class="line">    let code = [];</span><br><span class="line">    let radix = chars.length;</span><br><span class="line">    for (let i = 0; i &lt; this.num; i++) &#123;</span><br><span class="line">        code[i] = chars[0 | Math.random() * radix];</span><br><span class="line">    &#125;</span><br><span class="line">    this.code = code.join(&apos;&apos;);</span><br><span class="line">    console.log(this.code);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="画code"><a href="#画code" class="headerlink" title="画code"></a>画code</h3><p>生成code之后，就可以开始在canvas画布上画code了。这里用到的是canvas的<code>fillText()</code>方法，这个方法可以把文字绘画到canvas上。在调用<code>fillText()</code>方法之前，还可以给文字增加属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">drawCode () &#123;</span><br><span class="line">    for (let i = 0; i &lt; this.num; i++) &#123;</span><br><span class="line">        let x = (this.width - 20) / this.num * i + 15;</span><br><span class="line">        let y = this.randomNum(this.height * 0.92, this.height * 0.92);</span><br><span class="line">        let deg = this.randomNum(-45, 45);</span><br><span class="line">        let txt = this.code.charAt(i);</span><br><span class="line"></span><br><span class="line">        this.ctx.fillStyle = this.randomColor(10, 100);</span><br><span class="line">        this.ctx.font = `$&#123;this.randomNum(80, 100)&#125;px SimHei`;</span><br><span class="line">        this.ctx.translate(x, y);</span><br><span class="line">        this.ctx.rotate(deg * Math.PI / 180);</span><br><span class="line">        this.ctx.fillText(txt, 0, 0);</span><br><span class="line">        this.ctx.rotate(-deg * Math.PI / 180);</span><br><span class="line">        this.ctx.translate(-x, -y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="干扰项"><a href="#干扰项" class="headerlink" title="干扰项"></a>干扰项</h3><p>干扰项一般增加直线跟曲线就可以了，如果想要更复杂，也是可以增加符号干扰的，不过要注意控制样式，否则真的会干扰到用户的判断。</p>
<p>这里我爸直线跟曲线的绘画分成两个方法来调用了。绘制的数量我都按code的长度来控制。然后在一定范围内随机生成长度，位置坐标，颜色等。最后调用canvas绘制路线的方法绘制即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">drawLine () &#123;</span><br><span class="line">    for (let i = 0; i &lt; this.num; i++) &#123;</span><br><span class="line">        this.ctx.strokeStyle = this.randomColor(90, 180);</span><br><span class="line">        this.ctx.beginPath();</span><br><span class="line">        this.ctx.moveTo(this.randomNum(0, this.width), this.randomNum(0, this.height));</span><br><span class="line">        this.ctx.lineTo(this.randomNum(0, this.width), this.randomNum(0, this.height));</span><br><span class="line">        this.ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">drawArc () &#123;</span><br><span class="line">    for (let i = 0; i &lt; this.num; i++) &#123;</span><br><span class="line">        this.ctx.fillStyle = this.randomColor(0, 255);</span><br><span class="line">        this.ctx.beginPath();</span><br><span class="line">        this.ctx.arc(this.randomNum(0, this.width), this.randomNum(0, this.height), 1, 0, 2 * Math.PI);</span><br><span class="line">        this.ctx.fill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="点击刷新验证码及验证"><a href="#点击刷新验证码及验证" class="headerlink" title="点击刷新验证码及验证"></a>点击刷新验证码及验证</h3><p>点击刷新验证码实现很简单，给canvas增加一个点击监听事件，点击之后调用<code>getCode()</code>方法就可以完成刷新。</p>
<p>验证验证码的实现是先实现一个验证方法，然后在父组件使用验证码组件是使用<code>this.$refs</code>来调用验证码组件的验证方法，传入用户输入的code进行比对，然后返回一个布尔值。</p>
<p>以上就是验证码组件的实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/08/25/wechat-mini-project-listentoweather-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/wechat-mini-project-listentoweather-II/" itemprop="url">微信小程序开发-倾听天气(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T23:04:07+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/微信小程序/" itemprop="url" rel="index">
                    <span itemprop="name">微信小程序</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我的微信小程序，倾听天气终于更新了0.2.1版本了，这个版本页面效果要比第一版的好很多了，主要的原因在于我申请的和风天气开发者权限通过了，所以获得更多的数据。比如24小时内间隔2小时的天气数据，最近7天的天气数据。</p>
<p>因此我的小程序所展示的数据可以更加详细。此外，我又在iconfont.cn搜集了一些icon来优化小程序的展示，并给逐小时天气预报做了一个折线图。下面我就以这几点来整理一下小程序的开发。</p>
<h3 id="申请过程"><a href="#申请过程" class="headerlink" title="申请过程"></a>申请过程</h3><p>这里就简单说一下申请的过程：和风天气的认证个人开发者很简单。只要申请的时候实名并提供自己的作品中使用了和风天气的api即可。我是在完成了倾听天气的第一版之后申请中，中间还给他们发了一封邮件，因为申请的信息要求的作品选项没有包括微信小程序，所以我发了邮件去咨询了一下。很快就回复了我微信小程序可以申请。所以我在申请的时候直接在作品一栏写明是微信小程序倾听天气。虽然那天刚好申请后隔天是周末，但到了周日就来邮件说申请通过了，周末都处理申请，好厉害的样子…</p>
<p>之后我在我的小程序中就发现原来3天的天气预报数据变成7天了，说明api的权限已经开好了。</p>
<h3 id="开发总结"><a href="#开发总结" class="headerlink" title="开发总结"></a>开发总结</h3><p>这里整理一下在0.2.1版本中涉及到的一些开发总结。主要分微信小程序滚动组件，iconfront引入及canvas绘制折线图。</p>
<h4 id="滚动组件scroll-view"><a href="#滚动组件scroll-view" class="headerlink" title="滚动组件scroll-view"></a>滚动组件<code>scroll-view</code></h4><p>之前整个小程序中都没有用到这个组件是因为没有太多的数据需要做这样的显示。不过当原来3天的天气预报数据变成7天之后，在屏幕上横着显示7天的数据就比较拥挤了，所以这个时候就需要用到滚动组件<code>scroll-view</code>了。</p>
<p><code>scroll-view</code>用起来不难，首先需要有一个父级组件包住<code>scroll-view</code>，然后通过<code>scroll-x</code>或<code>scroll-y</code>来控制滚动的方向。最后，如果是垂直方向的滚动需要给<code>scroll-view</code>增加一个高度的样式，而如果是水平方向的话，给父级标签增加一个固定宽度就可以了。</p>
<p>我这是因为是要水平方向展示7天的天气预报数据，所以我给组件<code>scroll-view</code>一个父级组件，固定width为<code>100%</code>，然后给组件<code>scroll-view</code>一个类，这里使用flex布局，让内部的子组件都并排在一行内，并固定宽度。这样的基本完成了水平滚动的实现了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&apos;forecast-wrapper&apos; wx:if=&quot;forecast.daily_forecast&quot;&gt;</span><br><span class="line">  &lt;scroll-view scroll-x enable-flex class=&apos;scroll-view-x&apos;&gt;</span><br><span class="line">    &lt;view</span><br><span class="line">      wx:for=&quot;&#123;&#123; forecast.daily_forecast &#125;&#125;&quot;</span><br><span class="line">      wx:for-index=&quot;index&quot;</span><br><span class="line">      wx:for-item=&quot;item&quot;</span><br><span class="line">      wx:key=&quot;item.date&quot;</span><br><span class="line">      class=&apos;forecast-item&apos;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;!-- --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/scroll-view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.forecast-wrapper &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.scroll-view-x &#123;</span><br><span class="line">  // display: flex;</span><br><span class="line">  width: auto;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">  // flex-wrap: nowrap 测试无效</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.forecast-item &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 20%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>scroll-view</code>组件的<code>enable-flex</code>属性相当于直接设置flex布局。还有很多属性可以设置，比如<code>scroll-into-view</code>滚动到某一子节点，<code>enable-back-to-top</code>支持垂直方向滚动的点击屏幕顶部后滚动条返回顶部，等等。具体可以去读官网文档。</p>
<h4 id="iconfont引入"><a href="#iconfont引入" class="headerlink" title="iconfont引入"></a>iconfont引入</h4><p>其实iconfont的引入本应没什么可以说的，但是鉴于微信小程序中写样式的文件叫wxss文件，我们平时写的样式文件是css，所以还是有点不一样的。</p>
<p>网上找到的解决方案一般都是先下载icon文件，然后把.ttf文件转码base64格式，然后再放到对应的wxss文件中，最后再引用。</p>
<p>但是我嫌这种方案比较复杂，而且需要下载icon文件存放在目录下也可能需要费些空间(我的项目还好，只是想找懒)。都知道微信小程序是有限项目大小的，所以有没有更好的方案。</p>
<p>有，很简单，就是通过iconfont直接生成unicode，把unicode复制放到wxss文件中，再下载icon文件，把icon的css样式在复制放到wxss文件中(我是直接放到app.wxss中，暂时先这样处理)，然后就可以快速的使用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**iconfont online**/</span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &apos;iconfont&apos;;  /* project id 1265794 */</span><br><span class="line">  src: url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.eot&apos;);</span><br><span class="line">  src: url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;),</span><br><span class="line">  url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.woff2&apos;) format(&apos;woff2&apos;),</span><br><span class="line">  url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.woff&apos;) format(&apos;woff&apos;),</span><br><span class="line">  url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.ttf&apos;) format(&apos;truetype&apos;),</span><br><span class="line">  url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.svg#iconfont&apos;) format(&apos;svg&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**iconfont.css**/</span><br><span class="line">.iconfont &#123;</span><br><span class="line">  font-family: &quot;iconfont&quot; !important;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  font-style: normal;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不需要把icon文件都放到项目中了。</p>
<p>目前项目中已经大面积的使用icon显示一些信息了，比如天气状态，生活指数，一些常用的功能icon。看起来要比原来纯文字的效果要好很多。</p>
<h4 id="canvas绘制"><a href="#canvas绘制" class="headerlink" title="canvas绘制"></a>canvas绘制</h4><p>canvas绘制应该是这一版本中最难的部分。原本想引入ECharts微信小程序版来实现24小时温度折线图的，但是因为没有用过，一下子使用有难度，再者最近看到不少canvas绘制图表的博文，所以想自己试试，所以最后选择了canvas绘制。</p>
<p>其实canvas绘制不难，它的操作逻辑就是在页面上建立一张画布，然后用坐标标识绘制的关键点，最后把方法当成指令这样使用就可以了，剩下就是想画好看点就用一些。</p>
<p>首先还是要对数据做处理。绘制一个24小时逐小时温度折线图需要确定要画布的宽跟高，这样才能确定最高温度跟最低温度的y轴值，最近时间温度跟最远时间温度的x轴值；然后找到所有温度数据中的最大值刚跟最小值，可以确定每个温度阶的间隔值，最后再计算每个时间温度对应的坐标。</p>
<p>这里我使用<code>wx.getSystemInfo</code>来获得屏幕的宽度，然后动态的计算画布的宽度跟高度(宽度为屏幕宽度，高度为宽度的1/5)。再用<code>getTmps</code>方法获得温度数据的数组跟最高最低温度值。最后用<code>getCoordinate</code>方法计算获得所有的坐标，最后在<code>drawHourly</code>方法中绘制。</p>
<p>微信小程序中canvas的绘制跟H5中有一点区别，但逻辑是一样的。首先要创建一个<code>content</code>，然后根据折线图的需要绘制线，绘制圆，绘制最大温度跟最小温度标识，最后把<code>content</code>绑定到页面上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">drawHourly(arr, maxCoo, minCoo, maxTmp, minTmp) &#123;</span><br><span class="line">  var context = wx.createContext();</span><br><span class="line">  context.draw(); // 清空</span><br><span class="line">  context.setStrokeStyle(&quot;#fff&quot;);</span><br><span class="line">  context.setLineWidth(1);</span><br><span class="line">  context.moveTo(arr[0].x, arr[0].y);</span><br><span class="line">  for (let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    context.lineTo(arr[i].x, arr[i].y);</span><br><span class="line">  &#125;</span><br><span class="line">  context.stroke();</span><br><span class="line">    </span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    // 设置描边颜色</span><br><span class="line">    context.setStrokeStyle(&quot;#ffffff&quot;);</span><br><span class="line">    context.moveTo(arr[i].x, arr[i].y);</span><br><span class="line">    context.arc(arr[i].x, arr[i].y, 2, 0, 2 * Math.PI, false);</span><br><span class="line">    context.closePath();</span><br><span class="line">    // 填充路径</span><br><span class="line">    // context.fill();</span><br><span class="line">    context.stroke();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.setFontSize(10);</span><br><span class="line">  context.setFillStyle(&quot;#fff&quot;);</span><br><span class="line">  context.fillText(`$&#123;maxTmp&#125;℃`, maxCoo.x - 10, maxCoo.y + 5);</span><br><span class="line">  context.fillText(`$&#123;minTmp&#125;℃`, minCoo.x - 10, minCoo.y + 5);</span><br><span class="line"></span><br><span class="line">  wx.drawCanvas(&#123;</span><br><span class="line">    canvasId: &apos;hourlyCanvas&apos;,</span><br><span class="line">    actions: context.getActions()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个绘制也是比较简单，也没有做效果更好的平滑曲线，达到效果就可以了。</p>
<p>以上就是新版本倾听天气小程序开发的整理。接下来会做新的优化，具体会在下一个版本出来后再整理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/08/25/wechat-mini-project-listentoweather-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/wechat-mini-project-listentoweather-I/" itemprop="url">微信小程序开发-倾听天气(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T22:57:19+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/微信小程序/" itemprop="url" rel="index">
                    <span itemprop="name">微信小程序</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近开始尝试开发微信小程序。之前多多少少了解了微信小程序的开发，了解了wxml，wxss，wxs跟一些微信小程序的api，但是并没有什么想法应该要拿什么来练手。最近找到和风天气(<a href="https://www.heweather.com/)有向普通开发者提供开发api，看了文档也觉得文档很友好，数据也很足够，所以就想尝试开发一款天气预报的微信小程序。" target="_blank" rel="noopener">https://www.heweather.com/)有向普通开发者提供开发api，看了文档也觉得文档很友好，数据也很足够，所以就想尝试开发一款天气预报的微信小程序。</a></p>
<p>简单的说，最基本的需要是用户需要查看所在地的天气情况跟最近几天的天气预报，并获得一些建议，而和风天气开放给普通用户也有这些信息，所以这个需求可以很容易实现。目前我也是打算实现最基础的展示功能先上线，走完整个开发到上线的流程，看看有什么坑。</p>
<p>话不多说，先上小程序码，可以去看看效果：</p>
<p><img src="../images/gh_49128d023947_258.jpg" alt="倾听天气 小程序码"></p>
<h3 id="创建小程序账号"><a href="#创建小程序账号" class="headerlink" title="创建小程序账号"></a>创建小程序账号</h3><p>第一步，肯定是要到微信公众平台申请一个小程序的账号，这个账号需要一个未申请过微信账号或其他开发账号的邮箱，然后申请之后还需要一个管理员。申请之后，可以得到一个AppID，这个AppID就是你开发小程序时需要绑定的。</p>
<p>然后就下载微信开发者工具，安装。打开工具，选择小程序，然后在新建项目那里，在AppID填入你刚才注册获得的Appid。选择好目录，项目名称跟后端服务（目前我没有使用云服务，但计划之后的版本会加入），点击新建即可新建小程序项目。</p>
<h3 id="腾讯地图开发者及和风天气开发者账号"><a href="#腾讯地图开发者及和风天气开发者账号" class="headerlink" title="腾讯地图开发者及和风天气开发者账号"></a>腾讯地图开发者及和风天气开发者账号</h3><p>从需求中分析到，需要获得用户的定位信息跟天气数据，前者可以通过微信小程序内置api获取，后者可以通过和风天气api获取。不过长远考虑可以获得更多地图数据以丰富小程序的功能，所以这里一并申请了腾讯地图开发者。</p>
<p>其实申请也不难，腾讯地图api是在腾讯位置服务申请的开发者账号，只要用QQ或微信扫一下二维码就可以注册成功了，简直0操作成本。然后在控制台的key管理那里创建新密钥。通过这个密钥就可以获得腾讯地图的数据了</p>
<p>注册和风天气的开发者账号也不难，进入官网之后进行注册。开发者的权限是跟开发者账号绑定的，一般的开发者（比如我）可以直接注册普通开发者，然后创建key，就可以获得最基础的数据。如果要申请认证开发者就需要提供开发上线的应用（目前我上线小程序之后就开始申请了）。申请就还需要提供个人信息了，但是因为小程序没有链接，所以我就直接写让他们去微信里面搜索了……</p>
<p>最后，还需要在微信公众平台，小程序账号的开发一栏，进入开发设置，设置服务器域名的request合法域名。设置的是把接口的域名添加进去。注意，这个操作每个月是有显示修改次数的。</p>
<p>这样，就完成了开发前的准备了。</p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>开发的过程耗时不长，只是因为每天比较忙，所以只能腾三个晚上每天大概6个小时从各种注册到开发到上线申请。</p>
<p>遇到的坑也不算太多，简单的百度一下也可以解决，不过既然是整理开发过程，我觉得还是可以拿一些出来说说的：</p>
<h4 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h4><p>因为是第一个版本，没打算获取用户太多信息，只需要获得定位信息就可以了，所以目前只获取用户定位权限。</p>
<p>现在微信小程序的用户权限都需要做多一些配置。比如获取定位权限，就需要先在app.json配置permission：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  &quot;permission&quot;: &#123;</span><br><span class="line">    &quot;scope.userLocation&quot;: &#123;</span><br><span class="line">      &quot;desc&quot;: &quot;你的位置信息将用于获取你所在地区的天气信息&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再在js文件中调用<code>wx.getLocation()</code>方法，这里我是在index.js中onLoad中调用<code>getUserLocation()</code>，在这个方法中获取定位的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function () &#123;</span><br><span class="line">  // 获取用户经纬度</span><br><span class="line">  this.getUserLocation()</span><br><span class="line">&#125;,</span><br><span class="line">getUserLocation () &#123;</span><br><span class="line">  wx.getLocation(&#123;</span><br><span class="line">    type: &apos;gcj02&apos;,</span><br><span class="line">    success: res =&gt; &#123;</span><br><span class="line">      this.updateLocation(res);</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: err =&gt; &#123;</span><br><span class="line">      console.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="腾讯位置服务获取位置描述"><a href="#腾讯位置服务获取位置描述" class="headerlink" title="腾讯位置服务获取位置描述"></a>腾讯位置服务获取位置描述</h4><p>毕竟是腾讯的产品，腾讯位置服务也有微信小程序JS SDK，不需要使用API调用。引入的方法也不难。</p>
<p>前面已经获得了key，然后在腾讯位置服务页面下载SDK，然后放到项目目录下（我的项目是放在了util目录下）。再在js文件中引入，并声明一个实例（官网也有详细的代码介）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 引入腾讯地图SDK核心类</span><br><span class="line">let QQMapWX = require(&apos;./qqmap-wx-jssdk.min.js&apos;);</span><br><span class="line"></span><br><span class="line">// 实例化地图API核心类</span><br><span class="line">let qqmapsdk = new QQMapWX(&#123;</span><br><span class="line">  key: config.MAP_API_KEY</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就可以开始使用了。前面已经获得了用户的位置信息，这个位置信息主要可以获得位置的经纬度，然后我们就要考虑使用经纬度获取位置的描述信息了。这个可以使用腾讯位置服务SDK的逆地址解析接口<code>reverseGeocoder(options:Object)</code>。</p>
<p>这个接口可以不传入任何字段，默认为当前位置坐标。然后返回的是经纬度对应的地理描述信息，不传则返回的是当前位置的描述信息。这个就有点有趣了，也就是可能可以绕过微信小程序的用户授权，直接获取用户的地理信息。不过为了不出问题，我们还是通过用户授权获取位置信息吧。</p>
<h4 id="和风天气获取常规天气数据"><a href="#和风天气获取常规天气数据" class="headerlink" title="和风天气获取常规天气数据"></a>和风天气获取常规天气数据</h4><p>天气数据我通过和风天气的常规天气数据api获取的。前面已经获取了和风天气普通开发者的key了，这里使用<code>wx.request</code>向接口<code>https://free-api.heweather.net/s6/weather/{weather-type}?{parameters}</code>发出请求。接口的要求官网也是有说明的，这里就不多说。我是把腾讯位置服务跟和风天气的请求操作都做了封装，放在util目录的<code>api.js</code>中，这样可以减少在页面js文件中写请求内容，请求操作统一开发。这里我使用了<code>Promise.all</code>把常规天气数据请求都包起来了，方便全部请求完成之后再关闭加载弹窗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getHefengData (lat, lon) &#123;</span><br><span class="line">  wx.showLoading(&#123;</span><br><span class="line">    title: &apos;获取天气信息中&apos;,</span><br><span class="line">  &#125;)</span><br><span class="line">  Promise.all([this.getWthNow(lat, lon), this.getWthForecast(lat, lon), this.getWthHourly(lat, lon), this.getWthLifestyle(lat, lon)]).then(res =&gt; &#123;</span><br><span class="line">    wx.hideLoading();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="wxs的使用"><a href="#wxs的使用" class="headerlink" title="wxs的使用"></a>wxs的使用</h4><p>因为微信小程序不支持在wxml中做数据处理，所以wxs的出现我觉得是js到wxml的中介物。数据或者状态通过wxs的处理后才能渲染到wxml。</p>
<p>比如说这个项目中，接口获取的天气状态码需要转换成天气状态描述跟对应的图标，这个时候就需要通过wxs的处理。所以，在微信小程序中，js扮演的角色更多是获取数据，保存状态，数据通过wxs的处理变成需要渲染的内容放到wxml中。</p>
<p>使用也不难，新建一个对应的wxs，把处理逻辑放进去，通过<code>&lt;wxs src=&quot;./xxx.wxs&quot; module=&quot;xxx&quot; /&gt;</code>引入到wxml中，然后通过<code>xxx.fn</code>来使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text class=&apos;iconfont &#123;&#123;tools.getCondIcon(now.now.cond_code)&#125;&#125;&apos;&gt;&lt;/text&gt;</span><br></pre></td></tr></table></figure>
<p>因为和风天气的天气状态比较多，所以我把天气状态对应的描述都放到<code>app.wxs</code>中，再在<code>index.wxs</code>引用。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>页面设计其实比较简陋，所以没什么好写的，而且显示的都是文字，展示效果并不那么好，所以等之后的迭代有比较好的设计再看有没有什么可以整理的吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Listentolife</p>
              <p class="site-description motion-element" itemprop="description">Listentolife's Blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archive">
              
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/listentolife" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:listentolife@qq.com" target="_blank" title="E-Mail">
                      E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Listentolife</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




<span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;</span>
<span id="showDays"></span>

<script>
	var birthDay = new Date('04/23/2018');
	var now = new Date();
	var duration = now.getTime() - birthDay.getTime();
	var total= Math.floor(duration / (1000 * 60 * 60 * 24));
	document.getElementById('showDays').innerHTML='本站已运行' + total + '天';
</script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
