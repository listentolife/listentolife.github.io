<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Listentolife&apos;s Blog">
<meta name="keywords" content="HTML CSS JavaScript">
<meta property="og:type" content="website">
<meta property="og:title" content="Listentolife">
<meta property="og:url" content="http://listentolife.github.io/index.html">
<meta property="og:site_name" content="Listentolife">
<meta property="og:description" content="Listentolife&apos;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Listentolife">
<meta name="twitter:description" content="Listentolife&apos;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://listentolife.github.io/"/>





  <title>Listentolife</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Listentolife</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">简单就好</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archive" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/02/09/Mouse-Event-Attributes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/09/Mouse-Event-Attributes/" itemprop="url">JavaScript鼠标事件中event的各种x/y属性梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-09T19:48:05+08:00">
                2019-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在敲代码的时候遇到关于JavaScript事件中求各种长宽，涉及到event中各种x/y，所以尝试做一些梳理。</p>
<p>这里说的event是指js中鼠标事件event的实例属性，而各种x/y就是指以下这些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e.clientX/e.clientY</span><br><span class="line">e.screenX/e.screenY</span><br><span class="line">e.offsetX/offsetY</span><br><span class="line">e.pageX/e.pageY</span><br><span class="line">e.layerX/e.layerX</span><br><span class="line">e.x/e.y</span><br></pre></td></tr></table></figure>
<h3 id="关于各种x-y属性的描述"><a href="#关于各种x-y属性的描述" class="headerlink" title="关于各种x/y属性的描述"></a>关于各种x/y属性的描述</h3><p>在网上找了一些资料，对于这些属性都有描述。<a href="http://www.w3school.com.cn" target="_blank" rel="noopener">http://www.w3school.com.cn</a> w3c给出了clientX/Y跟screenX/Y的描述，不过为了统一，我选择了阮一峰的一份JavaScript教程(<a href="https://wangdoc.com/javascript/events/mouse.html)中的描述：" target="_blank" rel="noopener">https://wangdoc.com/javascript/events/mouse.html)中的描述：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MouseEvent.clientX属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素）</span><br><span class="line">MouseEvent.clientY属性返回垂直坐标。这两个属性都是只读属性。</span><br><span class="line"></span><br><span class="line">MouseEvent.screenX属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），</span><br><span class="line">MouseEvent.screenY属性返回垂直坐标。这两个属性都是只读属性。</span><br><span class="line"></span><br><span class="line">MouseEvent.offsetX属性返回鼠标位置与目标节点左侧的padding边缘的水平距离（单位像素）</span><br><span class="line">MouseEvent.offsetY属性返回与目标节点上方的padding边缘的垂直距离。这两个属性都是只读属性。</span><br><span class="line"></span><br><span class="line">MouseEvent.pageX属性返回鼠标位置与文档左侧边缘的距离（单位像素），</span><br><span class="line">MouseEvent.pageY属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。这两个属性都是只读。</span><br></pre></td></tr></table></figure>
<p><code>layerX/e.layerX</code>跟<code>x/y</code>则没有找到比较权威的描述。</p>
<p>这些描述看完还是有点稀里糊涂的，不过可以看出，这些属性的值都是相对的，是有参考坐标的，比如浏览器，屏幕，目标节点，文档等。所以我们就试试在代码中获得更深入的理解。</p>
<h3 id="代码实现实例属性"><a href="#代码实现实例属性" class="headerlink" title="代码实现实例属性"></a>代码实现实例属性</h3><p>这里尝试做一个简单的演示项目，body中如下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;canvas-wrapper&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;canvas id=&quot;canvas&quot; height=&quot;2000&quot; width=&quot;2000&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><code>div#container</code>元素是作为鼠标事件的目标节点，而<code>canvas</code>画布则是用于绘出点击事件的坐标跟垂直线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  margin: 0px;</span><br><span class="line">  padding: 0px;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这几个实例属性中有一些是涉及页面可视，所以给<code>div#container</code>元素绝对定位，脱离文档流；为了页面可以上下左右滚动，所以<code>body</code>跟<code>canvas</code>元素的尺寸都很大。<br>而且为了减少盒模型的影响，所以设置了<code>box-sizing: border-box;</code></p>
<p>js逻辑部分，给<code>div#container</code>添加鼠标点击事件，回调函数中返回event，把event中的这些关于x/y的实例属性通过new传入一个位置构造函数的实例中，通过实例来绘出点击点跟各个x/y属性的线。</p>
<h3 id="x-y各属性的表现梳理"><a href="#x-y各属性的表现梳理" class="headerlink" title="x/y各属性的表现梳理"></a>x/y各属性的表现梳理</h3><p><img src="https://listentolife.cc/images/pos.PNG" alt="代码中各x/y属性的演示"></p>
<p>这张截图是在浏览器向左向下滚动后(浏览器的上边贴着绿色线，浏览器的左边贴着绿色线)，点击（点击点中心为黑点中心）触发事件得到的绘图。</p>
<h4 id="clientX-clientY-amp-x-y"><a href="#clientX-clientY-amp-x-y" class="headerlink" title="clientX/clientY &amp; x/y"></a><code>clientX</code>/<code>clientY</code> &amp; <code>x</code>/<code>y</code></h4><p><code>clientX</code>/<code>clientY</code>在点击事件触发时是等于点击点到浏览器的上边跟左边，说明 <strong><code>clientX</code>/<code>clientY</code>的参考坐标轴是沿着浏览器的上边为x轴，浏览器的左边为y轴</strong> 。跟目标节点的<code>border</code>，<code>margin</code>跟<code>padding</code>没有关系。<br>相同的<code>x</code>/<code>y</code>在表现上也一样。不过最好使用的时候使用前者。</p>
<h4 id="layerX-layerY"><a href="#layerX-layerY" class="headerlink" title="layerX/layerY"></a><code>layerX</code>/<code>layerY</code></h4><p><code>layerX</code>/<code>layerY</code>在点击事件触发之后显示出来是点击点到目标节点的边界，而且是在目标节点的边框上。目标节点的样式是有添加<code>border</code>跟<code>padding</code>样式的，而这个属性绘出的线跟目标节点的边框相交但不超出，说明 <strong><code>layerX</code>/<code>layerY</code>的参考坐标轴是沿着目标节点的上边界（有边框则是沿着上边框）为x轴，目标节点的左边界（有边框则是沿着左边框）为y轴</strong> 。跟目标节点的<code>margin</code>，页面的可视范围没有关系。</p>
<h4 id="offsetX-offsetY"><a href="#offsetX-offsetY" class="headerlink" title="offsetX/offsetY"></a><code>offsetX</code>/<code>offsetY</code></h4><p><code>offsetX</code>/<code>offsetY</code>跟<code>layerX</code>/<code>layerY</code>很接近，但是它跟目标节点的边框没有相交，也就是当目标节点没有边框的情况下，<code>offsetX</code>/<code>offsetY</code>跟<code>layerX</code>/<code>layerY</code>的值是相等的。<strong><code>offsetX</code>/<code>offsetY</code>的参考坐标轴是沿着目标节点的上边界为x轴，目标节点的左边界为y轴</strong> 。跟目标节点的<code>margin</code>，页面的可视范围没有关系。</p>
<h4 id="pageX-pageY"><a href="#pageX-pageY" class="headerlink" title="pageX/pageY"></a><code>pageX</code>/<code>pageY</code></h4><p><code>pageX</code>/<code>pageY</code>在点击事件触发之后显示出来是点击点到文档页面的边界，及时是页面发生了滚动，这个属性仍然显示的是点击点在文档页面的相对位置。所以 <strong><code>pageX</code>/<code>pageY</code>的参考坐标轴是沿着文档页面的上边界为x轴，文档页面的左边界为y轴</strong> 。跟目标节点，页面的可视范围没有关系。</p>
<h4 id="screenX-screenY"><a href="#screenX-screenY" class="headerlink" title="screenX/screenY"></a><code>screenX</code>/<code>screenY</code></h4><p><code>screenX</code>/<code>screenY</code>代码中没有绘制，原因在于这个属性的坐标是整个屏幕，跟浏览器无关，所以无法绘制展示出来。</p>
<p>上述就是鼠标事件event中关于x/y属性的梳理。文中的代码已上传github：<br><a href="https://github.com/listentolife/mouseEventPositionAttributes" target="_blank" rel="noopener">https://github.com/listentolife/mouseEventPositionAttributes</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/01/16/Vuejs-keepAlive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/16/Vuejs-keepAlive/" itemprop="url">Vue.js keep-alive组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T22:15:21+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有时候会觉得学习vue像在寻宝一样。因为vue中有很多很有用的组件，像之前写的关于插槽组件的那篇一样，我也是认为插槽组件很有用，可以更好的实现组件复用。这篇主要整理keep-alive组件的内容。</p>
<p>keep-alive组件是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p>
<p>keep-alive组件可以使用到动态组件<code>&lt;component&gt;</code>，也可以使用到路由组件<code>&lt;router-view&gt;</code>上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用到动态组件上</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;compunent :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">// 使用到路由组件上</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>keep-alive组件内可以由多个子组件，但是要求只能同时渲染一个子组件，也就是多子组件时，可以使用<code>v-if</code>，<code>v-else</code>，但不支持<code>v-for</code>。</p>
<p>它有三个props：<code>include</code>，<code>exclude</code>，<code>max</code>。</p>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a><code>include</code></h3><p><code>include</code>支持组件名匹配字符串或正则表达式的组件被缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;book&quot;&gt;</span><br><span class="line">  &lt;!-- 将缓存name为book的组件，name为movie的组件将不会被缓存 --&gt;</span><br><span class="line">  &lt;component&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive include=&quot;a,b&quot;&gt;</span><br><span class="line">  &lt;!-- 将缓存name为a或者b的组件，结合动态组件使用 --&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用正则表达式，需使用v-bind --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;/a|b/&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态匹配判断是否缓存 --&gt;</span><br><span class="line">&lt;keep-alive :include=&quot;[&apos;books&apos;, &apos;movies&apos;] &quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a><code>exclude</code></h3><p><code>exclude</code>跟<code>include</code>刚好相反，组件名不匹配字符串或正则表达式的组件才会被缓存。用法跟<code>include</code>一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive exclude=&quot;book&quot;&gt;</span><br><span class="line">  &lt;!-- 除name为book的组件之外其他组件都会被缓存，如name为movie的组件 --&gt;</span><br><span class="line">  &lt;component&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive exclude=&quot;a,b&quot;&gt;</span><br><span class="line">  &lt;!-- 将不缓存name为a或者b的组件 --&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用正则表达式，需使用v-bind --&gt;</span><br><span class="line">&lt;keep-alive :exclude=&quot;/a|b/&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态匹配判断是否缓存 --&gt;</span><br><span class="line">&lt;keep-alive :exclude=&quot;[&apos;books&apos;, &apos;movies&apos;] &quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<h3 id="max"><a href="#max" class="headerlink" title="max"></a><code>max</code></h3><p><code>max</code>表示最多可以缓存多少个组件实例。一旦这个数字达到了，在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 最多只能缓存10个组件实例，而且是最新被访问的组件实例才会被缓存 --&gt;</span><br><span class="line">&lt;keep-alive :max=&quot;10&quot;&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/01/16/Vuejs-VueRouterII/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/16/Vuejs-VueRouterII/" itemprop="url">Vue Router学习(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T22:13:14+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇整理一下vue-router的两个部分：编程式导航及路由传值。</p>
<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>编程式导航其实是跟声明式导航相对的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明式路由导航</span><br><span class="line">&lt;router-link to=&apos;/books&apos;&gt;To Books List&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">// 编程式路由导航</span><br><span class="line">router.push(&#123;</span><br><span class="line">  path: &apos;/books&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>两种方式都可以实现路由导航，使用<code>&lt;router-link&gt;</code>相当于调用了<code>router.push</code>。不过编程式导航，还有<code>router.replace()</code>，<code>router.go()</code>，<code>router.back()</code>及<code>router.forward()</code>方法可以调用。</p>
<h4 id="router-push-amp-router-replace"><a href="#router-push-amp-router-replace" class="headerlink" title="router.push()&amp;router.replace()"></a><code>router.push()</code>&amp;<code>router.replace()</code></h4><p><code>router.push()</code>和<code>router.replace()</code>传参都是一样，分别是必须传值的<code>location</code>和可选的<code>onComplete</code>，<code>onAbort</code>回调。</p>
<p><code>location</code>传入的参数可以是字符串，直接指向路由地址，也可以是描述地址的对象，还可以是路由对象及带查询参数的对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 官方文档的代码*/</span><br><span class="line">// 字符串</span><br><span class="line">router.push(&apos;home&apos;)</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">router.push(&#123; path: &apos;home&apos; &#125;)</span><br><span class="line"></span><br><span class="line">// 命名的路由</span><br><span class="line">router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)</span><br><span class="line"></span><br><span class="line">// 带查询参数，变成 /register?plan=private</span><br><span class="line">router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>下面是实际项目中对编程式导航的实现及router.push()的运用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 项目中的实现 */</span><br><span class="line">&lt;!-- 监听点击事件，再使用编程式导航到新路由 --&gt;</span><br><span class="line">&lt;li</span><br><span class="line">  v-for=&quot;(movie,index) in movies&quot;</span><br><span class="line">  :key=&quot;index&quot;</span><br><span class="line">  class=&quot;movie-list&quot;</span><br><span class="line">  @click=&quot;selectMovie(movie)&quot;</span><br><span class="line">  &gt;...&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">// 这里使用的this.$router等同于router对象</span><br><span class="line">// 上一篇中说到在各个组件中都可以调用到this.$router</span><br><span class="line">selectMovie (movie) &#123;</span><br><span class="line">  this.$router.push(&#123;</span><br><span class="line">    name: &apos;movie-item&apos;,</span><br><span class="line">    params: &#123;</span><br><span class="line">      id: movie.title,</span><br><span class="line">      movie: movie</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>router.push()</code>实际上是在history栈添加一个新的记录，也就是用户点击浏览器后退时，是可以返回到上一个路由的。</p>
<p>官方文档中提醒了一句：<strong>如果提供了<code>path</code>，<code>params</code>会被忽略。</strong>如果要传入无法通过路径传入的值，或者传入值较多，建议使用parmas。</p>
<p>可选的<code>onComplete</code>，<code>onAbort</code>回调主要用在导航完成之后及导航终止的时候进行调用。目前我还没有看到网上有什么人有讲到这部分，所以了解就好，以后再深入。</p>
<p><code>router.replace()</code>跟<code>router.push()</code>有一个很大的区别，在于它不是在history栈添加一个新的记录，而是替换当前的记录，也就是无法返回上一个路由记录。其他使用方面都是一样的。</p>
<h4 id="router-go-，router-back-及router-forward"><a href="#router-go-，router-back-及router-forward" class="headerlink" title="router.go()，router.back()及router.forward()"></a><code>router.go()</code>，<code>router.back()</code>及<code>router.forward()</code></h4><p><code>router.go()</code>的参数是一个整数，表示在浏览器记录中向前或向后几步。如果是向前一步，就是<code>router.go(1)</code>，即<code>router.back()</code>；如果是向后一步，就是<code>router.go(-1)</code>，即<code>router.forward()</code>。</p>
<h3 id="路由传值"><a href="#路由传值" class="headerlink" title="路由传值"></a>路由传值</h3><p>其实前面的篇幅中，多少已经涉及到路由传值了。路由传值主要是在<code>&lt;router-link&gt;</code>的<code>to</code>属性中跟<code>router.push()</code>中使用，传值也分<code>params</code>跟<code>query</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 使用动态路由时，在to属性中使用params对象传值</span><br><span class="line">&lt;router-link</span><br><span class="line">  class=&quot;music-list&quot;</span><br><span class="line">  tag=&quot;li&quot;</span><br><span class="line">  :to=&quot;&#123;name:&apos;music-item&apos;,params:&#123;id:music.title,music:music&#125;&#125;&quot;</span><br><span class="line">  v-for=&quot;music in musics&quot;</span><br><span class="line">  :key=&quot;music.title&quot;</span><br><span class="line">&gt;...&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">// 使用编程式导航时，直接在location参数中写入params传值</span><br><span class="line">// query的写法一样</span><br><span class="line">selectMovie (movie) &#123;</span><br><span class="line">  this.$router.push(&#123;</span><br><span class="line">    name: &apos;movie-item&apos;,</span><br><span class="line">    params: &#123;</span><br><span class="line">      id: movie.title,</span><br><span class="line">      movie: movie</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有提到，如果提供了<code>path</code>，<code>params</code>会被忽略，所以一般使用params时，就需要传入name指明路由名，如果使用query时，就可以直接传入路由路径。</p>
<p>传值在组件内可以通过<code>this.$route.params</code>及<code>this.$route.query</code>获得。</p>
<p>使用<code>path</code>，<code>params</code>时有一点需要注意，使用<code>path</code>传值，刷新页面参数会丢失；使用<code>params</code>查询参数，刷新页面参数就不会丢失。</p>
<p>vue-router的这两篇内容算入门内容，简单做整理，加深理解。vue-router的其他内容也会在深入学习使用之后再整理出来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/01/10/Vuejs-VueRouter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/10/Vuejs-VueRouter/" itemprop="url">Vue Router学习(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-10T21:39:30+08:00">
                2019-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在尝试用Vue.js来重构我之前用react写的豆瓣项目了，感觉vue-router这块的内容还是挺多的，在项目的重构中也看了官方文档跟上网其他人的博客，也决定自己总结一下相关的一些内容，把自己在项目中遇到的点做一些整理。这个估计一次性也是说不完的，所以也分几篇来整理了。</p>
<p>以下使用的一些示例代码是来源于我的豆瓣项目：<a href="https://github.com/listentolife/Vue-doubanPocket" target="_blank" rel="noopener">https://github.com/listentolife/Vue-doubanPocket</a></p>
<p>这里先整理动态路由跟嵌套路由。</p>
<h3 id="基础路由"><a href="#基础路由" class="headerlink" title="基础路由"></a>基础路由</h3><p>首先，vue-router是vue.js的官方路由管理器，功能在官方文档中有列表介绍，我会根据开发中对vue-router使用的程度一点点整理。</p>
<p>最基础的路由使用，官方给出了完整的操作，包括JavaScript的五步操作：引入调用vue-router，定义组件，定义路由，创建配置router实例，创建和挂载根实例。</p>
<h4 id="JavaScript操作"><a href="#JavaScript操作" class="headerlink" title="JavaScript操作"></a>JavaScript操作</h4><p>实际操作中，我在项目的src目录下会创建一个router目录，在这里完成上面JavaScript的前四步操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// router/index.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">import Book from &apos;components/book/book&apos;</span><br><span class="line">import Movie from &apos;components/movie/movie&apos;</span><br><span class="line"></span><br><span class="line">// 注册Router</span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  mode: &apos;history&apos;,</span><br><span class="line">  base: process.env.BASE_URL,</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      redirect: &apos;/book&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/book&apos;,</span><br><span class="line">      name: &apos;book&apos;,</span><br><span class="line">      component: Book</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/movie&apos;,</span><br><span class="line">      name: &apos;movie&apos;,</span><br><span class="line">      component: Movie</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后在根实例上挂载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// main.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure>
<h4 id="router组件操作"><a href="#router组件操作" class="headerlink" title="router组件操作"></a>router组件操作</h4><p>然后就可以使用<code>&lt;router-link&gt;</code>导航组件跟<code>&lt;router-view&gt;</code>组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// components/tag.vue</span><br><span class="line">/* 在router-link导航，</span><br><span class="line"> * tag指定组件会被渲染成什么标签，默认为a标签</span><br><span class="line"> * to传入的是指定的链接，也可以是一个对象，这个后面再细说</span><br><span class="line"> */</span><br><span class="line">&lt;router-link class=&quot;tab-item&quot; tag=&quot;div&quot; to=&quot;/book&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;tab-link&quot;&gt;图书&lt;/span&gt;</span><br><span class="line">    &lt;/router-link&gt;</span><br><span class="line">    &lt;router-link class=&quot;tab-item&quot; tag=&quot;div&quot; to=&quot;/movie&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;tab-link&quot;&gt;电影&lt;/span&gt;</span><br><span class="line">    &lt;/router-link&gt;</span><br><span class="line">	</span><br><span class="line">// 路由匹配到的组件会渲染在这里</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<h4 id="this-router和this-route"><a href="#this-router和this-route" class="headerlink" title="this.$router和this.$route"></a><code>this.$router</code>和<code>this.$route</code></h4><p>这样就可以完成最简单的路由。<em>“我们可以在任何组件内通过<code>this.$router</code>访问路由器，也可以通过<code>this.$route</code>访问当前路由”</em>。</p>
<p>上面这段引号的话是需要注意的。通过<code>this.$router</code>是访问<strong>路由器</strong>，通过<code>this.$route</code>是访问<strong>当前路由</strong>。</p>
<p>一开始我也不是很明白，就在项目中写了一段console.log，尝试打印一下这两个：</p>
<p><img src="https://listentolife.cc/images/router&amp;route.PNG" alt="this.$router &amp; this.route"></p>
<p>这样看就比较明白了：<code>this.$router</code>指向的是router目录中创建的路由实例，<code>this.$route</code>指向的是当前渲染的路由对象。</p>
<p>通过<code>this.$route</code>跟<code>this.$router</code>，我们有一些常用的方法可以调用，这里就属于编程式导航中会提及的内容，等后面再整理了。</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>上面的例子是比较简单的路由实现，但实际上很多时候是没办法把路由路径写死的，比较用户页面，比如我的项目中每个图书页面都是一样的，但是图书是各不相同的。这个时候就需要用到动态路由来实现。</p>
<p>实现动态路由，需要以下几步（基于上面的例子）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// router/index.js</span><br><span class="line">// 先在路由器上配置路由</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/musicDetail/:id&apos;,</span><br><span class="line">    name: &apos;music-item&apos;,</span><br><span class="line">    component: MusicItem</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>/musicDetail/:id</code>这个路径包含了一个路径参数<code>id</code>，前面使用<code>:</code>标记。这个路径参数会被设置到<code>this.$route.params</code>中，可以被组件使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// music.vue</span><br><span class="line">// 使用动态路由，就需要用对象来传值给to</span><br><span class="line">// 路由渲染后，地址上也是显示/musicDetail/(music.title)</span><br><span class="line">&lt;router-link</span><br><span class="line">  class=&quot;music-list&quot;</span><br><span class="line">  tag=&quot;li&quot;</span><br><span class="line">  :to=&quot;&#123;name:&apos;music-item&apos;,params:&#123;id:music.title,music:music&#125;&#125;&quot;</span><br><span class="line">  v-for=&quot;music in musics&quot;</span><br><span class="line">  :key=&quot;music.title&quot;</span><br><span class="line">&gt;...&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">// 路由匹配到的组件会渲染在这里</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<p>在组件内，就可以利用<code>this.$route.params</code>可以获得父组件传入的值。由于在路由配置时路径参数只有<code>id</code>，所以只有<code>id</code>会显示在地址上，其他值不会显示在地址上，可以传入很多数据。</p>
<p>有几个地方需要留意的：</p>
<ol>
<li>一个路由可以设置多段路径参数，但是一定要一一匹配上;</li>
<li>使用动态路由，匹配同一动态路径的路由之间导航，组件实例会被复用，组件的声明钩子将不会再被调用。可以使用<code>watch</code>或导航守卫响应路由变化；</li>
<li>多个路由同时匹配同一路径时，最先定义的优先级越高。</li>
</ol>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>嵌套路由就是在路由内再嵌套路由组件，通过路由做跳转，跳转前后父路由组件不受影响。比如根路径‘/’下路由导航到‘/book’，渲染book组件，在book组件内有子路由‘/book/detail/:id’，路由跳转时，book组件内<code>&lt;router-view&gt;</code>之外不受影响。</p>
<p>子路由配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// router/index.js</span><br><span class="line">// 在&apos;/book&apos;路由下配置子路由</span><br><span class="line">  &#123;</span><br><span class="line">    path: &apos;/book&apos;,</span><br><span class="line">    name: &apos;book&apos;,</span><br><span class="line">    component: Book,</span><br><span class="line">    children: [&#123;</span><br><span class="line">      // 当/book/:id匹配成功，就会在book组件内的&lt;router-view&gt;中渲染bookItem组件</span><br><span class="line">      path: &apos;:id&apos;,</span><br><span class="line">      name: &apos;book-item&apos;,</span><br><span class="line">      component: BookItem</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<p>子路由导航与出口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// book.vue</span><br><span class="line">// 写法跟动态路由中的差不多</span><br><span class="line">&lt;router-link</span><br><span class="line">  class=&quot;book-list&quot;</span><br><span class="line">  tag=&quot;li&quot;</span><br><span class="line">  :to=&quot;&#123;name:&apos;book-item&apos;,params:&#123;id:book.title,book:book&#125;&#125;&quot;</span><br><span class="line">  v-for=&quot;book in books&quot;</span><br><span class="line">  :key=&quot;book.title&quot;</span><br><span class="line">&gt;...&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">// 路由匹配到的组件会渲染在这里</span><br><span class="line">// 注意，这个&lt;router-view&gt;是写在book组件中的</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p>
<p>嵌套路由也有需要注意的：上面子路由配置中，path的值是 <strong>‘:id’</strong> ，不是 <strong>‘/:id’</strong> 。如果路径前有<code>/</code>斜杠，则嵌套路径指向根路径上的。</p>
<p>以上就是Vue Router关于动态路由跟嵌套路由的内容整理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/12/19/Vuejs-Slots/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/Vuejs-Slots/" itemprop="url">Vue.js插槽组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T08:18:17+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里写一下关于Vue.js插槽的内容。之前在学习vue.js的时候就觉得这个插槽非常有意思，非常神奇，在官方文档跟一些教程的学习后，觉得有必要单独记录一下，所以这里准备了这么一篇。</p>
<h3 id="插槽是什么"><a href="#插槽是什么" class="headerlink" title="插槽是什么"></a>插槽是什么</h3><p>官方文档是这么解释的：<em>Vue 实现了一套内容分发的 API，这套 API 基于当前的 Web Components 规范草案，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</em></p>
<p>简单的说，插槽是vue.js的一套API，是用于实现内容分发的，使用<code>&lt;slot&gt;</code> 元素做接口。</p>
<p>从我个人的使用理解来说，就是子组件上留了一些口，这些口就是插槽，这些口可以提供给父组件进行自定义的插入内容，包括字符串，html标签，甚至其他组件。</p>
<h3 id="没有使用插槽的情况"><a href="#没有使用插槽的情况" class="headerlink" title="没有使用插槽的情况"></a>没有使用插槽的情况</h3><p>一般来说，在没有使用插槽的情况下，或者子组件没有留插槽的情况下，父组件上在组件标签之间码下的所有内容，都会被抛弃。这也是vue.js官方文档中明确提醒的。也就是说，没有插槽，父子组件之间只有通信的操作，父组件并不能控制在子组件内展示什么内容。</p>
<h3 id="插槽的实现"><a href="#插槽的实现" class="headerlink" title="插槽的实现"></a>插槽的实现</h3><p>实现插槽不难，理解插槽就好办了。上面说了，我理解的插槽就是在子组件上留一些口，父组件引用子组件时就可以在这些口上插入内容了。因此，先要在子组件上开口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- child-component --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h2&gt;child component&lt;/h2&gt;</span><br><span class="line">  &lt;p&gt;slot标签就是子组件留的口，下面的内容就是父组件通过插槽传给子组件的&lt;/p&gt;</span><br><span class="line">  &lt;slot&gt;&lt;slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- parent-component --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;parent component&lt;/h1&gt;</span><br><span class="line">  &lt;child-component&gt;</span><br><span class="line">    这部分就是传入子组件slot标签的内容</span><br><span class="line">	&lt;p&gt;如果没有指定，所有父组件传入的内容都会通过这个插槽进入子组件&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;甚至下面的组件也可以被传入&lt;/p&gt;</span><br><span class="line">	&lt;icon-arrow-right&gt;&lt;/icon--arrow-right&gt;</span><br><span class="line">  &lt;/child-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这样就可以实现简单的插槽功能了。但是插槽不只是这些。插槽还分具名插槽，默认插槽。</p>
<h3 id="具名插槽-amp-默认插槽"><a href="#具名插槽-amp-默认插槽" class="headerlink" title="具名插槽&amp;默认插槽"></a>具名插槽&amp;默认插槽</h3><p>有时候子组件不止设置一个插槽，还会设置多个插槽。而在父组件上，只能在子组件标签之后传入插槽内容。所以需要一个区分的标识。就像子组件上有多个插槽，父组件要往这些插槽上分别放内容，怎么知道哪些内容放到哪个插槽呢？这就用到<code>&lt;slot&gt;</code>元素上的属性<code>name</code>了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- child-component --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h2&gt;child component&lt;/h2&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- parent-component --&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;parent component&lt;/h1&gt;</span><br><span class="line">  &lt;child-component&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;template slot=&quot;header&quot;&gt;</span><br><span class="line">	具名插槽</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;p&gt;父组件的内容传入子组件插槽时，可以使用template标签，并使用slot标识对应插槽的位置。这样就可以正确的分发到组件的插槽中。&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;如果插槽未命名，那么父组件传入的为指定分发位置的内容都会统一放在未命名插槽中，这个插槽就是默认插槽。&lt;/p&gt;</span><br><span class="line">	</span><br><span class="line">  &lt;p slot=&quot;footer&quot;&gt;最后，slot也可以用到普通的元素中&lt;/p&gt;</span><br><span class="line">	</span><br><span class="line">  &lt;/child-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>上面的例子中就实现了默认插槽，父组件所有未指定插槽的内容都会分发到默认插槽中。</p>
<h3 id="默认内容-amp-编译作用域"><a href="#默认内容-amp-编译作用域" class="headerlink" title="默认内容&amp;编译作用域"></a>默认内容&amp;编译作用域</h3><p>不过有时候父组件不一定会用上子组件的插槽。这种情况下子组件就可以指定默认的内容。如果父组件有传入内容，指定默认的内容就会被替换掉.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;main&gt;</span><br><span class="line">    &lt;slot&gt;</span><br><span class="line">	  &lt;p&gt;如果父组件没有给这个插槽传入内容，则在页面上能看到这段子组件默认的内容。&lt;/p&gt;</span><br><span class="line">	&lt;slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br></pre></td></tr></table></figure>
<p>如果想在插槽中使用数据，需要注意作用域的问题：插槽中的内容所在的作用域是父组件的作用域，只能访问父组件作用域内的数据，不能访问子组件作用域内的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template slot=&quot;header&quot;&gt;</span><br><span class="line">  &#123;&#123; article.title &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>虽然插槽所使用的数据只能是父组件的作用域，但是还是有办法使用子组件的数据的，就是作用域插槽。</p>
<p>作用域插槽就是把子组件需要在插槽内使用的数据作为插槽的prop传入，然后父组件在插槽内的元素或组件中使用<code>slot-scope</code>获取数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引用官方文档的例子 --&gt;</span><br><span class="line">&lt;!-- 子组件todo-list --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li</span><br><span class="line">    v-for=&quot;todo in todos&quot;</span><br><span class="line">    v-bind:key=&quot;todo.id&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;!-- 我们为每个 todo 准备了一个插槽，--&gt;</span><br><span class="line">    &lt;!-- 将 `todo` 对象作为一个插槽的 prop 传入。--&gt;</span><br><span class="line">    &lt;slot v-bind:todo=&quot;todo&quot;&gt;</span><br><span class="line">      &lt;!-- 回退的内容 --&gt;</span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    &lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 父组件中引用子组件部分 --&gt;</span><br><span class="line">&lt;todo-list v-bind:todos=&quot;todos&quot;&gt;</span><br><span class="line">  &lt;!-- 将 `slotProps` 定义为插槽作用域的名字 --&gt;</span><br><span class="line">  &lt;template slot-scope=&quot;slotProps&quot;&gt;</span><br><span class="line">    &lt;!-- 为待办项自定义一个模板，--&gt;</span><br><span class="line">    &lt;!-- 通过 `slotProps` 定制每个待办项。--&gt;</span><br><span class="line">    &lt;span v-if=&quot;slotProps.todo.isComplete&quot;&gt;✓&lt;/span&gt;</span><br><span class="line">    &#123;&#123; slotProps.todo.text &#125;&#125;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/todo-list&gt;</span><br></pre></td></tr></table></figure>
<p>这里确认一点：<code>slot-scope</code>不仅可以在<code>&lt;template&gt;</code>元素上使用，还可以在插槽内的任何元素或组件上使用。另外，官方文档还说明了，基于ES2015解构语法，上面父组件中<code>&lt;template slot-scope=&quot;slotProps&quot;&gt;</code>可以写成<code>&lt;template slot-scope=&quot;{ todo }&quot;&gt;</code>。</p>
<p>以上就是关于vue.js插槽的内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/12/19/Vuejs-Note-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/Vuejs-Note-I/" itemprop="url">Vue.js散记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T08:15:35+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里主要记录一下学习Vue过程中遇到的问题。</p>
<h4 id="1-Vue-warn-Error-in-render-“TypeError-Cannot-read-property-‘xxx’-of-undefined"><a href="#1-Vue-warn-Error-in-render-“TypeError-Cannot-read-property-‘xxx’-of-undefined" class="headerlink" title="1. [Vue warn]: Error in render: “TypeError: Cannot read property ‘xxx’ of undefined"></a>1. [Vue warn]: Error in render: “TypeError: Cannot read property ‘xxx’ of undefined</h4><p>之前敲代码的时候，发现了这个报错，一开始的观察点在TypeError上，认为是某个props没有正确定义，但是检查的时候并没有写错。后面发现应该要看前面Error in render，是渲染时报错。最后是找到有个地方变量名写错了。</p>
<h4 id="2-为什么data必须是一个函数"><a href="#2-为什么data必须是一个函数" class="headerlink" title="2. 为什么data必须是一个函数"></a>2. 为什么data必须是一个函数</h4><p>这个问题其实在vue.js官网有说明，并且给出了一个例子。正确的写法应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">  	count: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为，在创建组件的实例时，data作为一个函数可以返回一个初始化对象，能独立于其他实例的data对象。如果data不是作为一个函数，而只是一个数据，则会导致所有实例公用一个data对象。</p>
<h4 id="3-计算属性computed，侦听属性wtach-amp-方法methods"><a href="#3-计算属性computed，侦听属性wtach-amp-方法methods" class="headerlink" title="3. 计算属性computed，侦听属性wtach&amp;方法methods"></a>3. 计算属性<code>computed</code>，侦听属性<code>wtach</code>&amp;方法<code>methods</code></h4><p>计算属性<code>computed</code>的设计，是用于处理一些复杂的运算。一般在template模板中是支持使用表达式的，但是如果需要进行一些复杂的运算或数据处理，就可以把这些运算或数据处理放到计算属性中处理。</p>
<p>当然，这些复杂的运算或数据处理也可以定义为一个方法放到<code>methods</code>中，但是放在计算属性和放到方法中是有其不同的地方的。</p>
<p>vue官网有明确的指出这两者的不同。计算属性<code>computed</code>是基于它们的依赖进行缓存的。也就是说，<code>methods</code>中所有的运算结果只有当依赖的变量发生改变的时候才会重新计算，否则只要变量不改变，计算属性不会重新执行函数，直接返回缓存的计算结果。相反的，方法<code>methods</code>是并非响应式的，每次触发重新渲染时，调用的方法总会在此执行函数，即使依赖并没有发生变化。</p>
<p>计算属性<code>computed</code>的优势在于可以减少很多不必要的性能开销。而方法<code>methods</code>中的函数都是需要根据页面的渲染或不需要缓存函数结果的</p>
<p>侦听属性<code>watch</code>跟计算属性<code>computed</code>也有极为相似的方面，侦听属性是需要监听数据的变化并作出响应。但是一般用于执行异步或开销较大的操作时，才比较适合。</p>
<h4 id="4-指令v-for-amp-key"><a href="#4-指令v-for-amp-key" class="headerlink" title="4. 指令v-for &amp; key"></a>4. 指令<code>v-for</code> &amp; <code>key</code></h4><p><code>v-for</code>是vue.js用于渲染列表的指令，针对数组可以使用<code>(item, index) in items</code>的语法迭代数组，针对对象可以使用<code>(item, key, index) in items</code>的语法迭代对象。其中，<code>key</code>的用途主要在于优化渲染过程。vue.js在处理数据项的变化时，对只改变顺序的数据项会选择复用，这样能优化渲染性能。如果没有提供<code>key</code>也只是会报提示，不影响项目运行，但是建议提供（如果是在组件上使用，则必须提供<code>key</code>）。</p>
<h4 id="5-父子组件通信"><a href="#5-父子组件通信" class="headerlink" title="5. 父子组件通信"></a>5. 父子组件通信</h4><p>vue.js的父子组件通信跟react类似，父组件向子组件传值，是通过props传入，子组件是通过<code>$emit</code>方法触发父组件的事件。父组件在使用子组件时，通过v-bind指令传入或通过v-for传入数组中的一个元素，子组件需要在props中声明这些接收的值。</p>
<p>父组件通过props向子组件传值这点来看，vue.js的操作跟react是类似的，但是子组件向父组件通信的处理，就有点不同了。</p>
<p>vue.js中，父组件中需要在子组件上用<code>v-on</code>指令监听事件，然后子组件上通过<code>$emit(event, arg)</code>来向父组件触发事件，必要时传入参数<code>arg</code>。react处理上不同，react中父组件需要通过props向子组件传入方法，子组件只要使用这个方法并传入参数即可，并不是通过事件触发。</p>
<h4 id="6-通过插槽分发内容"><a href="#6-通过插槽分发内容" class="headerlink" title="6. 通过插槽分发内容"></a>6. 通过插槽分发内容</h4><p>另外开一篇文章来记录这个内容，因为插槽的分类比较多，能用起来的话作用也很强大。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/12/19/Algorithm-Analysis-Note-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/Algorithm-Analysis-Note-I/" itemprop="url">算法分析笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T08:05:36+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Algorithm-Analysis/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm Analysis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一段时间有看一些关于算法的文章，主要是因为在leetcode跟warcode都有做过一些题目了。算法以前学过一些皮毛，但是还是会觉得不够，有些算法还是需要找很多资料花一些时间才能想明白。这里整理一些关于算法分析的笔记。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="什么是复杂度分析"><a href="#什么是复杂度分析" class="headerlink" title="什么是复杂度分析"></a>什么是复杂度分析</h3><p>数据结构和算法解决的是“如何让计算机更短时间，更省空间的解决问题”，因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。</p>
<p>我们可以分别用时间复杂度和空间复杂度两个概念来描述算法的性能问题，这两个概念也统称为算法的复杂度分析。因此，算法的复杂度描述的是算法执行的时间或占用的空间与数据规模的增长关系。</p>
<h3 id="为什么要做复杂度分析"><a href="#为什么要做复杂度分析" class="headerlink" title="为什么要做复杂度分析"></a>为什么要做复杂度分析</h3><p>其一，和性能测试相比，复杂度分析有不依赖执行环境，成本低，效率高，已操作，指导性强的特点。</p>
<p>其二，掌握复杂度分析，将有助于我们编写出性能更优的代码，有利于降低系统开发和维护成本。</p>
<h3 id="如何计算复杂度"><a href="#如何计算复杂度" class="headerlink" title="如何计算复杂度"></a>如何计算复杂度</h3><h4 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h4><p>算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示其中T(n)表示内行代码执行的总次数，而n表示数据的规模。</p>
<p>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶，低阶以及系数实际上对这种增长趋势不产生决定性的影响，所以在做时间复杂度分析时可以忽略这些项。</p>
<h4 id="复杂度分析技巧："><a href="#复杂度分析技巧：" class="headerlink" title="复杂度分析技巧："></a>复杂度分析技巧：</h4><p>单独一段代码，只需要找到最高频运行的代码分析，比如循环代码。</p>
<p>多段代码的分析，则取所有代码中最高频运行的代码分析，比如一段代码中同时有单循环和多重循环的，只需要分析多重循环的代码复杂度；即：<em>如果T1(n) = O(f(n))， T2(n) = O(g(n))，则T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))</em>。</p>
<p>嵌套代码的分析，可以先把嵌套拆分分析复杂度，再相乘。即：<em>如果T1(n) = O(f(n))， T2(n) = O(g(n))，则T(n) = T1(n) x T2(n) = O(f(n) x g(n)) = O(f(n)) x O(g(n))</em>。</p>
<p>多参数多段代码的分析，需要分别分析每个参数参与代码的复杂度，然后再相加。即：<em>如果T1(n) = O(f(n))， T2(m) = O(g(m))，则T(n, m) = T1(n) + T2(m) = O(f(n)) + O(g(m))</em>。</p>
<h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p>以下是一些常见的时间复杂度量级：</p>
<ol>
<li><p>常量阶O(1)：常量阶一般指代码的时间复杂度不随n的增大而增长。</p>
</li>
<li><p>对数阶O(logn)，O(nlogn)：简单的例子：用while循环计算一个2的n次方，n是参数，其时间复杂度为O(logn)。</p>
</li>
<li><p>线性阶O(n)：线性阶指代码的时间复杂度跟n成比例。</p>
</li>
<li><p>平方阶O(n^2)，立方阶O(n^3)：平方阶跟立方阶都是随n的增大而呈现高倍增长。</p>
</li>
<li><p>非多项式阶-指数阶O(2^n)，阶乘阶O(n!)：非多项式阶的时间复杂度会随着数据的规模增长而大幅度增长，所以这类算法的性能都很差。</p>
</li>
</ol>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>一般来说，提及复杂度分析主要指的是事件复杂度分析。但是实际还有空间复杂度分析。空间复杂度全程为渐进空间复杂度，表示算法的储存空间与数据规模之间的增长关系。同样是使用大O表示法，但是分析的是存储空间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/12/19/React-Learning-React-Redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/React-Learning-React-Redux/" itemprop="url">react学习总结系列-redux&react-redux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T07:57:58+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇将介绍redux跟react-redux。这里打算是介绍这两个插件在react项目中的运用。redux是可以在其他库中使用的。</p>
<p>前面使用react开发项目，是可以实现大部分需求的。但是react毕竟是一个实现视图层的框架，它在数据层的实现还是存在一些不足的。比如当项目较大，需要使用大量的数据，父子组件之间的数据通信特别频繁的时候，性能就会直线下滑；当数据发生改变的时候，就无从得知数据是从哪里发生改变的。</p>
<p>redux作为一个应用数据流框架，它的最大的特点就是应用状态的管理，它用一个单独的常量状态树<code>store</code>保存整个应用的状态。这个状态树不能直接被改变。</p>
<p>我们分析一下。如果没有redux，react组件的所有状态<code>state</code>将各自存储于组件中，一旦遇到不同父组件的组件之间的通信问题，需要把数据先传到能使两个组件通信的上层组件，然后在下发到另一个组件。而如果使用redux，则数据都存储在常量状态树<code>store</code>中，所有组件获取状态数据都从<code>store</code>中直接获取。而组件需要修改状态数据时，只需要直接修改<code>store</code>中的数据，其他组件就会获知<code>store</code>的变化并自动重新获取状态。这样可以减少组件之间大规模的通讯消耗。</p>
<h3 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h3><p>我们了解了react的组件<code>components</code>跟redux的常量状态树<code>store</code>，那他们是怎么串连起来，是怎么样的工作流程呢？</p>
<p>这里需要考虑三个场景，一个是<code>components</code>需要修改<code>store</code>中的数据，一个是<code>store</code>中实现数据的更新，还有一个就是<code>store</code>的数据更新之后新状态同步到<code>components</code>中。</p>
<p>最主要是前两个场景。这里需要引入redux中两个概念。</p>
<h4 id="actionCreator"><a href="#actionCreator" class="headerlink" title="actionCreator"></a>actionCreator</h4><p>因为常量状态树<code>store</code>的状态数据不允许直接修改，所以当<code>components</code>需要修改<code>store</code>中的数据时，需要通过<code>actionCreator</code>中的action去让<code>store</code>做数据的更新。</p>
<p><code>actionCreator</code>是一个action的集合，这个集合中包含了各种用于申请修改的<code>action</code>。这个<code>action</code>需要包括修改数据的类型跟需要修改的数据。在<code>components</code>发出<code>store.dispatch(action)</code>之后提交给<code>store</code>，完成修改申请。</p>
<h4 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h4><p>当<code>store</code>得到action时，它本身没有什么方法可以修改数据，所以需要用到<code>reducer</code>来实现状态的更新。<code>store</code>会把当前的<code>state</code>跟前面接收到的action传给<code>reducer</code>，<code>reducer</code>会根据传入的action类型进行状态更新，然后再返回新的<code>state</code>。</p>
<h4 id="组件的状态更新"><a href="#组件的状态更新" class="headerlink" title="组件的状态更新"></a>组件的状态更新</h4><p>关于最后<code>store</code>的数据更新之后新状态同步到<code>components</code>中，阮一峰的《Redux 入门教程（一）：基本用法》中有提到，当<code>store</code>中<code>state</code>发生变化后，<code>store</code>会调用监听函数，监听函数就可以更新组件中的<code>state</code>，组件就可以重新渲染页面。</p>
<h3 id="react-redux实战"><a href="#react-redux实战" class="headerlink" title="react-redux实战"></a>react-redux实战</h3><h4 id="安装react-redux"><a href="#安装react-redux" class="headerlink" title="安装react-redux"></a>安装react-redux</h4><p>在react项目中，引入react-redux还需要引入redux：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install redux --save</span><br><span class="line">npm install react-redux --save</span><br></pre></td></tr></table></figure>
<p>这样在react项目中才可以使用react-redux。</p>
<h4 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建<code>store</code></h4><p>先在项目中创建一个store的文件夹，然后在创建一个index.js的js文件。在这个js文件中写下以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure>
<p>首先，先从redux中引入<code>createStore</code>，然后通过<code>createStore</code>来创建一个<code>store</code>，最后导出。</p>
<h4 id="创建reducer"><a href="#创建reducer" class="headerlink" title="创建reducer"></a>创建<code>reducer</code></h4><p>上面我们已经完成<code>store</code>的创建，然后需要创建<code>reducer</code>来给<code>store</code>处理数据。在store目录下创建一个reducer.js的js文件。redux中，<code>reducer</code>其实是一个函数，所需要引入的参数为当前的<code>state(preState)</code>跟<code>action</code>，而返回的是一个修改后的<code>state(newState)</code>。一般初始化的时候，没有当前的<code>state(preState)</code>，所以会先声明一个<code>defaultState</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const defaultState = &#123;</span><br><span class="line">  /*</span><br><span class="line">   *这里初始化数据</span><br><span class="line">   */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default (state = defaultState, action) =&gt; &#123;</span><br><span class="line">	switch (action.type) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * 这里判断action.type，然后修改获得newState</span><br><span class="line">		 */</span><br><span class="line">	&#125;</span><br><span class="line">    return newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，先声明一个<code>defaultState</code>作为<code>state</code>的初始化状态，然后导出一个函数，这个函数中通过判断<code>action.type</code>来修改获得<code>newState</code>，然后返回出去。</p>
<p>创建之后，需要把<code>reducer</code>传入到<code>store</code>中，因此上面的index.js需要稍加修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">import reducer from &apos;./reducer&apos;;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure>
<h4 id="创建actionCreator"><a href="#创建actionCreator" class="headerlink" title="创建actionCreator"></a>创建<code>actionCreator</code></h4><p><code>actionCreator</code>还是要强调，它是一个方法的是一个action的集合，这个集合中包含了各种用于申请修改的<code>action</code>。当然，把所有action都只在需要的时候再编写也可以，但是把所有action集中起来可以提高代码的可读性，可维护性。每一个action方法最终都是返回一个对象，这个对象包含有修改类型type跟需要修改的值。在reducer.js中，大家可以看到传入的action.type是会在switch语句中作为判断值，然后修改值则会在判断后做对应的修改。</p>
<p>在store目录下创建一个actionCreator.js的js文件，然后写入所有需要导出的action方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export const action1 = (value1) =&gt; (&#123;</span><br><span class="line">  type: actionType1,</span><br><span class="line">  value1: value1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const action2 = (value2) =&gt; (&#123;</span><br><span class="line">  type: actionType2,</span><br><span class="line">  value2: value2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在reducer中，action.type作为判断时，会再写一次。为了保证不出抄写错误，方便后期排查bug，一般还可以把actionType集中起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export const actionType1 = &apos;action_type_1&apos;;</span><br><span class="line">export const actionType2 = &apos;action_type_2&apos;;</span><br></pre></td></tr></table></figure>
<p>那么，在actionCreator中就可以改写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import * as constants from &apos;./actionType&apos;;</span><br><span class="line"></span><br><span class="line">export const action1 = (value1) =&gt; (&#123;</span><br><span class="line">  type: constants.actionType1,</span><br><span class="line">  value1: value1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const action2 = (value2) =&gt; (&#123;</span><br><span class="line">  type: constants.actionType2,</span><br><span class="line">  value2: value2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="组件中的使用"><a href="#组件中的使用" class="headerlink" title="组件中的使用"></a>组件中的使用</h4><p>组件中使用一般分引入store，调用action申请及store修改订阅。</p>
<p>组件中会现在构造函数中引入store：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor (props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = store.getState(); // 引入store，把store中的状态赋给state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当状态需要修改时，通过<code>store.dispatch()</code>调用action：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(actionCreators.action1(value1));</span><br></pre></td></tr></table></figure>
<p>action方法返回对象将交给store，但是store不会处理，而是通过dispatch方法交给reducer处理。reducer接收到action后，会根据修改类型type对数据进行更新。在store的状态进行更新之后组件就需要更新。但是组件的状态更新还需要做一步操作，就是对store变化的订阅。这个订阅也是在<code>constructor()</code>完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = store.getState(); // 引入store，把store中的状态赋给state</span><br><span class="line">  store.subscribe(this.handleStoreChange); // 订阅store的状态修改，如果检测到修改，则调用this.handleStoreChange监听函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是对redux跟react-redux使用的总结。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/12/19/React-Learning-Styled-Components/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/React-Learning-Styled-Components/" itemprop="url">react学习总结系列-styled-components</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T07:54:08+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一篇主要整理关于React的CSS插件styled-components。这个插件是我一开始学习React跟做项目的时候推荐并使用的。用了之后觉得这个插件确实很适合React的项目，有无缝对接的效果。</p>
<p>这里也是留一下styled-components官网文档地址：</p>
<p><a href="https://www.styled-components.com/docs" target="_blank" rel="noopener">https://www.styled-components.com/docs</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>简单说一下安装。</p>
<p>代码1 NPM&amp;CDN安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* NPM install */</span><br><span class="line">npm  install --save styled-components</span><br><span class="line"></span><br><span class="line">/* CDM install */</span><br><span class="line">; &lt;script src=&quot; https://unpkg.com/styled-components/dist/styled-components.min.js&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>styled-components使用也比较简单。最简单的写法就是声明styled变量，然后把css样式以模板字符串形式写入，最后把这个变量以React组件的形式写到<code>render()</code>中就可以了。</p>
<p>代码2 styled-components简单例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: palevioletred;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Wrapper = styled.section`</span><br><span class="line">  padding: 4em;</span><br><span class="line">  background: papayawhip;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Wrapper&gt;</span><br><span class="line">    &lt;Title&gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">  &lt;/Wrapper&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>上面是官网用例。可以看到，其实是把css样式表嵌入到JavaScript中，然后通过styled-components转成组件，然后再在其他组件中使用。所以使用起来非常简单。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>因为style-components把css样式表转成一个个的组件，所以也可以实现一些样式的传参。</p>
<p>代码2 传递参数，对代码1的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: \function(e)&#123;return e.inputColor||&quot;palevioletred&quot;&#125;;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Title inputColor=&quot;rebeccapurple&quot; &gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>代码2中，在变量<code>Input</code>的样式表中，color后面是跟着一个<code>\</code>，接着一个匿名函数。这个匿名函数有一个传参<code>e</code>，函数中会返回<code>e.inputColor</code>或默认值<code>&quot;palevioletred&quot;</code>。在<code>render()</code>函数中，第二个<code>Input</code>组件标签中声明了一个inputColor的属性值，而第一个没有。在最终的显示上，第一个组件字体样式是紫罗兰红(palevioletred)，第二个组件字体样式是丽贝卡紫(rebeccapurple)。也就是说，变量<code>Input</code>的样式表中的匿名函数，传入的参数<code>e</code>应该指向当前组件对象</p>
<p>传递参数的类型还可以是真假值。组件的属性上，可以直接声明一个属性并不传值，匿名函数中可将直接判断是否存在这个属性，以确定返回的样式值。</p>
<p>代码3 传递属性，对代码1的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: $&#123;props =&gt; props.primary ? &quot;palevioletred&quot; : &quot;white&quot;&#125;;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Title primary &gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="组件继承"><a href="#组件继承" class="headerlink" title="组件继承"></a>组件继承</h3><p>一个项目中或多或少会出现一些组件上设计样式的类似，比如不同级标题可能HTML样式，尺寸是一样的，但是颜色会不同。如果都是写成独立的组件样式表，则会出现代码冗余，不好维护。这种情况下就可以考虑使用组件继承。</p>
<p>代码4 组件继承，对代码1的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: palevioletred;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const SecondTitle = styled(Title)`</span><br><span class="line">	font-size: 1em;</span><br><span class="line">	font-weight: bold;</span><br><span class="line">` </span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Title&gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">	&lt;SecondTitle&gt;</span><br><span class="line">	  This is the second title!</span><br><span class="line">	&lt;/SecondTitle&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>如果<code>Title</code>中没有样式的话，那它就是直接继承<code>react.component</code>的组件，仍然可以被继承。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>styled-components对动画也有很好的支持。内置了<code>keyframes</code>来实现CSS3中的<code>@keyframes</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const rotate360 = keyframes`</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: rotate(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: rotate(360deg);</span><br><span class="line">  &#125;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Rotate = styled.div`</span><br><span class="line">  display: inline-block;</span><br><span class="line">  animation: $&#123;rotate360&#125; 2s linear infinite;</span><br><span class="line">  padding: 2rem 1rem;</span><br><span class="line">  font-size: 1.2rem;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Rotate&gt;&amp;lt; 💅 &amp;gt;&lt;/Rotate&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>除了上面介绍的方面之外，styled-component插件还有一些更复杂的用法，但是目前大部分的样式实现只要上面这些内容掌握了，在项目中也能解决大部分的问题了。剩下的以后有涉及到会再介绍。</p>
<p>下一篇将会介绍redux及react-redux插件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/11/24/React-Learning-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/24/React-Learning-II/" itemprop="url">react学习总结系列-react(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-24T21:29:27+08:00">
                2018-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇主要写的是React中父子组件数据传递跟生命周期。</p>
<h3 id="父子组件数据传递"><a href="#父子组件数据传递" class="headerlink" title="父子组件数据传递"></a>父子组件数据传递</h3><p>上一篇其实有说到，组件跟组件之前其实是相对独立的。虽然每个组件的数据是可以独立处理，但是组件与组件之间的数据还是存在联系的，而所有的组件之间的数据关系，都是可以归结为父组件跟子组件之间的数据传递关系。再拆分这种数据传递关系，就是要解决<strong>父组件数据传给子组件</strong>，<strong>子组件数据传给父组件</strong>两个问题。</p>
<ol>
<li><strong>父组件传入参数</strong>。在React中，父组件给子组件传递数据其实挺简单的，就是在子组件标签中通过变量进行传入，子组件通过props获取传入的数据：</li>
</ol>
<p>代码1 父组件传参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* 自己写豆瓣的一段代码，</span><br><span class="line">  * 图书页面Book组件中把页面类型参数Contants.Book传入</span><br><span class="line">  * 搜索Search组件</span><br><span class="line">  * /</span><br><span class="line">class Book extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;Search</span><br><span class="line">          page=&#123;this.state.book&#125;</span><br><span class="line">          searchInfo=&#123;this.getSearchInfo&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 搜索Search组件通过props.page接收父组件的参数，</span><br><span class="line">  * 判断input标签的属性placeholder的值</span><br><span class="line">  * 项目中还使用了styled-components插件，后面会另有介绍</span><br><span class="line">  * /</span><br><span class="line">class Search extends Component &#123;</span><br><span class="line">  // 根据父组件传入的props.page确定input标签的属性placeholder的值</span><br><span class="line">  showPlaceHolder () &#123;</span><br><span class="line">    const &#123; placeHolders, page &#125; = this.props</span><br><span class="line">    const placeHoldersJS = placeHolders.toJS()</span><br><span class="line">    return placeHoldersJS[page]</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;SearchWrapper&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;SearchInput</span><br><span class="line">            value=&#123;this.props.keyword&#125;</span><br><span class="line">            placeholder=&#123;this.showPlaceHolder()&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/SearchWrapper&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码有所省略，但基本上是对父子组件之前传递数据有基本的实现。注意，父组件的数据需要在子组件标签内用一个变量传入，这个变量将会放在子组件的props属性中。子组件调用这个变量时需要到props中调用。</p>
<ol start="2">
<li><strong>子组件传出参数</strong>。一般来说，React的数据流是单向流动，即父组件的数据可以流入子组件，但是子组件的数据是不能向父组件传递或修改父组件的数据。但是子组件是可以通过自己的事件处理函数，手动触发父组件传递进来的回调函数，在回调函数上把数据通过参数传递进去。这样就可以让子组件当数据有变化的时候，父组件也可以根据变化进行响应处理：</li>
</ol>
<p>代码2 子组件调用父组件回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 父组件Book组件向子组件Search先传入getSearchInfo()方法</span><br><span class="line">class Book extends Component &#123;</span><br><span class="line">  constructor (props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.getSearchInfo = this.getSearchInfo.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getSearchInfo (newKeyword) &#123;</span><br><span class="line">    /* 省略代码 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    const &#123; pullDownStatus, pullUpStatus &#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;Search</span><br><span class="line">          searchInfo=&#123;this.getSearchInfo&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子组件在handleClick()方法中调用父组件传入的回调函数searchInfo(keyword)，并把值传入</span><br><span class="line">class Search extends Component &#123;</span><br><span class="line">  constructor (props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.handleClick = this.handleClick.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    const &#123; searchInfo, keyword&#125; = this.props</span><br><span class="line">    if (keyword !== &apos;&apos;) &#123;</span><br><span class="line">      searchInfo(keyword)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;SearchWrapper&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;SearchInput /&gt;</span><br><span class="line">          &lt;SearchButton</span><br><span class="line">            onClick=&#123;this.handleClick&#125;</span><br><span class="line">          &gt;搜索&lt;/SearchButton&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/SearchWrapper&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有个地方需要注意的。父组件方法<code>getSearchInfo()</code>虽然是对象中的方法，但是它也有自己的作用域，所以正常来说它的this指向它自己的作用域，this.props就不存在了。所以需要在<code>constructor()</code>中指定它的作用域为整个类，需要补上<code>this.getSearchInfo = this.getSearchInfo.bind(this)</code>。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>我们来回头说一下组件的生命周期。组件的生命周期包括了初始化，第一次加载渲染，更新渲染跟卸载四个阶段。而React的生命周期函数主要分布在后面三个阶段。我们先每个阶段简单整理一下：</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>这个阶段主要还是调用了ES6中类的<code>constructor()</code>。通过构造器完成对父类的继承，变量的初始化和函数指定作用域。这个阶段还没有调用生命周期函数。</p>
<h4 id="第一次加载渲染"><a href="#第一次加载渲染" class="headerlink" title="第一次加载渲染"></a>第一次加载渲染</h4><p>第一次加载渲染的过程会调用三个生命周期函数：</p>
<p>1.<code>componentWillMount()</code>，这个函数将会在组件第一次加载渲染之前被调用。可以做一些组件渲染到页面前的操作。只调用一次。</p>
<p>2.<code>render()</code>，这个函数就是负责创建虚拟DOM，此时所有数据都至少已经初始化了。</p>
<p>3.<code>componentDidMount()</code>，这个函数是在组件第一次加载渲染完成之后马上被调用的，也只调用一次。这个函数可以调用ajax请求，返回的数据会在后面阶段更新组件状态，并触发重新渲染</p>
<h4 id="更新渲染"><a href="#更新渲染" class="headerlink" title="更新渲染"></a>更新渲染</h4><p>第一次加载渲染完成之后到组件被卸载之前，组件中的state状态跟props数据还是可以改变。所以会调用下面几个生命周期函数：</p>
<p>1.<code>componentWillReceiveProps(nextProps)</code>，在组件第一次加载渲染之后，如果props数据将要发生改变，那改变之前会先调用这个函数。函数的传参为props改变之后的值。</p>
<p>2.<code>shouldComponentUpdate(nextProps,nextState)</code>，在组件props或state将发生改变，进行更新渲染之前会调用这个函数。函数的传参为props或者state改变之后的值。函数最后返回值一定是布尔值，表示是否重新渲染组件(true为重新渲染，false为阻止渲染)。这里可以判断props或state的值是否达到需要重新渲染组件的要求。这个函数的判断有助于提高页面性能，因为当父组件重新渲染时也会导致其所有子组件重新渲染，所以在组件中做这个判断可以阻止不必要的重新渲染。</p>
<p>3.<code>componentWillUpdate (nextProps,nextState)</code>，在组件调用<code>shouldComponentUpdate(nextProps,nextState)</code>并返回<code>true</code>之后，进行更新渲染之前会调用这个函数。这里同样可以拿到<code>nextProps</code>跟<code>nextState</code>进行操作。</p>
<p>4.<code>render()</code>，这里的渲染就是根据新更新的<code>props</code>跟<code>state</code>的值进行重新创建虚拟DOM，然后在根据diff算法比对新旧DOM数，找到有差异的最小DOM节点，并重新渲染。</p>
<p>5.<code>componentDidUpdate(prevProps,prevState)</code>，在组件重新渲染之后会调用这个函数。函数的传参为props或者state改变之前的值。</p>
<h4 id="组件卸载"><a href="#组件卸载" class="headerlink" title="组件卸载"></a>组件卸载</h4><p>当组件将不再被渲染到页面上时，组件将会被卸载。卸载前只有一个函数会被触发调用：</p>
<p><strong><code>componentWillUnmount ()</code></strong> ，这个函数因为是在组件被卸载前被调用，所以很适合以下一些操作：</p>
<p>1.清除组件内的所有定时<code>setTimeout</code>，<code>setInterval</code>；</p>
<p>2.移除组件内的所有监听事件 <code>removeEventListener</code>；</p>
<p>3.处理未完成的ajax请求。一般ajax请求之后都会修改state，导致会调用组件的<code>setState()</code>，如果组件被卸载的时候ajax请求未完成，会导致请求完成后调用报错，所以可以在组件内设置状态值控制ajax请求完成后是否执行组件内<code>setState()</code>，然后在<code>componentWillUnmount ()</code>中修改状态值。</p>
<h4 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h4><p>这里拓展一下，父子组件的生命周期被调用也是有顺序的。</p>
<p>在组件初次渲染阶段，会从父组件开始，先调用父组件的<code>constructor()</code>构造函数、<code>componentWillMount()</code>，然后接着子组件开始调用这两个函数，直到最底层子组件调用这两个函数。接着调用对底层子组件的<code>componentDidMount()</code>，再一层层往上调用父组件的这个函数，直到最顶层父组件。</p>
<p>在组件的卸载阶段，则会先从最顶层父组件开始调用<code>componentDidUnmount()</code>，直到最底层子组件。</p>
<h4 id="父子组件之间的性能优化"><a href="#父子组件之间的性能优化" class="headerlink" title="父子组件之间的性能优化"></a>父子组件之间的性能优化</h4><p>其实在React中，父组件的数据变化，是会影响子组件进行重新渲染，倒是出现不必要的性能消耗。</p>
<p>前面有说到，可以通过<code>shouldComponentUpdate(nextProps,nextState)</code>函数来判断是否需要重新渲染组件，但这样一来，每个组件都要手动判断重新渲染。每次只要出现父组件传来的数据，包括state状态的变化，都会调用这个函数，也会导致代码冗余。所以React还提供了一种处理方案。</p>
<p>React V15中就引入了<code>React.PureComponent</code>。这个<code>PureComponent</code>跟<code>Component</code>用法上是一样的，只是组件继承了<code>PureComponent</code>类后，组件会自动实现<code>props</code>跟<code>state</code>的浅比较。当组件的<code>props</code>跟<code>state</code>的类型都比较简单的时候，就可以直接使用<code>PureComponent</code>。当如果<code>props</code>跟<code>state</code>是嵌套对象或数组时，浅比较将得不到预期的结果。</p>
<p>关于 React的内容就先把这些基础的先介绍到这里，主要还是要看文档，这里的就算是一些个人整理。下一篇将会介绍style-components插件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Listentolife</p>
              <p class="site-description motion-element" itemprop="description">Listentolife's Blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archive">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/listentolife" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:listentolife@qq.com" target="_blank" title="E-Mail">
                      E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Listentolife</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




<span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;</span>
<span id="showDays"></span>

<script>
	var birthDay = new Date('04/23/2018');
	var now = new Date();
	var duration = now.getTime() - birthDay.getTime();
	var total= Math.floor(duration / (1000 * 60 * 60 * 24));
	document.getElementById('showDays').innerHTML='本站已运行' + total + '天';
</script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
