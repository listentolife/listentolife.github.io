<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Listentolife&apos;s Blog">
<meta name="keywords" content="HTML CSS JavaScript">
<meta property="og:type" content="website">
<meta property="og:title" content="Listentolife">
<meta property="og:url" content="http://listentolife.github.io/page/4/index.html">
<meta property="og:site_name" content="Listentolife">
<meta property="og:description" content="Listentolife&apos;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Listentolife">
<meta name="twitter:description" content="Listentolife&apos;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://listentolife.github.io/page/4/"/>





  <title>Listentolife</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Listentolife</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">简单就好</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archive" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/12/19/Vuejs-Note-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/Vuejs-Note-I/" itemprop="url">Vue.js散记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T08:15:35+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里主要记录一下学习Vue过程中遇到的问题。</p>
<h4 id="1-Vue-warn-Error-in-render-“TypeError-Cannot-read-property-‘xxx’-of-undefined"><a href="#1-Vue-warn-Error-in-render-“TypeError-Cannot-read-property-‘xxx’-of-undefined" class="headerlink" title="1. [Vue warn]: Error in render: “TypeError: Cannot read property ‘xxx’ of undefined"></a>1. [Vue warn]: Error in render: “TypeError: Cannot read property ‘xxx’ of undefined</h4><p>之前敲代码的时候，发现了这个报错，一开始的观察点在TypeError上，认为是某个props没有正确定义，但是检查的时候并没有写错。后面发现应该要看前面Error in render，是渲染时报错。最后是找到有个地方变量名写错了。</p>
<h4 id="2-为什么data必须是一个函数"><a href="#2-为什么data必须是一个函数" class="headerlink" title="2. 为什么data必须是一个函数"></a>2. 为什么data必须是一个函数</h4><p>这个问题其实在vue.js官网有说明，并且给出了一个例子。正确的写法应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">  	count: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是因为，在创建组件的实例时，data作为一个函数可以返回一个初始化对象，能独立于其他实例的data对象。如果data不是作为一个函数，而只是一个数据，则会导致所有实例公用一个data对象。</p>
<h4 id="3-计算属性computed，侦听属性wtach-amp-方法methods"><a href="#3-计算属性computed，侦听属性wtach-amp-方法methods" class="headerlink" title="3. 计算属性computed，侦听属性wtach&amp;方法methods"></a>3. 计算属性<code>computed</code>，侦听属性<code>wtach</code>&amp;方法<code>methods</code></h4><p>计算属性<code>computed</code>的设计，是用于处理一些复杂的运算。一般在template模板中是支持使用表达式的，但是如果需要进行一些复杂的运算或数据处理，就可以把这些运算或数据处理放到计算属性中处理。</p>
<p>当然，这些复杂的运算或数据处理也可以定义为一个方法放到<code>methods</code>中，但是放在计算属性和放到方法中是有其不同的地方的。</p>
<p>vue官网有明确的指出这两者的不同。计算属性<code>computed</code>是基于它们的依赖进行缓存的。也就是说，<code>methods</code>中所有的运算结果只有当依赖的变量发生改变的时候才会重新计算，否则只要变量不改变，计算属性不会重新执行函数，直接返回缓存的计算结果。相反的，方法<code>methods</code>是并非响应式的，每次触发重新渲染时，调用的方法总会在此执行函数，即使依赖并没有发生变化。</p>
<p>计算属性<code>computed</code>的优势在于可以减少很多不必要的性能开销。而方法<code>methods</code>中的函数都是需要根据页面的渲染或不需要缓存函数结果的</p>
<p>侦听属性<code>watch</code>跟计算属性<code>computed</code>也有极为相似的方面，侦听属性是需要监听数据的变化并作出响应。但是一般用于执行异步或开销较大的操作时，才比较适合。</p>
<h4 id="4-指令v-for-amp-key"><a href="#4-指令v-for-amp-key" class="headerlink" title="4. 指令v-for &amp; key"></a>4. 指令<code>v-for</code> &amp; <code>key</code></h4><p><code>v-for</code>是vue.js用于渲染列表的指令，针对数组可以使用<code>(item, index) in items</code>的语法迭代数组，针对对象可以使用<code>(item, key, index) in items</code>的语法迭代对象。其中，<code>key</code>的用途主要在于优化渲染过程。vue.js在处理数据项的变化时，对只改变顺序的数据项会选择复用，这样能优化渲染性能。如果没有提供<code>key</code>也只是会报提示，不影响项目运行，但是建议提供（如果是在组件上使用，则必须提供<code>key</code>）。</p>
<h4 id="5-父子组件通信"><a href="#5-父子组件通信" class="headerlink" title="5. 父子组件通信"></a>5. 父子组件通信</h4><p>vue.js的父子组件通信跟react类似，父组件向子组件传值，是通过props传入，子组件是通过<code>$emit</code>方法触发父组件的事件。父组件在使用子组件时，通过v-bind指令传入或通过v-for传入数组中的一个元素，子组件需要在props中声明这些接收的值。</p>
<p>父组件通过props向子组件传值这点来看，vue.js的操作跟react是类似的，但是子组件向父组件通信的处理，就有点不同了。</p>
<p>vue.js中，父组件中需要在子组件上用<code>v-on</code>指令监听事件，然后子组件上通过<code>$emit(event, arg)</code>来向父组件触发事件，必要时传入参数<code>arg</code>。react处理上不同，react中父组件需要通过props向子组件传入方法，子组件只要使用这个方法并传入参数即可，并不是通过事件触发。</p>
<h4 id="6-通过插槽分发内容"><a href="#6-通过插槽分发内容" class="headerlink" title="6. 通过插槽分发内容"></a>6. 通过插槽分发内容</h4><p>另外开一篇文章来记录这个内容，因为插槽的分类比较多，能用起来的话作用也很强大。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/12/19/Algorithm-Analysis-Note-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/Algorithm-Analysis-Note-I/" itemprop="url">算法分析笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T08:05:36+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Algorithm-Analysis/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm Analysis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一段时间有看一些关于算法的文章，主要是因为在leetcode跟warcode都有做过一些题目了。算法以前学过一些皮毛，但是还是会觉得不够，有些算法还是需要找很多资料花一些时间才能想明白。这里整理一些关于算法分析的笔记。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="什么是复杂度分析"><a href="#什么是复杂度分析" class="headerlink" title="什么是复杂度分析"></a>什么是复杂度分析</h3><p>数据结构和算法解决的是“如何让计算机更短时间，更省空间的解决问题”，因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。</p>
<p>我们可以分别用时间复杂度和空间复杂度两个概念来描述算法的性能问题，这两个概念也统称为算法的复杂度分析。因此，算法的复杂度描述的是算法执行的时间或占用的空间与数据规模的增长关系。</p>
<h3 id="为什么要做复杂度分析"><a href="#为什么要做复杂度分析" class="headerlink" title="为什么要做复杂度分析"></a>为什么要做复杂度分析</h3><p>其一，和性能测试相比，复杂度分析有不依赖执行环境，成本低，效率高，已操作，指导性强的特点。</p>
<p>其二，掌握复杂度分析，将有助于我们编写出性能更优的代码，有利于降低系统开发和维护成本。</p>
<h3 id="如何计算复杂度"><a href="#如何计算复杂度" class="headerlink" title="如何计算复杂度"></a>如何计算复杂度</h3><h4 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h4><p>算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示其中T(n)表示内行代码执行的总次数，而n表示数据的规模。</p>
<p>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶，低阶以及系数实际上对这种增长趋势不产生决定性的影响，所以在做时间复杂度分析时可以忽略这些项。</p>
<h4 id="复杂度分析技巧："><a href="#复杂度分析技巧：" class="headerlink" title="复杂度分析技巧："></a>复杂度分析技巧：</h4><p>单独一段代码，只需要找到最高频运行的代码分析，比如循环代码。</p>
<p>多段代码的分析，则取所有代码中最高频运行的代码分析，比如一段代码中同时有单循环和多重循环的，只需要分析多重循环的代码复杂度；即：<em>如果T1(n) = O(f(n))， T2(n) = O(g(n))，则T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))</em>。</p>
<p>嵌套代码的分析，可以先把嵌套拆分分析复杂度，再相乘。即：<em>如果T1(n) = O(f(n))， T2(n) = O(g(n))，则T(n) = T1(n) x T2(n) = O(f(n) x g(n)) = O(f(n)) x O(g(n))</em>。</p>
<p>多参数多段代码的分析，需要分别分析每个参数参与代码的复杂度，然后再相加。即：<em>如果T1(n) = O(f(n))， T2(m) = O(g(m))，则T(n, m) = T1(n) + T2(m) = O(f(n)) + O(g(m))</em>。</p>
<h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p>以下是一些常见的时间复杂度量级：</p>
<ol>
<li><p>常量阶O(1)：常量阶一般指代码的时间复杂度不随n的增大而增长。</p>
</li>
<li><p>对数阶O(logn)，O(nlogn)：简单的例子：用while循环计算一个2的n次方，n是参数，其时间复杂度为O(logn)。</p>
</li>
<li><p>线性阶O(n)：线性阶指代码的时间复杂度跟n成比例。</p>
</li>
<li><p>平方阶O(n^2)，立方阶O(n^3)：平方阶跟立方阶都是随n的增大而呈现高倍增长。</p>
</li>
<li><p>非多项式阶-指数阶O(2^n)，阶乘阶O(n!)：非多项式阶的时间复杂度会随着数据的规模增长而大幅度增长，所以这类算法的性能都很差。</p>
</li>
</ol>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>一般来说，提及复杂度分析主要指的是事件复杂度分析。但是实际还有空间复杂度分析。空间复杂度全程为渐进空间复杂度，表示算法的储存空间与数据规模之间的增长关系。同样是使用大O表示法，但是分析的是存储空间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/12/19/React-Learning-React-Redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/React-Learning-React-Redux/" itemprop="url">react学习总结系列-redux&react-redux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T07:57:58+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇将介绍redux跟react-redux。这里打算是介绍这两个插件在react项目中的运用。redux是可以在其他库中使用的。</p>
<p>前面使用react开发项目，是可以实现大部分需求的。但是react毕竟是一个实现视图层的框架，它在数据层的实现还是存在一些不足的。比如当项目较大，需要使用大量的数据，父子组件之间的数据通信特别频繁的时候，性能就会直线下滑；当数据发生改变的时候，就无从得知数据是从哪里发生改变的。</p>
<p>redux作为一个应用数据流框架，它的最大的特点就是应用状态的管理，它用一个单独的常量状态树<code>store</code>保存整个应用的状态。这个状态树不能直接被改变。</p>
<p>我们分析一下。如果没有redux，react组件的所有状态<code>state</code>将各自存储于组件中，一旦遇到不同父组件的组件之间的通信问题，需要把数据先传到能使两个组件通信的上层组件，然后在下发到另一个组件。而如果使用redux，则数据都存储在常量状态树<code>store</code>中，所有组件获取状态数据都从<code>store</code>中直接获取。而组件需要修改状态数据时，只需要直接修改<code>store</code>中的数据，其他组件就会获知<code>store</code>的变化并自动重新获取状态。这样可以减少组件之间大规模的通讯消耗。</p>
<h3 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h3><p>我们了解了react的组件<code>components</code>跟redux的常量状态树<code>store</code>，那他们是怎么串连起来，是怎么样的工作流程呢？</p>
<p>这里需要考虑三个场景，一个是<code>components</code>需要修改<code>store</code>中的数据，一个是<code>store</code>中实现数据的更新，还有一个就是<code>store</code>的数据更新之后新状态同步到<code>components</code>中。</p>
<p>最主要是前两个场景。这里需要引入redux中两个概念。</p>
<h4 id="actionCreator"><a href="#actionCreator" class="headerlink" title="actionCreator"></a>actionCreator</h4><p>因为常量状态树<code>store</code>的状态数据不允许直接修改，所以当<code>components</code>需要修改<code>store</code>中的数据时，需要通过<code>actionCreator</code>中的action去让<code>store</code>做数据的更新。</p>
<p><code>actionCreator</code>是一个action的集合，这个集合中包含了各种用于申请修改的<code>action</code>。这个<code>action</code>需要包括修改数据的类型跟需要修改的数据。在<code>components</code>发出<code>store.dispatch(action)</code>之后提交给<code>store</code>，完成修改申请。</p>
<h4 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h4><p>当<code>store</code>得到action时，它本身没有什么方法可以修改数据，所以需要用到<code>reducer</code>来实现状态的更新。<code>store</code>会把当前的<code>state</code>跟前面接收到的action传给<code>reducer</code>，<code>reducer</code>会根据传入的action类型进行状态更新，然后再返回新的<code>state</code>。</p>
<h4 id="组件的状态更新"><a href="#组件的状态更新" class="headerlink" title="组件的状态更新"></a>组件的状态更新</h4><p>关于最后<code>store</code>的数据更新之后新状态同步到<code>components</code>中，阮一峰的《Redux 入门教程（一）：基本用法》中有提到，当<code>store</code>中<code>state</code>发生变化后，<code>store</code>会调用监听函数，监听函数就可以更新组件中的<code>state</code>，组件就可以重新渲染页面。</p>
<h3 id="react-redux实战"><a href="#react-redux实战" class="headerlink" title="react-redux实战"></a>react-redux实战</h3><h4 id="安装react-redux"><a href="#安装react-redux" class="headerlink" title="安装react-redux"></a>安装react-redux</h4><p>在react项目中，引入react-redux还需要引入redux：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install redux --save</span><br><span class="line">npm install react-redux --save</span><br></pre></td></tr></table></figure>
<p>这样在react项目中才可以使用react-redux。</p>
<h4 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建<code>store</code></h4><p>先在项目中创建一个store的文件夹，然后在创建一个index.js的js文件。在这个js文件中写下以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure>
<p>首先，先从redux中引入<code>createStore</code>，然后通过<code>createStore</code>来创建一个<code>store</code>，最后导出。</p>
<h4 id="创建reducer"><a href="#创建reducer" class="headerlink" title="创建reducer"></a>创建<code>reducer</code></h4><p>上面我们已经完成<code>store</code>的创建，然后需要创建<code>reducer</code>来给<code>store</code>处理数据。在store目录下创建一个reducer.js的js文件。redux中，<code>reducer</code>其实是一个函数，所需要引入的参数为当前的<code>state(preState)</code>跟<code>action</code>，而返回的是一个修改后的<code>state(newState)</code>。一般初始化的时候，没有当前的<code>state(preState)</code>，所以会先声明一个<code>defaultState</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const defaultState = &#123;</span><br><span class="line">  /*</span><br><span class="line">   *这里初始化数据</span><br><span class="line">   */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default (state = defaultState, action) =&gt; &#123;</span><br><span class="line">	switch (action.type) &#123;</span><br><span class="line">		/*</span><br><span class="line">		 * 这里判断action.type，然后修改获得newState</span><br><span class="line">		 */</span><br><span class="line">	&#125;</span><br><span class="line">    return newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，先声明一个<code>defaultState</code>作为<code>state</code>的初始化状态，然后导出一个函数，这个函数中通过判断<code>action.type</code>来修改获得<code>newState</code>，然后返回出去。</p>
<p>创建之后，需要把<code>reducer</code>传入到<code>store</code>中，因此上面的index.js需要稍加修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &apos;redux&apos;;</span><br><span class="line">import reducer from &apos;./reducer&apos;;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">export default store;</span><br></pre></td></tr></table></figure>
<h4 id="创建actionCreator"><a href="#创建actionCreator" class="headerlink" title="创建actionCreator"></a>创建<code>actionCreator</code></h4><p><code>actionCreator</code>还是要强调，它是一个方法的是一个action的集合，这个集合中包含了各种用于申请修改的<code>action</code>。当然，把所有action都只在需要的时候再编写也可以，但是把所有action集中起来可以提高代码的可读性，可维护性。每一个action方法最终都是返回一个对象，这个对象包含有修改类型type跟需要修改的值。在reducer.js中，大家可以看到传入的action.type是会在switch语句中作为判断值，然后修改值则会在判断后做对应的修改。</p>
<p>在store目录下创建一个actionCreator.js的js文件，然后写入所有需要导出的action方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export const action1 = (value1) =&gt; (&#123;</span><br><span class="line">  type: actionType1,</span><br><span class="line">  value1: value1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const action2 = (value2) =&gt; (&#123;</span><br><span class="line">  type: actionType2,</span><br><span class="line">  value2: value2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在reducer中，action.type作为判断时，会再写一次。为了保证不出抄写错误，方便后期排查bug，一般还可以把actionType集中起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export const actionType1 = &apos;action_type_1&apos;;</span><br><span class="line">export const actionType2 = &apos;action_type_2&apos;;</span><br></pre></td></tr></table></figure>
<p>那么，在actionCreator中就可以改写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import * as constants from &apos;./actionType&apos;;</span><br><span class="line"></span><br><span class="line">export const action1 = (value1) =&gt; (&#123;</span><br><span class="line">  type: constants.actionType1,</span><br><span class="line">  value1: value1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export const action2 = (value2) =&gt; (&#123;</span><br><span class="line">  type: constants.actionType2,</span><br><span class="line">  value2: value2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="组件中的使用"><a href="#组件中的使用" class="headerlink" title="组件中的使用"></a>组件中的使用</h4><p>组件中使用一般分引入store，调用action申请及store修改订阅。</p>
<p>组件中会现在构造函数中引入store：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor (props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = store.getState(); // 引入store，把store中的状态赋给state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当状态需要修改时，通过<code>store.dispatch()</code>调用action：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(actionCreators.action1(value1));</span><br></pre></td></tr></table></figure>
<p>action方法返回对象将交给store，但是store不会处理，而是通过dispatch方法交给reducer处理。reducer接收到action后，会根据修改类型type对数据进行更新。在store的状态进行更新之后组件就需要更新。但是组件的状态更新还需要做一步操作，就是对store变化的订阅。这个订阅也是在<code>constructor()</code>完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = store.getState(); // 引入store，把store中的状态赋给state</span><br><span class="line">  store.subscribe(this.handleStoreChange); // 订阅store的状态修改，如果检测到修改，则调用this.handleStoreChange监听函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是对redux跟react-redux使用的总结。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/12/19/React-Learning-Styled-Components/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/React-Learning-Styled-Components/" itemprop="url">react学习总结系列-styled-components</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T07:54:08+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一篇主要整理关于React的CSS插件styled-components。这个插件是我一开始学习React跟做项目的时候推荐并使用的。用了之后觉得这个插件确实很适合React的项目，有无缝对接的效果。</p>
<p>这里也是留一下styled-components官网文档地址：</p>
<p><a href="https://www.styled-components.com/docs" target="_blank" rel="noopener">https://www.styled-components.com/docs</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>简单说一下安装。</p>
<p>代码1 NPM&amp;CDN安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* NPM install */</span><br><span class="line">npm  install --save styled-components</span><br><span class="line"></span><br><span class="line">/* CDM install */</span><br><span class="line">; &lt;script src=&quot; https://unpkg.com/styled-components/dist/styled-components.min.js&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>styled-components使用也比较简单。最简单的写法就是声明styled变量，然后把css样式以模板字符串形式写入，最后把这个变量以React组件的形式写到<code>render()</code>中就可以了。</p>
<p>代码2 styled-components简单例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: palevioletred;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Wrapper = styled.section`</span><br><span class="line">  padding: 4em;</span><br><span class="line">  background: papayawhip;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Wrapper&gt;</span><br><span class="line">    &lt;Title&gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">  &lt;/Wrapper&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>上面是官网用例。可以看到，其实是把css样式表嵌入到JavaScript中，然后通过styled-components转成组件，然后再在其他组件中使用。所以使用起来非常简单。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>因为style-components把css样式表转成一个个的组件，所以也可以实现一些样式的传参。</p>
<p>代码2 传递参数，对代码1的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: \function(e)&#123;return e.inputColor||&quot;palevioletred&quot;&#125;;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Title inputColor=&quot;rebeccapurple&quot; &gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>代码2中，在变量<code>Input</code>的样式表中，color后面是跟着一个<code>\</code>，接着一个匿名函数。这个匿名函数有一个传参<code>e</code>，函数中会返回<code>e.inputColor</code>或默认值<code>&quot;palevioletred&quot;</code>。在<code>render()</code>函数中，第二个<code>Input</code>组件标签中声明了一个inputColor的属性值，而第一个没有。在最终的显示上，第一个组件字体样式是紫罗兰红(palevioletred)，第二个组件字体样式是丽贝卡紫(rebeccapurple)。也就是说，变量<code>Input</code>的样式表中的匿名函数，传入的参数<code>e</code>应该指向当前组件对象</p>
<p>传递参数的类型还可以是真假值。组件的属性上，可以直接声明一个属性并不传值，匿名函数中可将直接判断是否存在这个属性，以确定返回的样式值。</p>
<p>代码3 传递属性，对代码1的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: $&#123;props =&gt; props.primary ? &quot;palevioletred&quot; : &quot;white&quot;&#125;;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Title primary &gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="组件继承"><a href="#组件继承" class="headerlink" title="组件继承"></a>组件继承</h3><p>一个项目中或多或少会出现一些组件上设计样式的类似，比如不同级标题可能HTML样式，尺寸是一样的，但是颜色会不同。如果都是写成独立的组件样式表，则会出现代码冗余，不好维护。这种情况下就可以考虑使用组件继承。</p>
<p>代码4 组件继承，对代码1的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: palevioletred;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const SecondTitle = styled(Title)`</span><br><span class="line">	font-size: 1em;</span><br><span class="line">	font-weight: bold;</span><br><span class="line">` </span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Title&gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">	&lt;SecondTitle&gt;</span><br><span class="line">	  This is the second title!</span><br><span class="line">	&lt;/SecondTitle&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>如果<code>Title</code>中没有样式的话，那它就是直接继承<code>react.component</code>的组件，仍然可以被继承。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>styled-components对动画也有很好的支持。内置了<code>keyframes</code>来实现CSS3中的<code>@keyframes</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const rotate360 = keyframes`</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: rotate(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: rotate(360deg);</span><br><span class="line">  &#125;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Rotate = styled.div`</span><br><span class="line">  display: inline-block;</span><br><span class="line">  animation: $&#123;rotate360&#125; 2s linear infinite;</span><br><span class="line">  padding: 2rem 1rem;</span><br><span class="line">  font-size: 1.2rem;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Rotate&gt;&amp;lt; 💅 &amp;gt;&lt;/Rotate&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>除了上面介绍的方面之外，styled-component插件还有一些更复杂的用法，但是目前大部分的样式实现只要上面这些内容掌握了，在项目中也能解决大部分的问题了。剩下的以后有涉及到会再介绍。</p>
<p>下一篇将会介绍redux及react-redux插件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/11/24/React-Learning-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/24/React-Learning-II/" itemprop="url">react学习总结系列-react(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-24T21:29:27+08:00">
                2018-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇主要写的是React中父子组件数据传递跟生命周期。</p>
<h3 id="父子组件数据传递"><a href="#父子组件数据传递" class="headerlink" title="父子组件数据传递"></a>父子组件数据传递</h3><p>上一篇其实有说到，组件跟组件之前其实是相对独立的。虽然每个组件的数据是可以独立处理，但是组件与组件之间的数据还是存在联系的，而所有的组件之间的数据关系，都是可以归结为父组件跟子组件之间的数据传递关系。再拆分这种数据传递关系，就是要解决<strong>父组件数据传给子组件</strong>，<strong>子组件数据传给父组件</strong>两个问题。</p>
<ol>
<li><strong>父组件传入参数</strong>。在React中，父组件给子组件传递数据其实挺简单的，就是在子组件标签中通过变量进行传入，子组件通过props获取传入的数据：</li>
</ol>
<p>代码1 父组件传参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* 自己写豆瓣的一段代码，</span><br><span class="line">  * 图书页面Book组件中把页面类型参数Contants.Book传入</span><br><span class="line">  * 搜索Search组件</span><br><span class="line">  * /</span><br><span class="line">class Book extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;Search</span><br><span class="line">          page=&#123;this.state.book&#125;</span><br><span class="line">          searchInfo=&#123;this.getSearchInfo&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 搜索Search组件通过props.page接收父组件的参数，</span><br><span class="line">  * 判断input标签的属性placeholder的值</span><br><span class="line">  * 项目中还使用了styled-components插件，后面会另有介绍</span><br><span class="line">  * /</span><br><span class="line">class Search extends Component &#123;</span><br><span class="line">  // 根据父组件传入的props.page确定input标签的属性placeholder的值</span><br><span class="line">  showPlaceHolder () &#123;</span><br><span class="line">    const &#123; placeHolders, page &#125; = this.props</span><br><span class="line">    const placeHoldersJS = placeHolders.toJS()</span><br><span class="line">    return placeHoldersJS[page]</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;SearchWrapper&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;SearchInput</span><br><span class="line">            value=&#123;this.props.keyword&#125;</span><br><span class="line">            placeholder=&#123;this.showPlaceHolder()&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/SearchWrapper&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码有所省略，但基本上是对父子组件之前传递数据有基本的实现。注意，父组件的数据需要在子组件标签内用一个变量传入，这个变量将会放在子组件的props属性中。子组件调用这个变量时需要到props中调用。</p>
<ol start="2">
<li><strong>子组件传出参数</strong>。一般来说，React的数据流是单向流动，即父组件的数据可以流入子组件，但是子组件的数据是不能向父组件传递或修改父组件的数据。但是子组件是可以通过自己的事件处理函数，手动触发父组件传递进来的回调函数，在回调函数上把数据通过参数传递进去。这样就可以让子组件当数据有变化的时候，父组件也可以根据变化进行响应处理：</li>
</ol>
<p>代码2 子组件调用父组件回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 父组件Book组件向子组件Search先传入getSearchInfo()方法</span><br><span class="line">class Book extends Component &#123;</span><br><span class="line">  constructor (props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.getSearchInfo = this.getSearchInfo.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getSearchInfo (newKeyword) &#123;</span><br><span class="line">    /* 省略代码 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    const &#123; pullDownStatus, pullUpStatus &#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;Search</span><br><span class="line">          searchInfo=&#123;this.getSearchInfo&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子组件在handleClick()方法中调用父组件传入的回调函数searchInfo(keyword)，并把值传入</span><br><span class="line">class Search extends Component &#123;</span><br><span class="line">  constructor (props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.handleClick = this.handleClick.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    const &#123; searchInfo, keyword&#125; = this.props</span><br><span class="line">    if (keyword !== &apos;&apos;) &#123;</span><br><span class="line">      searchInfo(keyword)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;SearchWrapper&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;SearchInput /&gt;</span><br><span class="line">          &lt;SearchButton</span><br><span class="line">            onClick=&#123;this.handleClick&#125;</span><br><span class="line">          &gt;搜索&lt;/SearchButton&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/SearchWrapper&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有个地方需要注意的。父组件方法<code>getSearchInfo()</code>虽然是对象中的方法，但是它也有自己的作用域，所以正常来说它的this指向它自己的作用域，this.props就不存在了。所以需要在<code>constructor()</code>中指定它的作用域为整个类，需要补上<code>this.getSearchInfo = this.getSearchInfo.bind(this)</code>。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>我们来回头说一下组件的生命周期。组件的生命周期包括了初始化，第一次加载渲染，更新渲染跟卸载四个阶段。而React的生命周期函数主要分布在后面三个阶段。我们先每个阶段简单整理一下：</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>这个阶段主要还是调用了ES6中类的<code>constructor()</code>。通过构造器完成对父类的继承，变量的初始化和函数指定作用域。这个阶段还没有调用生命周期函数。</p>
<h4 id="第一次加载渲染"><a href="#第一次加载渲染" class="headerlink" title="第一次加载渲染"></a>第一次加载渲染</h4><p>第一次加载渲染的过程会调用三个生命周期函数：</p>
<p>1.<code>componentWillMount()</code>，这个函数将会在组件第一次加载渲染之前被调用。可以做一些组件渲染到页面前的操作。只调用一次。</p>
<p>2.<code>render()</code>，这个函数就是负责创建虚拟DOM，此时所有数据都至少已经初始化了。</p>
<p>3.<code>componentDidMount()</code>，这个函数是在组件第一次加载渲染完成之后马上被调用的，也只调用一次。这个函数可以调用ajax请求，返回的数据会在后面阶段更新组件状态，并触发重新渲染</p>
<h4 id="更新渲染"><a href="#更新渲染" class="headerlink" title="更新渲染"></a>更新渲染</h4><p>第一次加载渲染完成之后到组件被卸载之前，组件中的state状态跟props数据还是可以改变。所以会调用下面几个生命周期函数：</p>
<p>1.<code>componentWillReceiveProps(nextProps)</code>，在组件第一次加载渲染之后，如果props数据将要发生改变，那改变之前会先调用这个函数。函数的传参为props改变之后的值。</p>
<p>2.<code>shouldComponentUpdate(nextProps,nextState)</code>，在组件props或state将发生改变，进行更新渲染之前会调用这个函数。函数的传参为props或者state改变之后的值。函数最后返回值一定是布尔值，表示是否重新渲染组件(true为重新渲染，false为阻止渲染)。这里可以判断props或state的值是否达到需要重新渲染组件的要求。这个函数的判断有助于提高页面性能，因为当父组件重新渲染时也会导致其所有子组件重新渲染，所以在组件中做这个判断可以阻止不必要的重新渲染。</p>
<p>3.<code>componentWillUpdate (nextProps,nextState)</code>，在组件调用<code>shouldComponentUpdate(nextProps,nextState)</code>并返回<code>true</code>之后，进行更新渲染之前会调用这个函数。这里同样可以拿到<code>nextProps</code>跟<code>nextState</code>进行操作。</p>
<p>4.<code>render()</code>，这里的渲染就是根据新更新的<code>props</code>跟<code>state</code>的值进行重新创建虚拟DOM，然后在根据diff算法比对新旧DOM数，找到有差异的最小DOM节点，并重新渲染。</p>
<p>5.<code>componentDidUpdate(prevProps,prevState)</code>，在组件重新渲染之后会调用这个函数。函数的传参为props或者state改变之前的值。</p>
<h4 id="组件卸载"><a href="#组件卸载" class="headerlink" title="组件卸载"></a>组件卸载</h4><p>当组件将不再被渲染到页面上时，组件将会被卸载。卸载前只有一个函数会被触发调用：</p>
<p><strong><code>componentWillUnmount ()</code></strong> ，这个函数因为是在组件被卸载前被调用，所以很适合以下一些操作：</p>
<p>1.清除组件内的所有定时<code>setTimeout</code>，<code>setInterval</code>；</p>
<p>2.移除组件内的所有监听事件 <code>removeEventListener</code>；</p>
<p>3.处理未完成的ajax请求。一般ajax请求之后都会修改state，导致会调用组件的<code>setState()</code>，如果组件被卸载的时候ajax请求未完成，会导致请求完成后调用报错，所以可以在组件内设置状态值控制ajax请求完成后是否执行组件内<code>setState()</code>，然后在<code>componentWillUnmount ()</code>中修改状态值。</p>
<h4 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h4><p>这里拓展一下，父子组件的生命周期被调用也是有顺序的。</p>
<p>在组件初次渲染阶段，会从父组件开始，先调用父组件的<code>constructor()</code>构造函数、<code>componentWillMount()</code>，然后接着子组件开始调用这两个函数，直到最底层子组件调用这两个函数。接着调用对底层子组件的<code>componentDidMount()</code>，再一层层往上调用父组件的这个函数，直到最顶层父组件。</p>
<p>在组件的卸载阶段，则会先从最顶层父组件开始调用<code>componentDidUnmount()</code>，直到最底层子组件。</p>
<h4 id="父子组件之间的性能优化"><a href="#父子组件之间的性能优化" class="headerlink" title="父子组件之间的性能优化"></a>父子组件之间的性能优化</h4><p>其实在React中，父组件的数据变化，是会影响子组件进行重新渲染，倒是出现不必要的性能消耗。</p>
<p>前面有说到，可以通过<code>shouldComponentUpdate(nextProps,nextState)</code>函数来判断是否需要重新渲染组件，但这样一来，每个组件都要手动判断重新渲染。每次只要出现父组件传来的数据，包括state状态的变化，都会调用这个函数，也会导致代码冗余。所以React还提供了一种处理方案。</p>
<p>React V15中就引入了<code>React.PureComponent</code>。这个<code>PureComponent</code>跟<code>Component</code>用法上是一样的，只是组件继承了<code>PureComponent</code>类后，组件会自动实现<code>props</code>跟<code>state</code>的浅比较。当组件的<code>props</code>跟<code>state</code>的类型都比较简单的时候，就可以直接使用<code>PureComponent</code>。当如果<code>props</code>跟<code>state</code>是嵌套对象或数组时，浅比较将得不到预期的结果。</p>
<p>关于 React的内容就先把这些基础的先介绍到这里，主要还是要看文档，这里的就算是一些个人整理。下一篇将会介绍style-components插件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/12/React-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/12/React-Learning/" itemprop="url">react学习总结系列-开篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-12T00:20:52+08:00">
                2018-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面写了好几篇关于Canvas射击小游戏的博文，内容还总结了挺多的。不过其实在写之前主要的时间都在学习react。react是一个很热门的mvc框架，支持的插件非常多，从小页面到大工程都是可以hold得住，所以很有必要学习react并要熟练的使用。所以连着做了两个项目。一个是找了些学习资料边学边做的，是比较简单的简书PC端网页项目，学习完后就去拿豆瓣的数据做了一个简单的豆瓣app。现在打算开始写新的系列博客，把中间学习react的内容做一下整理回顾，把掌握的东西再加强一下。</p>
<p>内容主要涉及react框架及使用过或期间学习过的框架的，有一些内容比较多，会结合代码去说，有一些学得比较浅，就先把项目中有用到的先介绍了，以后在慢慢的深入。再者就是做了两个项目了，对项目的分析跟设计也会想说一下。</p>
<p>先给后面会涉及到的内容做一个列表，然后一项项的完成。</p>
<p>列表：<br>react框架<br>styled-components插件<br>PropTypes插件<br>redux及react-redux插件<br>redux-thunk及redux-saga插件<br>redux-immutable插件<br>react-router-dom插件<br>react-transition-group插件<br>jest测试</p>
<p>列表可能会继续更新，然后下一篇将会从react框架开始。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/12/React-Learning-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/12/React-Learning-I/" itemprop="url">react学习总结系列-react(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-12T00:17:14+08:00">
                2018-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里开始总结一下React。最好了解跟学习react的方法当然是去看react的官方文档，所以这里主要写的是各个知识点需要注意的点。</p>
<h3 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h3><p>JSX语法就是在JS中直接写类似HTML标签，但实际上写的不是HTML代码，这中写法其实是<code>React.creatElement(component, props, ...children)</code>的语法糖。这种语法糖的书写相较于后者的书写更为方便易懂。</p>
<p>代码1 react文档中的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// JSX语法</span><br><span class="line">&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;/MyButton&gt;</span><br><span class="line"></span><br><span class="line">// 编译为:</span><br><span class="line">React.createElement(</span><br><span class="line">  MyButton,</span><br><span class="line">  &#123;color: &apos;blue&apos;, shadowSize: 2&#125;,</span><br><span class="line">  &apos;Click Me&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>react文档有非常详细的介绍，这里主要提一些需要留意的点：</p>
<p>1.<strong>字母大小写</strong>。标签名(组件名)都是驼峰命名法(大驼峰命名法)，后面也会说到的style-component插件也是用这样的写法。</p>
<p>2.<strong>className</strong>。因为JSX语法其实是JS封装的，所以class还是js的关键词。所以在标签中如果要使用class类的话，需要写成className而不是class。写成class也不会影响代码的运行，但是会报一个提示。其他的html标签中使用的属性在JSX中都是小驼峰命名法的写法。</p>
<p>3.<strong>标签之间的值</strong>。如果标签之间没有值，则可以直接一个标签闭合。在html中，有一些标签是单一标签，不用写/闭合也是可以的，但是在JSX中所有标签都需要用<code>/</code>来闭合，所以像input，img都需要写成<code>&lt;input /&gt;</code>、<code>&lt;img /&gt;</code>的闭合形式。如果是标签之间有值，那么支持像html一样直接把字符串写在标签之间，也可以直接写变量，如果遇到数组，可以用map函数枚举数组所有项，但是需要注意的是，标签之间不支持多个语句，最多只支持一个语句。上面用到的map也是一个语句下完成的。不支持if-else判断语句，但是支持三元判断。</p>
<p>4.<strong>获取dom</strong>。react中支持用<code>ref</code>来获取dom对象，但实际上是react封装的一个React对象。如果要获取原生dom对象，可以使用<code>innerRef</code>。(PS: 这一部分其实涉及起来可以有很多内容，不过先知道这些就好，而且一般也建议少用<code>ref</code>)</p>
<p>代码2 获取div的React对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// v16之前写法</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;(myRef) =&gt; &#123;this.myRef = myRef&#125;&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// v16的写法</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;this.myRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.标签中支持写入带html代码的字符串，但是如果直接填入这样的字符串并不会被渲染成相应的内容，因为react也有这方面的安全防御。如果一定要填入这样的字符串，则需要通过<code>dangerouslySetInnerHTML</code>这个属性来传入。`dangerouslySetInnerHTML={{__html: }}`</p>
<p>代码3 在<code>Content</code>组件中传入带HTML代码的字符串<code>this.props.content</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Content dangerouslySetInnerHTML=&#123;&#123;__html: this.props.content&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>6.<strong>JSX语法可以在函数中使用</strong>。一般指函数最后返回的值是直接放在标签中的。其实这些JSX语句在函数中还是以字符串的形式专递的，直到进入<code>render()</code>的return中才会被编译。</p>
<p>7.<strong>属性</strong>。标签中的属性都是小驼峰命名法。属性支持的值可以是各种类型的（包括Function），也可以是一个执行语句，但是一样不支持多语句，判断语句中只支持三元判断。</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是react中一个很重要的概念。首先，从一个用户来说，整个页面可以分为多个信息块，不同的信息块可以获得不同的信息，而从开发者来说，整个页面可以分为多个开发模块，每个模块都是相对独立，互不干扰，而且有些模块可能在整个网站多个页面都会出现。组件其实就是这些开发模块，它拥有属于自己的数据(信息)，根据自己的样式被渲染到页面上。</p>
<p>react中组件的写法很简单，上一篇已经提到了JSX语法，针对的就是react的组件。组件中可以直接书写字符串，非引用类型变量，执行一条语句等，也可以什么都不写，自我闭合。</p>
<p>组件中还可以嵌套子组件，但是前提是子组件必须已经定义或者引入。下面来说一些关于组件开发中的一些需要注意的点：</p>
<p>1.<strong>组件的返回值只能有一个根元素</strong>。组件的返回值如果不只有一个根元素，则编译的时候回出现报错，无法渲染到页面。一般在实现一个组件时，会在最外层用一个html标签包住内容。</p>
<p>2.<strong><code>Fragment</code>组件</strong>。有时候因为一些样式的原因，组件最外层的标签会影响页面显示的效果。这个时候可以考虑使用react提供的方案，<code>Fragment</code>。先把<code>Fragment</code>从react中引入，然后把组件最外层的标签替换成<code>&lt;Fragment&gt;</code>。在编译之后，DOM中将不会出现Fragment组件，组件内部直接渲染出来。这样既减少不必要的<code>div</code>标签，还可以保证一些样式的效果。</p>
<p>3.<strong>React DOM更新</strong>。大家都知道，React是通过虚拟DOM来提高页面性能的。React对DOM的操作其实都是对虚拟DOM的操作。当虚拟DOM的修改完成之后，React在把虚拟DOM跟DOM做比对，把需要更新的部分进行更新。注意，这里是只更新需要更新的部分，其他没变动的部分不会更新。</p>
<p>4.<strong><code>props</code>跟<code>state</code></strong> 。<code>props</code>跟<code>state</code>其实区别还挺明显的，不过这个还是用得越多也清楚这个区别。<code>props</code>可以理解为传入的参数的集合，因为这个集合内的变量都是传入进来的，所以是不可以修改的。<code>state</code>可以 理解问组件自身的属性值集合，这些属性都是会根据不同状态页面的表现而改变，所以是可以修改的，但是需要调用<code>setState()</code>进行修改，不能随意修改。所有的<code>props</code>在组件外传入，包括父组件，url等等，而<code>state</code>是需要在组件的<code>constructor()</code>中先声明后才可以赋值使用。</p>
<p>5.<strong><code>super(props);</code></strong> 。在写<code>constructor()</code>，必须要先写一个语句<code>super(props);</code>。我看网上的解释是因为我们写的组件都是继承父类<code>React.component</code>，而我们在组件中写的<code>constructor()</code>会覆盖掉父类的<code>constructor()</code>，导致你父类构造函数没执行，所以手动执行下。</p>
<p>其他的注意点想到或遇到后更新上来，现在就先写这么多。下一篇会介绍React的父子组件数据传递跟生命周期。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/07/Canvas-Game-VI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/07/Canvas-Game-VI/" itemprop="url">Canvas 射击小游戏详解系列(六)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-07T23:10:00+08:00">
                2018-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML5/" itemprop="url" rel="index">
                    <span itemprop="name">HTML5</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML5/Canvas/" itemprop="url" rel="index">
                    <span itemprop="name">Canvas</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇将介绍页面动画跟项目设计实现。先会对动画做介绍，然后再总结项目中实现动画的设计。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>这里说的页面动画指的是js动画，使用<code>requestAnimationFrame()</code>实现。</p>
<p>实现动画效果的原理是把动画拆成一帧帧的画面，当达到每秒至少24帧时，可以给人造成流畅的视觉变化效果。也就算在实现动画效果时，要经历更新画面，清除画面，绘制画面三个部分。</p>
<p>代码1 每个循环的代码逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var animate = function () &#123;</span><br><span class="line">  /* </span><br><span class="line">   * 1.更新下一帧画面，比如移动</span><br><span class="line">   * 2.清除当前页面画面</span><br><span class="line">   * 3.绘制下一帧画面</span><br><span class="line">   */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一步是更新下一帧的画面，处理完一些画面元素的数据调整跟状态调整；第二步是清除当前页面画布，腾出画布空间；第三步绘制下一帧画面，刷新画布内容。</p>
<p>完成三步循环之后，还需要通过<code>requestAnimationFrame()</code>进入下一个循环周期。</p>
<p>另外，既然有动画就需要用暂停或者结束的情况，需要做状态的判断。判断状态转变成暂停或者结束的条件一般有监听事件，碰撞检测，位置范围，超时等等。一般在第一步前判断是否需要更新，调用<code>requestAnimationFrame()</code>前判断是否需要进入下一个循环周期。</p>
<p>最终，一个完整的动画设计就明了了。</p>
<p>代码2 完整的动画代码逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var animate = function () &#123;</span><br><span class="line">  /* </span><br><span class="line">   * 判断条件，选择暂停动画或继续动画</span><br><span class="line">   * 1.更新下一帧画面，比如移动</span><br><span class="line">   * 2.清除当前页面画面</span><br><span class="line">   * 3.绘制下一帧画面</span><br><span class="line">   * 判断条件，选择调用requestAnimationFrame(animate)或结束动画</span><br><span class="line">   */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="项目设计"><a href="#项目设计" class="headerlink" title="项目设计"></a>项目设计</h3><p>项目中的动画主要是在GAME对象中。当玩家点击开始游戏后，会执行<code>play()</code>方法。这个方法会先设置游戏状态，然后重置关卡数据，创建跟初始化画布所有的元素，然后再调用<code>animate()</code>方法。</p>
<h4 id="动画设计"><a href="#动画设计" class="headerlink" title="动画设计"></a>动画设计</h4><h5 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h5><p>进入<code>animate()</code>方法后，先做判断。先判断暂停状态变量是否为真，是则直接在画布上渲染暂停的图标。但是不是真的停下动画，只是让每一帧的渲染都是一样而已。直到暂停状态变量修改成假，就可以给移动量赋值。</p>
<p>在项目中，判断前还需要对键盘对象做一次检测，确认玩家是否有出现键盘事件，再根据不同的键盘事件修改。</p>
<h5 id="更新动画"><a href="#更新动画" class="headerlink" title="更新动画"></a>更新动画</h5><p>完成判断，继续动画时，根据前面得到的移动量，传入到飞机，怪兽类的实例对象中修改坐标位置。调用碰撞测试的方法<code>collision()</code>，判断碰撞是否发生。</p>
<h5 id="清除画布"><a href="#清除画布" class="headerlink" title="清除画布"></a>清除画布</h5><p>参考上一篇，直接使用<code>context.clearRect(0, 0, canvas.width, canvas.height)</code>。</p>
<h5 id="绘制画面"><a href="#绘制画面" class="headerlink" title="绘制画面"></a>绘制画面</h5><p>完成清除之后，调用<code>drawOject()</code>方法。这个方法内部会遍历所有画布的对象，调用对象的绘制方法。</p>
<h5 id="调用requestAnimationFrame-animate"><a href="#调用requestAnimationFrame-animate" class="headerlink" title="调用requestAnimationFrame(animate)"></a>调用<code>requestAnimationFrame(animate)</code></h5><p>这里需要再加一个判断。因为在前面的更新动画中，只是判断了是否暂停，这里判断是否结束动画。前面绘制之后，可能结束的条件是怪兽已经被消灭完或怪兽已经到达底部，其他情况下继续动画，需要调用<code>requestAnimationFrame(animate)</code>。</p>
<h4 id="碰撞设计"><a href="#碰撞设计" class="headerlink" title="碰撞设计"></a>碰撞设计</h4><p>碰撞设计主要是判断两个画布元素是否有重叠，其次是碰撞之后的状态跟动画效果的处理。这里主要讨论碰撞判断。</p>
<p>碰撞的判断到底为画布元素的边界是否有交叉。比如矩形的碰撞判断，为两个矩形的左边界与右边界，上边界与下边界的交叉判断。比如圆形，则是判断两个圆形圆心的距离是否小于两个圆形的半径之和。</p>
<p>如果是考虑矩形跟圆形，则需要判断矩形四个角跟圆形的位置关系及矩形中心到圆心的距离；</p>
<p>如果是考虑矩形缺角或圆形缺弧，则需要判断矩形各个角跟圆心及弧角的位置关系及矩形中心到圆心的距离。</p>
<p>如果是跟复杂的图形，则需要增加参考移动行为。比如项目中的怪兽跟子弹。不管怪兽的形状有多复杂，子弹的移动只有向上一个移动行为，所以主要的判断可以是子弹最上方的坐标是否进入怪兽边界内。</p>
<p>越复杂的碰撞判断，越要参考除了图形之外，其他的因素，比如移动行为，形状变化等等。</p>
<p>以上就是关于项目中动画部分的总结。</p>
<h3 id="系列结语"><a href="#系列结语" class="headerlink" title="系列结语"></a>系列结语</h3><p>整个项目其实整体的重点是动画的流程，怎么实现完整的动画每一帧的代码逻辑。然后拆分成两个问题，怎么渲染游戏元素，怎么设计游戏对象。</p>
<p>这个只是前端的一部分，还需要继续学习。加油！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/05/Canvas-Game-V/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/Canvas-Game-V/" itemprop="url">Canvas 射击小游戏详解系列(五)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T00:32:48+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML5/" itemprop="url" rel="index">
                    <span itemprop="name">HTML5</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML5/Canvas/" itemprop="url" rel="index">
                    <span itemprop="name">Canvas</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇开始介绍Canvas的内容。Canvas是属于HTML5的内容。下面就来介绍一下Canvas。</p>
<h3 id="Canvas元素及画布"><a href="#Canvas元素及画布" class="headerlink" title="Canvas元素及画布"></a>Canvas元素及画布</h3><p>Canvas元素其实写法跟其他的HTML元素写法一样，比如下面的项目中的例子：</p>
<p>代码1 项目中Canvas元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;game&quot; data-status=&quot;start&quot;&gt;  </span><br><span class="line">    &lt;-- 其他代码 !-&gt;</span><br><span class="line">    &lt;canvas id=&quot;canvas&quot; width=&quot;700&quot; height=&quot;600&quot;&gt;</span><br><span class="line">        &lt;!-- 动画画板 --&gt;</span><br><span class="line">    &lt;/canvas&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;-- 其他代码 !-&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>代码1中，Canvas元素在页面上创建了一个宽700，长600的画布，这个就是Canvas实现图形的基础。</p>
<p>然后需要在JavaScript代码中写下这么两行代码：</p>
<p>代码2 获取Canvas对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var context = canvas.getContext(&apos;2d&apos;);</span><br></pre></td></tr></table></figure></p>
<p>这段代码先是获取了canvas元素，然后在调用canvas元素的getContext方法访问获取2d渲染上下文。得到的context才能进行绘画的操作。</p>
<p>下面是一些关于Canvas的绘制的介绍，因为是基础内容的介绍，所以就主要以代码形式说明。</p>
<h3 id="Canvas绘制"><a href="#Canvas绘制" class="headerlink" title="Canvas绘制"></a>Canvas绘制</h3><p>Canvas绘制分下面几种： 线跟圆弧，几何图形，文本，图片。</p>
<h4 id="绘制原理"><a href="#绘制原理" class="headerlink" title="绘制原理"></a>绘制原理</h4><p>Canvas绘制的原理是把画布坐标化，以左上角为原点，上边为x坐标正方向，左边为y坐标正方向。所有的绘制方法都是context下的方法。</p>
<h4 id="线跟圆弧"><a href="#线跟圆弧" class="headerlink" title="线跟圆弧"></a>线跟圆弧</h4><p>代码1 线跟圆弧的绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 线的绘制 */</span><br><span class="line">// 设置路径</span><br><span class="line">context.beginPath();</span><br><span class="line">// 设置路径起始点</span><br><span class="line">context.moveTo(320,470);</span><br><span class="line">// 设置路径终点</span><br><span class="line">context.lineTo(320,480);</span><br><span class="line">// 绘制路径</span><br><span class="line">context.stroke();</span><br><span class="line"></span><br><span class="line">/* 圆弧的绘制 */</span><br><span class="line">context.beginPath();</span><br><span class="line">// 圆弧的绘制使用context.arc()方法</span><br><span class="line">// context.arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line">// x,y为圆心坐标</span><br><span class="line">// redius为圆的半径</span><br><span class="line">// startAngle，endAngle分别为开始角度跟结束角度（圆的水平右侧为0°）</span><br><span class="line">// anticlockwise为顺/逆时针设置，默认值为false顺时针</span><br><span class="line">context.arc(250, 250, 300, 0, Math.PI, false);</span><br><span class="line">// 绘制路径</span><br><span class="line">context.stroke();</span><br><span class="line">// 使用fill()方法将会把圆弧两端直接闭合填充</span><br><span class="line">// context.fill();</span><br></pre></td></tr></table></figure></p>
<h4 id="几何图形"><a href="#几何图形" class="headerlink" title="几何图形"></a>几何图形</h4><p>代码2 集合多边形跟圆形的绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 矩形的绘制 */</span><br><span class="line">context.beginPath();</span><br><span class="line">context.moveTo(320, 470);</span><br><span class="line">context.lineTo(350, 470);</span><br><span class="line">context.lineTo(350, 500);</span><br><span class="line">context.lineTo(320, 500);</span><br><span class="line">// 设置闭合路径</span><br><span class="line">context.closePath();</span><br><span class="line">context.stroke();</span><br><span class="line">// 填充路径用fill()方法</span><br><span class="line">// context.fill();</span><br><span class="line">// 也可以直接使用矩形的绘制方法context.rect(x, y, width, height);</span><br><span class="line">// context.rect(320, 500, 30, 30);</span><br><span class="line"></span><br><span class="line">/* 圆形的绘制 */</span><br><span class="line">context.beginPath();</span><br><span class="line">//context.arc(250, 250, 300, 0, 2 * Math.PI, false);</span><br><span class="line">// 使用fill()方法将填充整个圆形</span><br><span class="line">// context.fill();</span><br></pre></td></tr></table></figure></p>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>代码3 文本的绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 文本的绘制 */</span><br><span class="line">// 先设置字体样式</span><br><span class="line">context.font = &apos;25px arial&apos;;</span><br><span class="line">// context.strokeText()方法将文本描边绘制</span><br><span class="line">// 三个参数分别为被绘制的字符串，坐标(x,y)</span><br><span class="line">context.strokeText(&quot;描边文本&quot;, 100, 100);</span><br><span class="line">// context.fillText()方法将文本填充绘制</span><br><span class="line">context.fillText(&quot;填充文本&quot;, 100, 100);</span><br></pre></td></tr></table></figure></p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>代码4 图片的绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 图片的绘制 */</span><br><span class="line">// 设置图片对象</span><br><span class="line">var image = new Image();</span><br><span class="line">// 设置图片地址</span><br><span class="line">image.src = &apos;plane.png&apos;;</span><br><span class="line">// 设置图片加载完成后的回调函数</span><br><span class="line">image.onload = function () &#123;</span><br><span class="line">    // 绘制图片context.drawImage(img, x, y, width, height)</span><br><span class="line">	context.drawImage(image, 50, 50, 60, 100)</span><br><span class="line">	// 裁剪图片也是用context.drawImage(image, source_x, source_y, source_width, source_height, x, y, width, heigh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="样式设置"><a href="#样式设置" class="headerlink" title="样式设置"></a>样式设置</h4><p>代码5 绘制样式设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 描边颜色设置 */</span><br><span class="line">context.fillStyle = #999;</span><br><span class="line"></span><br><span class="line">/* 填充颜色设置 */</span><br><span class="line">context.strokeStyle = #333;</span><br><span class="line"></span><br><span class="line">/* 线宽设置 */</span><br><span class="line">context.lineWidth = (Number);</span><br><span class="line"></span><br><span class="line">/* 设置字体样式 */</span><br><span class="line">context.font = &apos;25px arial&apos;;</span><br></pre></td></tr></table></figure></p>
<h4 id="Canvas擦除"><a href="#Canvas擦除" class="headerlink" title="Canvas擦除"></a>Canvas擦除</h4><p>代码6 绘制擦除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 擦除 */</span><br><span class="line">// 擦除可以使用context.clearRect(x, y, width, height)方法</span><br><span class="line">// 下面直接擦除整个画布</span><br><span class="line">context.clearRect(0, 0, canvas.width, canvas.height);</span><br></pre></td></tr></table></figure></p>
<p>下一篇将会介绍Canvas动画跟项目中的关于Canvas跟动画的设计。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/02/Canvas-Game-IV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/Canvas-Game-IV/" itemprop="url">Canvas 射击小游戏详解系列(四)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T23:32:44+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/对象设计/" itemprop="url" rel="index">
                    <span itemprop="name">对象设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>写着写着内容有点多了，不过还是觉得这些东西记下来还是很有用的。下面开始介绍项目中对象的设计。</p>
<h3 id="项目中主要对象的设计"><a href="#项目中主要对象的设计" class="headerlink" title="项目中主要对象的设计"></a>项目中主要对象的设计</h3><p>整个项目中最重要的是游戏中的三个对象元素：飞机，怪兽，子弹。</p>
<h4 id="元素分析"><a href="#元素分析" class="headerlink" title="元素分析"></a>元素分析</h4><p>飞机支持在画布的底部进行左右的连续移动，移动时依赖玩家的操作，并仅支持左右键的操作。飞机还可以进行射击，玩家点击空格键，上键或Enter键会可以让飞机射击出子弹，并且支持连续射击。</p>
<p>上面总结的飞机行为可以得到，飞机有渲染，移动，临界判断跟射击的功能。需要的参数包括渲染时的画布对象，坐标，飞机图片，飞机尺寸，移动的速度，临界判断的画布上渲染的最大最小x坐标及射击的子弹长度跟移动速度参数。</p>
<p>怪兽只是在画布上部的一个区域进行从上到下蛇形自动移动。被子弹击中会有爆炸效果并消失。</p>
<p>上面总结的怪兽行为可以得到，怪兽有渲染，移动，临界判断的功能。需要的参数包括渲染时的画布对象，坐标，怪兽图片，爆炸图片，怪兽尺寸，移动的速度，临界判断的画布上渲染的最大最小x坐标。怪兽的下移移动不在对象中实现。</p>
<p>子弹通过飞机射击射出，保持一定速度向上移动，如果碰到怪兽会消失，如果一直到达画布顶部也会自动消失。</p>
<p>上面总结的子弹行为可以得到，子弹有渲染，移动，临界判断，清除的功能。需要的参数包括渲染时的画布对象，坐标，子弹长度，移动的速度。临界判断不在对象中设置方法。</p>
<h4 id="对象设计"><a href="#对象设计" class="headerlink" title="对象设计"></a>对象设计</h4><p>通过对三个元素的分析，飞机跟怪兽有可抽象成一致的属性(<code>options</code>属性及<code>context</code>画布)跟方法<code>drawing()</code>，<code>move()</code>，<code>translate()</code>。</p>
<p><code>options</code>传入的参数为JSON对象，包括了大量的参数，如果对象所渲染到画布上的图片，图片渲染的坐标点，图片尺寸，在画布上的可渲染的最大最小x坐标，移动速度等。Plane父类跟Enemy子类的<code>options</code>传入的参数会有差异，但是做了抽象统一。</p>
<p>两个元素的移动可以统一实现，所以我让怪兽的构造函数继承飞机的构造函数。</p>
<p>Enemy类虽然继承了Plane类，但是还是有一些差异点。Plane类中还有一个创建子弹的<code>shoot()</code>方法，这个方法也有被Enemy类继承，但是当前项目中Enemy类的实例并没有使用这个类，是存在代码冗余的问题。但是也支持了项目进一步优化，Enemy类的实例可以进一步提高难度，增加项目的趣味。</p>
<p>Enemy类的方法<code>drawing()</code>做了重写，因为怪兽有一个爆炸的渲染判断，涉及判断是否存活(属性<code>isLive</code>)。</p>
<p>子弹的行为跟前两者不同，虽然也是一样的属性，但是方法基本需要重写，所以不做继承。</p>
<h3 id="键盘对象设计"><a href="#键盘对象设计" class="headerlink" title="键盘对象设计"></a>键盘对象设计</h3><p>因为飞机的移动跟射击都是支持连续，如果只是在Game对象中实现键盘事件监听，实际的移动跟射击都会有卡顿感，所以把键盘事件转换成点击状态，效果上会更加顺畅。</p>
<p>键盘对象包括了左右上键，空格键，Enter键的状态，并把<code>document.onkeydown</code>跟<code>document.onkeyup</code>都指向了自身的方法，在放在中判断键盘按键是否按下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @constructor KeyBoard</span><br><span class="line"> * @description 键盘监听对象</span><br><span class="line"> * @see The &lt;a href=&quot;#&quot;&gt;KeyBoard&lt;/a &gt;.</span><br><span class="line"> * @example </span><br><span class="line"> * this.keyBoard = new KeyBoard();</span><br><span class="line"> */</span><br><span class="line">function KeyBoard () &#123;</span><br><span class="line">  document.onkeydown = this.keydown.bind(this);</span><br><span class="line">  document.onkeyup = this.keyup.bind(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KeyBoard.prototype = &#123;</span><br><span class="line">  pressedLeft: false, // 是否点击左键</span><br><span class="line">  pressedRight: false, // 是否点击右键</span><br><span class="line">  pressedUp: false, // 是否按了上报</span><br><span class="line">  pressedSpace: false, // 是否按了上报</span><br><span class="line">  pressedEnter: false, // 是否按了上报</span><br><span class="line">  keydown: function (event) &#123;</span><br><span class="line">    // 判断哪个按键按下，修改按键状态</span><br><span class="line">  &#125;,</span><br><span class="line">  keyup: function (event) &#123;</span><br><span class="line">    // 判断哪个按键松开，修改按键状态</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除了这几个对象的设计，因为还涉及对象的继承，所以还另外齐起了一个文件common.js放处理继承父类原型对象的函数<code>inheritPrototype()</code>。具体的介绍可以会看上一篇关于继承的介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description 继承父类原型对象的函数</span><br><span class="line"> * @param &#123;Object&#125; subType 子类对象</span><br><span class="line"> * @param &#123;Object&#125; subType 父类对象</span><br><span class="line"> */</span><br><span class="line">var inheritPrototype = function (subType, superType) &#123;</span><br><span class="line">  // 把父类对象的原型对象赋值给proto</span><br><span class="line">  var protoType = Object.create(superType.prototype);</span><br><span class="line">  // proto的constructor指向子类对象，进行重置</span><br><span class="line">  protoType.constructor = subType;</span><br><span class="line">  // 把子类的原型指向原型</span><br><span class="line">  subType.prototype = protoType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于对象中设计到的Canvas的部分，下一篇将介绍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Listentolife</p>
              <p class="site-description motion-element" itemprop="description">Listentolife's Blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archive">
              
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/listentolife" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:listentolife@qq.com" target="_blank" title="E-Mail">
                      E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Listentolife</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




<span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;</span>
<span id="showDays"></span>

<script>
	var birthDay = new Date('04/23/2018');
	var now = new Date();
	var duration = now.getTime() - birthDay.getTime();
	var total= Math.floor(duration / (1000 * 60 * 60 * 24));
	document.getElementById('showDays').innerHTML='本站已运行' + total + '天';
</script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
