<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Listentolife&apos;s Blog">
<meta name="keywords" content="HTML CSS JavaScript">
<meta property="og:type" content="website">
<meta property="og:title" content="Listentolife">
<meta property="og:url" content="http://listentolife.github.io/index.html">
<meta property="og:site_name" content="Listentolife">
<meta property="og:description" content="Listentolife&apos;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Listentolife">
<meta name="twitter:description" content="Listentolife&apos;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://listentolife.github.io/"/>





  <title>Listentolife</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Listentolife</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">简单就好</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archive" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/12/06/Axios-Encapsulation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/Axios-Encapsulation/" itemprop="url">封装axios</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T22:15:03+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/Axios/" itemprop="url" rel="index">
                    <span itemprop="name">Axios</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近做项目中，我尝试对axios做封装，以简化操作逻辑。所以这篇主要整理一下在项目中封装axios。</p>
<p>axios本身有create方法，可以处理各种请求，有拦截器，有cancelToken，可以根据请求的不同做不同的处理。封装的目的，就是让请求独立，的拦截可以分类，同时需要使用cancelToken的请求可以很方便的使用，把axios封装到一个类中，把axios的功能集中起来，调用的时候只要创建一个实例就可以了。</p>
<p>因此，这里封装就声明了一个<code>Ajaxquest</code>类，引入的时候其实是引入一个<code>Ajaxquest</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Ajaxquest &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default new Ajaxquest()</span><br></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>一般我们在使用axios的时候，有一些属性是可以设置固定的，比如timeout，baseURL等等，这里我把这些属性放在constructor中来初始化化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor () &#123;</span><br><span class="line">    this.baseURL = baseUrl</span><br><span class="line">    this.withCredentials = true</span><br><span class="line">    this.timeout = 60000</span><br><span class="line">    this.cancelToken = null // 关于cancelToken后面会单独整理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>这个<code>Ajaxquest</code>类在外部使用的时候是直接使用它的实例的，所以实际是调用实例的方法来使用，而且一般我们调用axios都是设置一些配置，所以我们需要有一个<code>request</code>的方法，这个方法支持传入axios的配置，然后在方法里面处理请求跟拦截。</p>
<p>axios的请求方法比较多，比如<code>axios.create(options)</code>，<code>axios.get(options)</code>等。这里我们直接使用<code>axios.create(options)</code>，因为它的灵活性更高，可以配置methods：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">request (config) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    const service = axios.create(&#123;</span><br><span class="line">        baseURL: this.baseURL,</span><br><span class="line">        withCredentials: this.withCredentials,</span><br><span class="line">        timeout: this.timeout</span><br><span class="line">    &#125;)</span><br><span class="line">    // ...</span><br><span class="line">    return service(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>return service(config)</code>之前，我们还要处理一步拦截，因为很多时候，一些请求是需要在头部添加一些信息的，而这些信息有些是通用的，有些是个别请求要求携带的，所以可以通过<code>config</code>传进来，然后再传到拦截器中处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">request (config) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    const service = axios.create(&#123;</span><br><span class="line">        baseURL: this.baseURL,</span><br><span class="line">        withCredentials: this.withCredentials,</span><br><span class="line">        timeout: this.timeout</span><br><span class="line">    &#125;)</span><br><span class="line">    service.interceptors.request.use(config =&gt; this._interceptorsRequest(config), error =&gt; &#123;</span><br><span class="line">        console.log(&apos;service error: &apos;, error)</span><br><span class="line">        // Do something with request error</span><br><span class="line">        return Promise.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">    service.interceptors.response.use(response =&gt; this._interceptorsResponse(response), error =&gt; this._interceptorsReject(error))</span><br><span class="line">    return service(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面拦截器中的callback，除了请求发送前拦截错误的callback，其他都写成内部方法。这些callback的作用是对所有请求的共性拦截处理。</p>
<h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><p>拦截器有请求前的拦截跟请求完毕后的拦截，每个拦截都会处理两个callback，因为请求前报错的处理比较少，只是打印报错信息跟返回Promise reject，所以只简单写了callback函数，没有写成内部方法。</p>
<p>请求前的拦截一般是为了配置头部信息，不在<code>request</code>方法的<code>axios.create()</code>中处理只是为了分开处理，是可以放在一起处理的。一些请求不需要配置头部信息，直接过滤掉，然后定义一些配置头部字段的，判断请求配置中是否带有这些属性，有则配置对应的头部信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_interceptorsRequest (config) &#123;</span><br><span class="line">    //当url为/admin/Image ,/admin/File, 不设置X-token请求头,图片和文件上传接口特殊要求</span><br><span class="line">    if (/*判断哪些请求不需要配置头部信息*/) &#123;</span><br><span class="line">        return config</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    // 自定义配置头部信息的属性，判断带有这些属性，就配置</span><br><span class="line">    if (config.areaID) &#123;</span><br><span class="line">        config.headers[&apos;x-area-id&apos;] = config.areaID</span><br><span class="line">        delete config.areaID</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&apos;service config: &apos;, config)</span><br><span class="line">    return config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求完成之后，也做拦截，把请求成功跟失败后的共性处理分别独立放到一个callback中。</p>
<p>请求成功之后，一些全局性的信息就可以在拦截器中处理。比如用户的信息更新，就可以在拦截器中直接处理；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_interceptorsResponse (response) &#123;</span><br><span class="line">    console.log(&apos;response success: &apos;, response)</span><br><span class="line">    const config = response.config</span><br><span class="line">    // 处理全局信息</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>如果请求失败了，拦截就可以做一些请求失败的报错信息打印。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 这里用了vant的Toast组件</span><br><span class="line">_interceptorsReject (error) &#123;</span><br><span class="line">    console.log(&apos;response fail response: &apos;, error.response)</span><br><span class="line"></span><br><span class="line">    if (error.message === &apos;cancel a request&apos;) return Promise.reject(error)</span><br><span class="line"></span><br><span class="line">    // 打印错误信息</span><br><span class="line">    let errorMessage = &apos;服务器繁忙，请刷新页面重试！&apos;</span><br><span class="line">    if (error.response &amp;&amp; error.response.headers[&apos;x-info&apos;] !== undefined &amp;&amp; error.response.headers[&apos;x-info&apos;] !== &apos;&apos;) &#123;</span><br><span class="line">        errorMessage = decodeURIComponent(error.response.headers[&apos;x-info&apos;])</span><br><span class="line">    &#125; else if (error.message) &#123;</span><br><span class="line">        errorMessage = error.message.toLowerCase()</span><br><span class="line">        if (errorMessage.indexOf(&apos;timeout&apos;) &gt; -1) &#123;</span><br><span class="line">            errorMessage = &apos;服务器长时间未响应，请刷新页面重试！&apos;</span><br><span class="line">        &#125; else if (errorMessage.indexOf(&apos;abort&apos;) &gt; -1) &#123;</span><br><span class="line">            errorMessage = &apos;服务器连接中断 abort！&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Toast.fail(errorMessage)</span><br><span class="line"></span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cancelToken"><a href="#cancelToken" class="headerlink" title="cancelToken"></a>cancelToken</h3><p>axios提供了cancelToken来处理取消请求。这里我们也来实现cancelToken的封装。</p>
<p>因为我们导出的是实例，写请求方法的时候只是调用了<code>request()</code>方法，所以需要提供另一个方法来处理取消请求。另外，因为cancelToken的处理是需要在请求的时候先创建一个cancel token，所以就是说需要在调用<code>request()</code>方法时提出需要创建cancel token，所以在<code>request()</code>方法需要增加一个逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request (config) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    if (config.cancelToken) &#123;</span><br><span class="line">        this.cancelToken = axios.CancelToken.source()</span><br><span class="line">    &#125;</span><br><span class="line">    // 接着再处理service跟拦截器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样外部传入一个<code>cancelToken</code>的布尔值，方法内部判断是否为真，是则创建cancelToken。</p>
<p>使用的时候，当需要取消请求，就可以直接调用<code>abort()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">abort (notice = &apos;cancel a request&apos;) &#123;</span><br><span class="line">    console.log(&apos;abort&apos;)</span><br><span class="line">    if (this.cancelToken) &#123;</span><br><span class="line">        this.cancelToken.cancel(notice)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>这个封装其实只是一个结构的封装，内部的配置可以根据不同的项目，不同的请求分类去做差异化的处理。封装的功能也主要是一些常用的请求处理，有其他需求还可以在这个基础上继续封装。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/12/06/work-summary9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/work-summary9/" itemprop="url">工作总结(9) - 关于移动端底部评论框效果的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T22:11:05+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前在工作总结(六)中就整理了自己实现的移动端底部评论框的方案。这个方案整体效果可以，但是还是有些细节不够好。最近项目中再次遇到同样的需求，重新做了分析，用另一种不那么复杂的方案又实现了一次。这里就来总结一下这次实现方案。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>这次的需求跟上次的一样，只是因为考虑到可能有多个地方复用，所以打算做成一个底部评论框组件。需求是底部有一个假的评论栏，点击之后会弹出真的评论栏，并附着在底部和软键盘。</p>
<p>这个需求之前实现的思路是切换评论栏的布局，然后短时间内监听距离视窗顶部的高度来调整。这个方案能实现效果，但是在软键盘升起的时候会出现抖动现象。所以这次改变思路，直接使用绝对定位布局处理。</p>
<p>之前其实也考虑过这个思路，但是因为只考虑了评论框做绝对定位，所以那种处理的方案需要一直计算位置。这次思路的实现，是把整个页面的布局做调整：body元素直接限定高度为视窗高度，内容分块也全部使用绝对定位，内容的滚动是在内容块内处理。这样，评论框是相对于body做绝对定位，位置一定在视窗的底部。</p>
<p>这次还是用vue来实现。</p>
<h3 id="页面处理"><a href="#页面处理" class="headerlink" title="页面处理"></a>页面处理</h3><p>页面有几个需要处理的地方。因为每个页面都是一个vue组件，所以只要组件最外层限定为视窗的高度，body的高度就跟视窗高度一致，同时设置为相对定位：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后<code>.wrapper</code>内的所有子节点都要使用绝对定位。内容块如果高度超过视窗高度，一般可以使用<code>overflow:auto</code>来处理，不过在移动端的效果有个不太好的情况的滑动不流畅，这个问题可以使用下面的写法处理：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line"><span class="attribute">overflow</span>: auto;</span><br><span class="line">-webkit-<span class="attribute">overflow</span>-scrolling : touch;</span><br><span class="line"></span><br><span class="line">&amp;::-webkit-scrollbar &#123; /* WebKit的浏览器隐藏滚动条 */</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遮罩层的设计"><a href="#遮罩层的设计" class="headerlink" title="遮罩层的设计"></a>遮罩层的设计</h3><p>一般评论框弹起是需要用户避免操作其他功能，所以这里在评论组件上增加一个全屏的遮罩层。而且增加一个点击隐藏的功能。这个功能必须要点击遮罩层才能触发，所以用vue开发就是使用<a href="mailto:`@click.self" target="_blank" rel="noopener">`@click.self</a>`来设计点击事件。</p>
<h3 id="评论框的设计"><a href="#评论框的设计" class="headerlink" title="评论框的设计"></a>评论框的设计</h3><p>因为这个页面的效果先是视窗底部有一个假的评论框，点击之后这个假的评论框会隐藏，真的评论框会弹出来，所以实际上是需要做两个，但是这个假的评论框并不影响这些评论框的设计，所以只要保证它的布局时绝对定位就可以了。</p>
<p>首先，这个评论框的布局一样是绝对定位，定位在组件最外层元素的底部，也即在视窗的底部，这样当软键盘弹起的时候，整个页面被顶起，评论框依然能固定在页面的底部，贴着软键盘的顶部，而且不需要做任何计算高度的处理。</p>
<p>这里需要注意的是，评论框的绝对定位必须使用<code>bottom</code>属性来定位，而不能用<code>top</code>属性，因为使用<code>top</code>属性的情况下，因为软键盘弹起，视窗高度被压缩，会导致评论框还是按<code>top</code>属性的设置隐藏到软键盘后面，而用<code>bottom</code>属性可以使评论框一直定位在视窗的底部，所以不会被隐藏。</p>
<p>还有一个会影响效果的，是需要设计评论框的高度。因为在iOS上，当H5的input标签获得聚焦，弹出软键盘时，iOS会先把页面所有fixed定位改成绝对定位，然后判断输入框的位置，根据判断滚动页面。一方面软键盘的弹出会导致视窗高度变小，这会影响使用vh布局的样式，另一方面是滚动页面也会让从fixed定位改绝对定位的容器上移，而且高度不确定。所以最后会导致本身输入框会上移，然后视窗缩小也是顶起，最后效果就会变成输入框偏移更多，显示不全或各种难堪的页面显示。因此可以先设定一个高度，然后在输入框获得聚焦时把高度改高一些，这样在经历视窗缩小跟滚动之后，评论框的显示效果也不会差。这里就不上代码了，思路已经整理了。</p>
<p>实际开发出来的效果还是可以的。这里说的效果是安卓跟iOS13版本之前。安卓效果最好，而且其实在输入框获得聚焦的时候也不需要调整评论框高度的。但因为自iOS13出来之后，这个方案实现的效果跟实际效果又有了新的偏差：软键盘弹起后，当输入框失焦时，软键盘虽然隐藏了，但是视窗竟然没有恢复，导致页面下方原来软键盘的部分空白。这个原因目前不明，当然我只在我们公司的app上测试出来，并没有在其他地方测试过，可能跟webview有关。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/12/06/work-summary8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/work-summary8/" itemprop="url">工作总结(8)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T22:08:23+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结将整理一下如何实现html生成图片。</p>
<p>生成图片一般的思路都是将需要生成图片的dom绘制到canvas中，再调用<code>canvas.toDataURL()</code>将绘制好的canvas转成file对象，然后再上传服务器，拿到线上地址，再显示出来。</p>
<p>最麻烦的就是将dom绘制到canvas，摘自网上的说法，需要先遍历需要生成图片区域的所有元素，提取DOM数，然后获取渲染之后的每个DOM节点的内联、外链CSS属性，最后将样式转换成canvas的属性，利用offset等属性辅助摆放位置，将节点对应到canvas上。所以更多人实现的方案是使用第三方库<code>html2canvas</code>。</p>
<p><code>html2canvas</code>用法也很简单，就是一个<code>html2canvas()</code>方法，传入需要生成图片的dom跟配置，然后这个方法支持Promise，可以使用<code>html2canvas(dom).then</code>方法写入一个回调函数，拿到绘制完成的<code>canvas</code>，就可以完成接下来的处理了。</p>
<p>这里整理一下开发中遇到的需求跟处理。一般生成的图片会跟页面显示不同，因为可能会加一些内容。这样就需要在调用<code>html2canvas()</code>方法先调整需要生成图片的dom的样式，改成需要的样式效果。然后在回调函数中，等拿到<code>canvas</code>之后，再把dom的样式恢复。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用vue开发</span></span><br><span class="line"><span class="comment">// 先引入html2canvas</span></span><br><span class="line">htmlToImage () &#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise，调用的时候可以知道什么时候结束，支持异步处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 保存需要修改的样式的当前值</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 设置需要打印的样式的宽高</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 调用$nextTick确保样式已经更新</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 调用html2canvas，传入需要生成图片的dom跟配置，配置可以参考官网</span></span><br><span class="line">      html2canvas(<span class="keyword">this</span>.$refs.print, &#123;</span><br><span class="line">        allowTaint: <span class="literal">true</span>, <span class="comment">// 不允许跨域图片污染画布</span></span><br><span class="line">        useCORS: <span class="literal">true</span>,  <span class="comment">// 允许加载跨域图片</span></span><br><span class="line">        width: <span class="keyword">this</span>.$refs.print.offsetWidth, <span class="comment">// canvas宽度</span></span><br><span class="line">        height: <span class="keyword">this</span>.$refs.print.offsetHeight, <span class="comment">// canvas高度</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到的就是绘制了dom的canvas</span></span><br><span class="line">        <span class="comment">// 恢复修改前的样式</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="关于图片模糊的问题"><a href="#关于图片模糊的问题" class="headerlink" title="关于图片模糊的问题"></a>关于图片模糊的问题</h3><p>上面的操作可以拿到canvas，然后就可以转file对象，上传，拿到服务端链接，然后打开一看，图片很模糊。</p>
<p>这个问题也很常见，一方面跟设备的dpi有关，另一方面跟生成的图片太小，拉伸之后也会出现这个问题。所以解决的方案是在调用<code>html2canvas()</code>方法先把需要生成图片的dom的整体样式放大数倍，然后再生成图片，同时在调用方法时设置<code>dpi</code>跟<code>scale</code>两个配置，这样能保证图片效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">htmlToImage () &#123;</span><br><span class="line">  <span class="comment">// 返回一个Promise，调用的时候可以知道什么时候结束，支持异步处理</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// //保存需要修改的样式的当前值</span></span><br><span class="line">    <span class="keyword">let</span> height = <span class="keyword">this</span>.$refs.print.offsetHeight;</span><br><span class="line">    <span class="keyword">let</span> width = <span class="keyword">this</span>.$refs.print.offsetWidth;</span><br><span class="line">    <span class="comment">// //设置需要打印的样式的宽高</span></span><br><span class="line">    <span class="keyword">this</span>.$refs.print.style.height = height * <span class="number">2</span> + <span class="string">'px'</span>;</span><br><span class="line">    <span class="keyword">this</span>.$refs.print.style.width = width * <span class="number">2</span> + <span class="string">'px'</span>;</span><br><span class="line">    <span class="comment">// 调用$nextTick确保样式已经更新</span></span><br><span class="line">    <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 调用html2canvas，传入需要生成图片的dom跟配置，配置可以参考官网</span></span><br><span class="line">      html2canvas(<span class="keyword">this</span>.$refs.print, &#123;</span><br><span class="line">        dpi: <span class="built_in">window</span>.devicePixelRatio * <span class="number">2</span>, <span class="comment">// dpi设置 每英寸的像素</span></span><br><span class="line">        scale: <span class="number">2</span>, <span class="comment">// 放大倍数</span></span><br><span class="line">        allowTaint: <span class="literal">true</span>, <span class="comment">// 不允许跨域图片污染画布</span></span><br><span class="line">        useCORS: <span class="literal">true</span>,  <span class="comment">// 允许加载跨域图片</span></span><br><span class="line">        width: <span class="keyword">this</span>.$refs.print.offsetWidth, <span class="comment">// canvas宽度</span></span><br><span class="line">        height: <span class="keyword">this</span>.$refs.print.offsetHeight, <span class="comment">// canvas高度</span></span><br><span class="line">      &#125;).then(<span class="function"><span class="params">canvas</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到的就是绘制了dom的canvas</span></span><br><span class="line">        <span class="comment">// 恢复修改前的样式</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="关于跨域图片不显示的问题"><a href="#关于跨域图片不显示的问题" class="headerlink" title="关于跨域图片不显示的问题"></a>关于跨域图片不显示的问题</h3><p>所以又按照上面的思路改了一下，图片是终于清晰了，但是还有一个问题没解决，就是本来应该显示的图片没有出现。这个问题我搜索过之后才知道原来是图片跨域的问题。</p>
<p>一般图片跨域没什么问题，但是在canvas上，跨域图片会导致画布被污染，所以跨域图片不会被绘制到canvas上，最终生成的图片也没有正常显示该图片。</p>
<p>解决这个问题，我试过一些网上的简单的处理，都无效，所以只能把跨域图片转为本地图片，再设置<code>html2canvas()</code>的<code>useCORS</code>为<code>true</code>。</p>
<p>跨域图片转为本地图片，目前我的解决方案是让服务器返回二进制数据，然后转成Blob对象，再调用window下的<code>createObjectURL()</code>方法转成本地图片url。</p>
<h3 id="关于base64转Blob对象转file对象"><a href="#关于base64转Blob对象转file对象" class="headerlink" title="关于base64转Blob对象转file对象"></a>关于base64转Blob对象转file对象</h3><p>这个问题打算单独整理，就不再这里写了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/12/06/work-summary7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/06/work-summary7/" itemprop="url">工作总结(7)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-06T22:06:58+08:00">
                2019-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结会整理一下使用Canvas实现随机生成验证码。</p>
<p>随机生成验证码是基于canvas绘制而成的，最基本的实现是随机生成多位验证码，然后验证码的每一位码按不同的颜色，大小，倾斜角度跟位置来绘制到画布上。更上一层是增加干扰项，比如划线，非验证码范围字符，验证码扭曲，定时更新验证码等等。这里实现的验证码只是增加了干扰项跟点击更新，定时更新可以实现，但这里就不整理了。</p>
<p>这里的代码实现基于vue实现的。</p>
<h3 id="初始化工作"><a href="#初始化工作" class="headerlink" title="初始化工作"></a>初始化工作</h3><p>要实现随机验证码，有两个基本要素：canvas画布，随机生成的验证码(这里演示4位验证码)字符范围。</p>
<p>canvas绘制不难，主要是使用绘制的方法，这个后面整理。先要在页面上获得canvas画布，这一步需要在<code>mounted</code>中执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- html template --&gt;</span><br><span class="line">&lt;canvas id=&quot;verCode&quot;&gt;&lt;/canvas&gt;</span><br><span class="line"></span><br><span class="line">// js</span><br><span class="line">data () &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">mounted () &#123;</span><br><span class="line">  this.initCanvas();</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  initCanvas () &#123;</span><br><span class="line">    this.container = document.querySelector(&apos;#verCode&apos;);</span><br><span class="line">    this.width = this.container.width;</span><br><span class="line">    this.height = this.container.height;</span><br><span class="line">    this.ctx = this.container.getContext(&apos;2d&apos;);</span><br><span class="line">    this.ctx.textBaseline = &apos;bottom&apos;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面通过<code>.getContext(&#39;2d&#39;)</code>获取了画布，然后在获得画布的宽高，设置了画布的文字基线。</p>
<h3 id="生成code"><a href="#生成code" class="headerlink" title="生成code"></a>生成code</h3><p>接下来就是生成code。生成code是比较简单的，思路是从特定的字符集合中随机取出字符组成code。这里把特定的字符放到一个字符串中，然后随机生成数组下标，取出字符串。随机生成的code的长度可以从外部传进来，也可以使用默认的四位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getCode () &#123;</span><br><span class="line">    let chars = &apos;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&apos;.split(&apos;&apos;);</span><br><span class="line">    let code = [];</span><br><span class="line">    let radix = chars.length;</span><br><span class="line">    for (let i = 0; i &lt; this.num; i++) &#123;</span><br><span class="line">        code[i] = chars[0 | Math.random() * radix];</span><br><span class="line">    &#125;</span><br><span class="line">    this.code = code.join(&apos;&apos;);</span><br><span class="line">    console.log(this.code);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="画code"><a href="#画code" class="headerlink" title="画code"></a>画code</h3><p>生成code之后，就可以开始在canvas画布上画code了。这里用到的是canvas的<code>fillText()</code>方法，这个方法可以把文字绘画到canvas上。在调用<code>fillText()</code>方法之前，还可以给文字增加属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">drawCode () &#123;</span><br><span class="line">    for (let i = 0; i &lt; this.num; i++) &#123;</span><br><span class="line">        let x = (this.width - 20) / this.num * i + 15;</span><br><span class="line">        let y = this.randomNum(this.height * 0.92, this.height * 0.92);</span><br><span class="line">        let deg = this.randomNum(-45, 45);</span><br><span class="line">        let txt = this.code.charAt(i);</span><br><span class="line"></span><br><span class="line">        this.ctx.fillStyle = this.randomColor(10, 100);</span><br><span class="line">        this.ctx.font = `$&#123;this.randomNum(80, 100)&#125;px SimHei`;</span><br><span class="line">        this.ctx.translate(x, y);</span><br><span class="line">        this.ctx.rotate(deg * Math.PI / 180);</span><br><span class="line">        this.ctx.fillText(txt, 0, 0);</span><br><span class="line">        this.ctx.rotate(-deg * Math.PI / 180);</span><br><span class="line">        this.ctx.translate(-x, -y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="干扰项"><a href="#干扰项" class="headerlink" title="干扰项"></a>干扰项</h3><p>干扰项一般增加直线跟曲线就可以了，如果想要更复杂，也是可以增加符号干扰的，不过要注意控制样式，否则真的会干扰到用户的判断。</p>
<p>这里我爸直线跟曲线的绘画分成两个方法来调用了。绘制的数量我都按code的长度来控制。然后在一定范围内随机生成长度，位置坐标，颜色等。最后调用canvas绘制路线的方法绘制即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">drawLine () &#123;</span><br><span class="line">    for (let i = 0; i &lt; this.num; i++) &#123;</span><br><span class="line">        this.ctx.strokeStyle = this.randomColor(90, 180);</span><br><span class="line">        this.ctx.beginPath();</span><br><span class="line">        this.ctx.moveTo(this.randomNum(0, this.width), this.randomNum(0, this.height));</span><br><span class="line">        this.ctx.lineTo(this.randomNum(0, this.width), this.randomNum(0, this.height));</span><br><span class="line">        this.ctx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">drawArc () &#123;</span><br><span class="line">    for (let i = 0; i &lt; this.num; i++) &#123;</span><br><span class="line">        this.ctx.fillStyle = this.randomColor(0, 255);</span><br><span class="line">        this.ctx.beginPath();</span><br><span class="line">        this.ctx.arc(this.randomNum(0, this.width), this.randomNum(0, this.height), 1, 0, 2 * Math.PI);</span><br><span class="line">        this.ctx.fill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h3 id="点击刷新验证码及验证"><a href="#点击刷新验证码及验证" class="headerlink" title="点击刷新验证码及验证"></a>点击刷新验证码及验证</h3><p>点击刷新验证码实现很简单，给canvas增加一个点击监听事件，点击之后调用<code>getCode()</code>方法就可以完成刷新。</p>
<p>验证验证码的实现是先实现一个验证方法，然后在父组件使用验证码组件是使用<code>this.$refs</code>来调用验证码组件的验证方法，传入用户输入的code进行比对，然后返回一个布尔值。</p>
<p>以上就是验证码组件的实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/08/25/wechat-mini-project-listentoweather-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/wechat-mini-project-listentoweather-II/" itemprop="url">微信小程序开发-倾听天气(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T23:04:07+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/微信小程序/" itemprop="url" rel="index">
                    <span itemprop="name">微信小程序</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我的微信小程序，倾听天气终于更新了0.2.1版本了，这个版本页面效果要比第一版的好很多了，主要的原因在于我申请的和风天气开发者权限通过了，所以获得更多的数据。比如24小时内间隔2小时的天气数据，最近7天的天气数据。</p>
<p>因此我的小程序所展示的数据可以更加详细。此外，我又在iconfont.cn搜集了一些icon来优化小程序的展示，并给逐小时天气预报做了一个折线图。下面我就以这几点来整理一下小程序的开发。</p>
<h3 id="申请过程"><a href="#申请过程" class="headerlink" title="申请过程"></a>申请过程</h3><p>这里就简单说一下申请的过程：和风天气的认证个人开发者很简单。只要申请的时候实名并提供自己的作品中使用了和风天气的api即可。我是在完成了倾听天气的第一版之后申请中，中间还给他们发了一封邮件，因为申请的信息要求的作品选项没有包括微信小程序，所以我发了邮件去咨询了一下。很快就回复了我微信小程序可以申请。所以我在申请的时候直接在作品一栏写明是微信小程序倾听天气。虽然那天刚好申请后隔天是周末，但到了周日就来邮件说申请通过了，周末都处理申请，好厉害的样子…</p>
<p>之后我在我的小程序中就发现原来3天的天气预报数据变成7天了，说明api的权限已经开好了。</p>
<h3 id="开发总结"><a href="#开发总结" class="headerlink" title="开发总结"></a>开发总结</h3><p>这里整理一下在0.2.1版本中涉及到的一些开发总结。主要分微信小程序滚动组件，iconfront引入及canvas绘制折线图。</p>
<h4 id="滚动组件scroll-view"><a href="#滚动组件scroll-view" class="headerlink" title="滚动组件scroll-view"></a>滚动组件<code>scroll-view</code></h4><p>之前整个小程序中都没有用到这个组件是因为没有太多的数据需要做这样的显示。不过当原来3天的天气预报数据变成7天之后，在屏幕上横着显示7天的数据就比较拥挤了，所以这个时候就需要用到滚动组件<code>scroll-view</code>了。</p>
<p><code>scroll-view</code>用起来不难，首先需要有一个父级组件包住<code>scroll-view</code>，然后通过<code>scroll-x</code>或<code>scroll-y</code>来控制滚动的方向。最后，如果是垂直方向的滚动需要给<code>scroll-view</code>增加一个高度的样式，而如果是水平方向的话，给父级标签增加一个固定宽度就可以了。</p>
<p>我这是因为是要水平方向展示7天的天气预报数据，所以我给组件<code>scroll-view</code>一个父级组件，固定width为<code>100%</code>，然后给组件<code>scroll-view</code>一个类，这里使用flex布局，让内部的子组件都并排在一行内，并固定宽度。这样的基本完成了水平滚动的实现了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&apos;forecast-wrapper&apos; wx:if=&quot;forecast.daily_forecast&quot;&gt;</span><br><span class="line">  &lt;scroll-view scroll-x enable-flex class=&apos;scroll-view-x&apos;&gt;</span><br><span class="line">    &lt;view</span><br><span class="line">      wx:for=&quot;&#123;&#123; forecast.daily_forecast &#125;&#125;&quot;</span><br><span class="line">      wx:for-index=&quot;index&quot;</span><br><span class="line">      wx:for-item=&quot;item&quot;</span><br><span class="line">      wx:key=&quot;item.date&quot;</span><br><span class="line">      class=&apos;forecast-item&apos;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;!-- --&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">  &lt;/scroll-view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.forecast-wrapper &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.scroll-view-x &#123;</span><br><span class="line">  // display: flex;</span><br><span class="line">  width: auto;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">  // flex-wrap: nowrap 测试无效</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.forecast-item &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 20%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>scroll-view</code>组件的<code>enable-flex</code>属性相当于直接设置flex布局。还有很多属性可以设置，比如<code>scroll-into-view</code>滚动到某一子节点，<code>enable-back-to-top</code>支持垂直方向滚动的点击屏幕顶部后滚动条返回顶部，等等。具体可以去读官网文档。</p>
<h4 id="iconfont引入"><a href="#iconfont引入" class="headerlink" title="iconfont引入"></a>iconfont引入</h4><p>其实iconfont的引入本应没什么可以说的，但是鉴于微信小程序中写样式的文件叫wxss文件，我们平时写的样式文件是css，所以还是有点不一样的。</p>
<p>网上找到的解决方案一般都是先下载icon文件，然后把.ttf文件转码base64格式，然后再放到对应的wxss文件中，最后再引用。</p>
<p>但是我嫌这种方案比较复杂，而且需要下载icon文件存放在目录下也可能需要费些空间(我的项目还好，只是想找懒)。都知道微信小程序是有限项目大小的，所以有没有更好的方案。</p>
<p>有，很简单，就是通过iconfont直接生成unicode，把unicode复制放到wxss文件中，再下载icon文件，把icon的css样式在复制放到wxss文件中(我是直接放到app.wxss中，暂时先这样处理)，然后就可以快速的使用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**iconfont online**/</span><br><span class="line">@font-face &#123;</span><br><span class="line">  font-family: &apos;iconfont&apos;;  /* project id 1265794 */</span><br><span class="line">  src: url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.eot&apos;);</span><br><span class="line">  src: url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;),</span><br><span class="line">  url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.woff2&apos;) format(&apos;woff2&apos;),</span><br><span class="line">  url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.woff&apos;) format(&apos;woff&apos;),</span><br><span class="line">  url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.ttf&apos;) format(&apos;truetype&apos;),</span><br><span class="line">  url(&apos;//at.alicdn.com/t/font_1265794_rsipcjqri8.svg#iconfont&apos;) format(&apos;svg&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**iconfont.css**/</span><br><span class="line">.iconfont &#123;</span><br><span class="line">  font-family: &quot;iconfont&quot; !important;</span><br><span class="line">  font-size: 16px;</span><br><span class="line">  font-style: normal;</span><br><span class="line">  -webkit-font-smoothing: antialiased;</span><br><span class="line">  -moz-osx-font-smoothing: grayscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不需要把icon文件都放到项目中了。</p>
<p>目前项目中已经大面积的使用icon显示一些信息了，比如天气状态，生活指数，一些常用的功能icon。看起来要比原来纯文字的效果要好很多。</p>
<h4 id="canvas绘制"><a href="#canvas绘制" class="headerlink" title="canvas绘制"></a>canvas绘制</h4><p>canvas绘制应该是这一版本中最难的部分。原本想引入ECharts微信小程序版来实现24小时温度折线图的，但是因为没有用过，一下子使用有难度，再者最近看到不少canvas绘制图表的博文，所以想自己试试，所以最后选择了canvas绘制。</p>
<p>其实canvas绘制不难，它的操作逻辑就是在页面上建立一张画布，然后用坐标标识绘制的关键点，最后把方法当成指令这样使用就可以了，剩下就是想画好看点就用一些。</p>
<p>首先还是要对数据做处理。绘制一个24小时逐小时温度折线图需要确定要画布的宽跟高，这样才能确定最高温度跟最低温度的y轴值，最近时间温度跟最远时间温度的x轴值；然后找到所有温度数据中的最大值刚跟最小值，可以确定每个温度阶的间隔值，最后再计算每个时间温度对应的坐标。</p>
<p>这里我使用<code>wx.getSystemInfo</code>来获得屏幕的宽度，然后动态的计算画布的宽度跟高度(宽度为屏幕宽度，高度为宽度的1/5)。再用<code>getTmps</code>方法获得温度数据的数组跟最高最低温度值。最后用<code>getCoordinate</code>方法计算获得所有的坐标，最后在<code>drawHourly</code>方法中绘制。</p>
<p>微信小程序中canvas的绘制跟H5中有一点区别，但逻辑是一样的。首先要创建一个<code>content</code>，然后根据折线图的需要绘制线，绘制圆，绘制最大温度跟最小温度标识，最后把<code>content</code>绑定到页面上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">drawHourly(arr, maxCoo, minCoo, maxTmp, minTmp) &#123;</span><br><span class="line">  var context = wx.createContext();</span><br><span class="line">  context.draw(); // 清空</span><br><span class="line">  context.setStrokeStyle(&quot;#fff&quot;);</span><br><span class="line">  context.setLineWidth(1);</span><br><span class="line">  context.moveTo(arr[0].x, arr[0].y);</span><br><span class="line">  for (let i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    context.lineTo(arr[i].x, arr[i].y);</span><br><span class="line">  &#125;</span><br><span class="line">  context.stroke();</span><br><span class="line">    </span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    // 设置描边颜色</span><br><span class="line">    context.setStrokeStyle(&quot;#ffffff&quot;);</span><br><span class="line">    context.moveTo(arr[i].x, arr[i].y);</span><br><span class="line">    context.arc(arr[i].x, arr[i].y, 2, 0, 2 * Math.PI, false);</span><br><span class="line">    context.closePath();</span><br><span class="line">    // 填充路径</span><br><span class="line">    // context.fill();</span><br><span class="line">    context.stroke();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.setFontSize(10);</span><br><span class="line">  context.setFillStyle(&quot;#fff&quot;);</span><br><span class="line">  context.fillText(`$&#123;maxTmp&#125;℃`, maxCoo.x - 10, maxCoo.y + 5);</span><br><span class="line">  context.fillText(`$&#123;minTmp&#125;℃`, minCoo.x - 10, minCoo.y + 5);</span><br><span class="line"></span><br><span class="line">  wx.drawCanvas(&#123;</span><br><span class="line">    canvasId: &apos;hourlyCanvas&apos;,</span><br><span class="line">    actions: context.getActions()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个绘制也是比较简单，也没有做效果更好的平滑曲线，达到效果就可以了。</p>
<p>以上就是新版本倾听天气小程序开发的整理。接下来会做新的优化，具体会在下一个版本出来后再整理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/08/25/wechat-mini-project-listentoweather-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/wechat-mini-project-listentoweather-I/" itemprop="url">微信小程序开发-倾听天气(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T22:57:19+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/微信小程序/" itemprop="url" rel="index">
                    <span itemprop="name">微信小程序</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近开始尝试开发微信小程序。之前多多少少了解了微信小程序的开发，了解了wxml，wxss，wxs跟一些微信小程序的api，但是并没有什么想法应该要拿什么来练手。最近找到和风天气(<a href="https://www.heweather.com/)有向普通开发者提供开发api，看了文档也觉得文档很友好，数据也很足够，所以就想尝试开发一款天气预报的微信小程序。" target="_blank" rel="noopener">https://www.heweather.com/)有向普通开发者提供开发api，看了文档也觉得文档很友好，数据也很足够，所以就想尝试开发一款天气预报的微信小程序。</a></p>
<p>简单的说，最基本的需要是用户需要查看所在地的天气情况跟最近几天的天气预报，并获得一些建议，而和风天气开放给普通用户也有这些信息，所以这个需求可以很容易实现。目前我也是打算实现最基础的展示功能先上线，走完整个开发到上线的流程，看看有什么坑。</p>
<p>话不多说，先上小程序码，可以去看看效果：</p>
<p><img src="../images/gh_49128d023947_258.jpg" alt="倾听天气 小程序码"></p>
<h3 id="创建小程序账号"><a href="#创建小程序账号" class="headerlink" title="创建小程序账号"></a>创建小程序账号</h3><p>第一步，肯定是要到微信公众平台申请一个小程序的账号，这个账号需要一个未申请过微信账号或其他开发账号的邮箱，然后申请之后还需要一个管理员。申请之后，可以得到一个AppID，这个AppID就是你开发小程序时需要绑定的。</p>
<p>然后就下载微信开发者工具，安装。打开工具，选择小程序，然后在新建项目那里，在AppID填入你刚才注册获得的Appid。选择好目录，项目名称跟后端服务（目前我没有使用云服务，但计划之后的版本会加入），点击新建即可新建小程序项目。</p>
<h3 id="腾讯地图开发者及和风天气开发者账号"><a href="#腾讯地图开发者及和风天气开发者账号" class="headerlink" title="腾讯地图开发者及和风天气开发者账号"></a>腾讯地图开发者及和风天气开发者账号</h3><p>从需求中分析到，需要获得用户的定位信息跟天气数据，前者可以通过微信小程序内置api获取，后者可以通过和风天气api获取。不过长远考虑可以获得更多地图数据以丰富小程序的功能，所以这里一并申请了腾讯地图开发者。</p>
<p>其实申请也不难，腾讯地图api是在腾讯位置服务申请的开发者账号，只要用QQ或微信扫一下二维码就可以注册成功了，简直0操作成本。然后在控制台的key管理那里创建新密钥。通过这个密钥就可以获得腾讯地图的数据了</p>
<p>注册和风天气的开发者账号也不难，进入官网之后进行注册。开发者的权限是跟开发者账号绑定的，一般的开发者（比如我）可以直接注册普通开发者，然后创建key，就可以获得最基础的数据。如果要申请认证开发者就需要提供开发上线的应用（目前我上线小程序之后就开始申请了）。申请就还需要提供个人信息了，但是因为小程序没有链接，所以我就直接写让他们去微信里面搜索了……</p>
<p>最后，还需要在微信公众平台，小程序账号的开发一栏，进入开发设置，设置服务器域名的request合法域名。设置的是把接口的域名添加进去。注意，这个操作每个月是有显示修改次数的。</p>
<p>这样，就完成了开发前的准备了。</p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>开发的过程耗时不长，只是因为每天比较忙，所以只能腾三个晚上每天大概6个小时从各种注册到开发到上线申请。</p>
<p>遇到的坑也不算太多，简单的百度一下也可以解决，不过既然是整理开发过程，我觉得还是可以拿一些出来说说的：</p>
<h4 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h4><p>因为是第一个版本，没打算获取用户太多信息，只需要获得定位信息就可以了，所以目前只获取用户定位权限。</p>
<p>现在微信小程序的用户权限都需要做多一些配置。比如获取定位权限，就需要先在app.json配置permission：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  &quot;permission&quot;: &#123;</span><br><span class="line">    &quot;scope.userLocation&quot;: &#123;</span><br><span class="line">      &quot;desc&quot;: &quot;你的位置信息将用于获取你所在地区的天气信息&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再在js文件中调用<code>wx.getLocation()</code>方法，这里我是在index.js中onLoad中调用<code>getUserLocation()</code>，在这个方法中获取定位的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function () &#123;</span><br><span class="line">  // 获取用户经纬度</span><br><span class="line">  this.getUserLocation()</span><br><span class="line">&#125;,</span><br><span class="line">getUserLocation () &#123;</span><br><span class="line">  wx.getLocation(&#123;</span><br><span class="line">    type: &apos;gcj02&apos;,</span><br><span class="line">    success: res =&gt; &#123;</span><br><span class="line">      this.updateLocation(res);</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: err =&gt; &#123;</span><br><span class="line">      console.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="腾讯位置服务获取位置描述"><a href="#腾讯位置服务获取位置描述" class="headerlink" title="腾讯位置服务获取位置描述"></a>腾讯位置服务获取位置描述</h4><p>毕竟是腾讯的产品，腾讯位置服务也有微信小程序JS SDK，不需要使用API调用。引入的方法也不难。</p>
<p>前面已经获得了key，然后在腾讯位置服务页面下载SDK，然后放到项目目录下（我的项目是放在了util目录下）。再在js文件中引入，并声明一个实例（官网也有详细的代码介）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 引入腾讯地图SDK核心类</span><br><span class="line">let QQMapWX = require(&apos;./qqmap-wx-jssdk.min.js&apos;);</span><br><span class="line"></span><br><span class="line">// 实例化地图API核心类</span><br><span class="line">let qqmapsdk = new QQMapWX(&#123;</span><br><span class="line">  key: config.MAP_API_KEY</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就可以开始使用了。前面已经获得了用户的位置信息，这个位置信息主要可以获得位置的经纬度，然后我们就要考虑使用经纬度获取位置的描述信息了。这个可以使用腾讯位置服务SDK的逆地址解析接口<code>reverseGeocoder(options:Object)</code>。</p>
<p>这个接口可以不传入任何字段，默认为当前位置坐标。然后返回的是经纬度对应的地理描述信息，不传则返回的是当前位置的描述信息。这个就有点有趣了，也就是可能可以绕过微信小程序的用户授权，直接获取用户的地理信息。不过为了不出问题，我们还是通过用户授权获取位置信息吧。</p>
<h4 id="和风天气获取常规天气数据"><a href="#和风天气获取常规天气数据" class="headerlink" title="和风天气获取常规天气数据"></a>和风天气获取常规天气数据</h4><p>天气数据我通过和风天气的常规天气数据api获取的。前面已经获取了和风天气普通开发者的key了，这里使用<code>wx.request</code>向接口<code>https://free-api.heweather.net/s6/weather/{weather-type}?{parameters}</code>发出请求。接口的要求官网也是有说明的，这里就不多说。我是把腾讯位置服务跟和风天气的请求操作都做了封装，放在util目录的<code>api.js</code>中，这样可以减少在页面js文件中写请求内容，请求操作统一开发。这里我使用了<code>Promise.all</code>把常规天气数据请求都包起来了，方便全部请求完成之后再关闭加载弹窗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getHefengData (lat, lon) &#123;</span><br><span class="line">  wx.showLoading(&#123;</span><br><span class="line">    title: &apos;获取天气信息中&apos;,</span><br><span class="line">  &#125;)</span><br><span class="line">  Promise.all([this.getWthNow(lat, lon), this.getWthForecast(lat, lon), this.getWthHourly(lat, lon), this.getWthLifestyle(lat, lon)]).then(res =&gt; &#123;</span><br><span class="line">    wx.hideLoading();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="wxs的使用"><a href="#wxs的使用" class="headerlink" title="wxs的使用"></a>wxs的使用</h4><p>因为微信小程序不支持在wxml中做数据处理，所以wxs的出现我觉得是js到wxml的中介物。数据或者状态通过wxs的处理后才能渲染到wxml。</p>
<p>比如说这个项目中，接口获取的天气状态码需要转换成天气状态描述跟对应的图标，这个时候就需要通过wxs的处理。所以，在微信小程序中，js扮演的角色更多是获取数据，保存状态，数据通过wxs的处理变成需要渲染的内容放到wxml中。</p>
<p>使用也不难，新建一个对应的wxs，把处理逻辑放进去，通过<code>&lt;wxs src=&quot;./xxx.wxs&quot; module=&quot;xxx&quot; /&gt;</code>引入到wxml中，然后通过<code>xxx.fn</code>来使用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text class=&apos;iconfont &#123;&#123;tools.getCondIcon(now.now.cond_code)&#125;&#125;&apos;&gt;&lt;/text&gt;</span><br></pre></td></tr></table></figure>
<p>因为和风天气的天气状态比较多，所以我把天气状态对应的描述都放到<code>app.wxs</code>中，再在<code>index.wxs</code>引用。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>页面设计其实比较简陋，所以没什么好写的，而且显示的都是文字，展示效果并不那么好，所以等之后的迭代有比较好的设计再看有没有什么可以整理的吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/08/25/promise-realize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/promise-realize/" itemprop="url">手写一个Promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T22:46:35+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Promise/" itemprop="url" rel="index">
                    <span itemprop="name">Promise</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在掘金上看了一些关于promise的文章，然后学习了一番，发现是可以自己手写实现一套promise的，于是做了一番学习，现在来整理一下。</p>
<h4 id="Promise状态"><a href="#Promise状态" class="headerlink" title="Promise状态"></a>Promise状态</h4><p>promise是有一套规范的，只要实现的promise符合这套规范，就说明显示的promise是可以正常使用的。这套规范的地址是 <a href="https://promisesaplus.com/" target="_blank" rel="noopener">https://promisesaplus.com/</a> 。上面除了有规范，还给出了测试工具，方便测试代码。</p>
<p>promise的规范写的很详细，包括用语，各种情况下promise应该有的处理方式。这个就开始实现吧。</p>
<p>规范的一开始就明确定义了(1.1)promise是一个带有<code>then</code>方法的对象或者函数，所以我们实现的promise需要有一个<code>then</code>方法；(2.1)promise有三个状态，<code>pending</code>等待态，<code>fulfilled</code>成功态，<code>rejected</code>失败态，而关于这三种状态关系，在(2.1)中有详细的说明：</p>
<ol>
<li>等待态可以转化为成功态或失败态；</li>
<li>成功态不能转化为其他状态，而且需要有一个<code>value</code>；</li>
<li>失败态不能转化为其他状态，而且需要有一个<code>reason</code>；<br>(<code>value</code>跟<code>reason</code>值不可变，但如果指向是对象的话则指向不可变)</li>
</ol>
<p>基于以上规范，promise需要有一个状态<code>state</code>和对应成功态的<code>value</code>跟失败态的<code>reason</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const PENDING = &apos;PENDING&apos;;</span><br><span class="line">const FULFILLED = &apos;FULFILLED&apos;;</span><br><span class="line">const REJECTED = &apos;REJECTED&apos;;</span><br><span class="line"></span><br><span class="line">class Promise &#123;</span><br><span class="line">  constructor (executor) &#123;</span><br><span class="line">    this.state = PENDING;</span><br><span class="line">	this.value = undefined;</span><br><span class="line">	this.reason = undefined;</span><br><span class="line">	// ...</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Promise-executor"><a href="#Promise-executor" class="headerlink" title="Promise executor"></a>Promise executor</h4><p>上面代码中<code>constructor</code>传入了一个<code>executor</code>，这个是按照原生Promise的写法，声明一个Promise对象实例需要传入<code>executor</code>，这个executor需要带有两个参数，包括<code>resolve</code>跟<code>reject</code>。</p>
<p><code>resolve</code>跟<code>reject</code>是用来判断promise状态的两个函数，要求Promise转化为成功态时要调用<code>resolve</code>，并传入value，而转化为失败态时要调用<code>reject</code>，并传入reason。而且，<code>executor</code>是个立即执行的，是同步的。</p>
<p>当<code>resolve</code>获得value时，会把值赋给promise的value，并判断当前是否为等待态，是则会把状态改为成功态；而<code>reject</code>操作类似，把获得的reason赋值给promise的reason，然后判断等待态后把状态改为失败态。</p>
<p><code>executor</code>的执行可能出现运行报错，所以需要用<code>try catch</code>来捕获报错，捕获的报错则传给<code>reject</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">  constructor (executor) &#123;</span><br><span class="line">    this.state = PENDING;</span><br><span class="line">	this.value = undefined;</span><br><span class="line">	this.reason = undefined;</span><br><span class="line">    let resolve = (value) =&gt; &#123;</span><br><span class="line">      // ...</span><br><span class="line">      if (this.state === PENDING) &#123;</span><br><span class="line">        this.state = FULFILLED;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.onFulfilledStack.forEach(fn =&gt; fn());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    let reject = (reason) =&gt; &#123;</span><br><span class="line">      if (this.state === PENDING) &#123;</span><br><span class="line">        this.state = REJECTED;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">        this.onRejectedStack.forEach(fn =&gt; fn());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (exception) &#123;</span><br><span class="line">      reject(exception);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-then"><a href="#Promise-then" class="headerlink" title="Promise then"></a>Promise then</h3><p>promise/A+规范要求实现的promise需要有<code>then</code>方法。这个方法需要传入两个回调函数，<code>onFulfilled</code>和<code>onRejected</code>。因为支持链式调用，所以也要求函数返回的是一个promise。</p>
<p>首先，对于以上的要求，可以写出下面<code>then</code>方法的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Promise &#123;</span><br><span class="line">  // constructor...</span><br><span class="line">  then (onFulfilled, onRejected) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  let promise2;</span><br><span class="line">  promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">  return promise2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>then</code>方法中的<code>onFulfilled</code>和<code>onRejected</code>跟<code>promise2</code>规范中有比较详细的要求，所以我们单独的实现。</p>
<h4 id="onFulfilled和onRejected调用要求"><a href="#onFulfilled和onRejected调用要求" class="headerlink" title="onFulfilled和onRejected调用要求"></a><code>onFulfilled</code>和<code>onRejected</code>调用要求</h4><p>首先，只有当promise的状态为成功态时，才可以调用<code>onFulfilled</code>回调，并传入<code>value</code>，而只有为失败态时，才可以调用<code>onRejected</code>回调，并传入<code>reason</code>，而等待态的情况下，两个回调均不执行，会等待到状态转化之后才会根据状态执行。</p>
<p>同时，由于<code>then</code>方法支持多次调用，也就是说在promise等待态时，<code>then</code>方法调用的情况，所以需要在promise内部使用两个数组来储存所有的<code>onFulfilled</code>和<code>onRejected</code>方法，并在转化状态后按照先后顺序调用执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// Promise constructor</span><br><span class="line">this.onFulfilledStack = [];</span><br><span class="line">this.onRejectedStack = [];</span><br><span class="line">let resolve = (value) =&gt; &#123;</span><br><span class="line">  if (this.state === PENDING) &#123;</span><br><span class="line">    this.state = FULFILLED;</span><br><span class="line">    this.value = value;</span><br><span class="line">    this.onFulfilledStack.forEach(fn =&gt; fn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let reject = (reason) =&gt; &#123;</span><br><span class="line">  if (this.state === PENDING) &#123;</span><br><span class="line">    this.state = REJECTED;</span><br><span class="line">    this.reason = reason;</span><br><span class="line">    this.onRejectedStack.forEach(fn =&gt; fn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// then的promise2内部</span><br><span class="line">if (this.state === FULFILLED) &#123;</span><br><span class="line">  onFulfilled(this.value);</span><br><span class="line">&#125;</span><br><span class="line">if (this.state === REJECTED) &#123;</span><br><span class="line">  onRejected(this.reason);</span><br><span class="line">&#125;</span><br><span class="line">if (this.state === PENDING) &#123;</span><br><span class="line">  this.onFulfilledStack.push(() =&gt; &#123;</span><br><span class="line">    onFulfilled(this.value);</span><br><span class="line">  &#125;)</span><br><span class="line">  this.onRejectedStack.push(() =&gt; &#123;</span><br><span class="line">    onRejected(this.reason);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="onFulfilled和onRejected结果判断"><a href="#onFulfilled和onRejected结果判断" class="headerlink" title="onFulfilled和onRejected结果判断"></a><code>onFulfilled</code>和<code>onRejected</code>结果判断</h4><p>由于Promise链式调用，在then中执行<code>onFulfilled</code>和<code>onRejected</code>返回的值有可能也是一个Promise对象，也有可能是一个其他普通的值，还有可能是抛出一个错误，而这些值都有各自不同的处理要求：</p>
<ol>
<li>如果返回的值是普通值，则调用promise2的resolve；</li>
<li>如果返回的值是一个promise，则需要等待执行完把这个promise的<code>value</code>或<code>reason</code>传给promise2的<code>resolve</code>或<code>reject</code>；</li>
<li>如果是抛出一个错误，则调用promise2的reject；</li>
<li>如果返回的值等于promise2，则抛出类型错误；</li>
</ol>
<p>基于上面的要求，可以使用一个<code>resolvePromise</code>来处理，需要传入以下值：</p>
<ol>
<li>执行<code>onFulfilled</code>和<code>onRejected</code>之后返回的值，x，用来判断处理结果;</li>
<li>promise2的<code>resolve</code>或<code>reject</code>，用来接收x；</li>
<li>promise2，用来判断x是否与之引用相等。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  if (this.status === SUCCESS) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        let x = onFulfilled(this.value);</span><br><span class="line">        resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.status === FAIL) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        let x = onRejected(this.reason);</span><br><span class="line">        resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">      &#125; catch (err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  if (this.status === PENDING) &#123;</span><br><span class="line">    this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x = onFulfilled(this.value);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          let x = onRejected(this.reason);</span><br><span class="line">          resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">        &#125; catch (err) &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="返回值x的判断"><a href="#返回值x的判断" class="headerlink" title="返回值x的判断"></a>返回值<code>x</code>的判断</h4><p>Promise A+规范提供了对x的判断方案。首先，判断x是否为一个方法或者一个对象，因为Promise的实现可以通过<code>Function</code>或<code>Object</code>来实现。其次，x带有一个then方法，这是本身Promise规范要求<br>的方法。除此之外，都判断为普通值。</p>
<p>另外，如果x是一个Promise，那么作为<code>x</code>成功态返回的值，同样也要判断是否为Promise，这个判断的处理跟<code>x</code>的处理相同，所以<code>resolvePromise</code>可以以递归方法的形式实现。</p>
<p>在判断完<code>x</code>为Promise之后，Promise A+规范有一个比较严谨的考虑，就是为了防止同时出现成功态跟失败态，要在调用promise2的<code>resolve</code>或<code>reject</code>之后，禁止再调用promise2的<code>reject</code>或<code>resolve</code>。</p>
<p>因此，<code>resolvePromise</code>实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function resolvePromise (promise2, x, resolve, reject) &#123;</span><br><span class="line">  if (promise2 === x) &#123;</span><br><span class="line">    return reject(new TypeError(&apos;Chaining cycle detected for promise #&lt;my Promise&gt;&apos;))</span><br><span class="line">  &#125;</span><br><span class="line">  let called;</span><br><span class="line">  if (typeof x === &apos;function&apos; || (typeof x === &apos;object&apos; &amp;&amp; x != null)) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      let then = x.then</span><br><span class="line">        if (typeof then === &apos;function&apos;) &#123;</span><br><span class="line">        then.call(x, y =&gt; &#123;</span><br><span class="line">          if (called) return</span><br><span class="line">          called = true</span><br><span class="line">          resolvePromise (promise2, y, resolve, reject)</span><br><span class="line">        &#125;, r =&gt; &#123;</span><br><span class="line">          if (called) return // 2)</span><br><span class="line">          called = true</span><br><span class="line">          reject(r)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (called) return</span><br><span class="line">      called = true</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>以上基本实现基于Promise A+规范的Promise类。最后可以安装<code>promise-aplus-tasts</code>库对实现的Promise做检验。测试之前需要加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">  let dfd = &#123;&#125;</span><br><span class="line">  dfd.promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    dfd.resolve = resolve;</span><br><span class="line">    dfd.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    return dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码本身也实现了一种异步操作代码同步化的处理。最后使用命令<code>promises-aplus-tests xxx.js</code>执行测试。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/06/09/work-summary6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/work-summary6/" itemprop="url">工作总结(6)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-09T22:38:28+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结，主要针对移动端网页开发中遇到的软键盘坑来整理的。</p>
<p>最近在做移动端页面，然后遇到一个很多人都遇到的坑：当页面有固定在底部的评论框的情况下，当点击评论框获得聚焦之后，底部评论框会被软键盘顶起，但是不会贴着软键盘顶部，而且后面的页面也会向上滚动一定高度，而且仍然可以滚动。这个问题的结果就是，在评论框获得聚焦时，整个页面会滚动，输入框位置很突兀，如果输入框是textarea，则有可能有一部分推到页面顶部一样，用户体验非常差。</p>
<p>这个问题拆解出来，有几个需要解决的问题：</p>
<ol>
<li><p>背景页面仍然可以滚动。我尝试了增加遮罩层，但是还是不受控制；</p>
</li>
<li><p>底部评论框顶起的位置不正确。这个问题在安卓系统不会出现，所以是iOS的坑；</p>
</li>
<li><p>底部评论框获得聚焦的时候，背景页面会被顶起。</p>
</li>
</ol>
<p>这个坑我在网上找了很多帖子，发现真的是一个很难解决的问题。我也有找到一些解决方案，但是实际实现下来效果还是很差。这里我们一个个问题来整理如何解决。</p>
<h4 id="背景页面滚动问题"><a href="#背景页面滚动问题" class="headerlink" title="背景页面滚动问题"></a>背景页面滚动问题</h4><p>这个问题不管在安卓还是iOS系统上都会出现。原因应该出现在本身页面高度超过窗口高度，而且移动端有touchmove事件，虽然有遮罩层，但是其实body是遮罩层的根节点，所以存在事件捕获跟冒泡的问题。</p>
<p>因此，主要的问题是要阻止touchmove事件。解决方案需要完成两步操作：</p>
<h5 id="1-禁止body的touch事件。这样可以确保touchmove事件不会从body元素开始捕获"><a href="#1-禁止body的touch事件。这样可以确保touchmove事件不会从body元素开始捕获" class="headerlink" title="1. 禁止body的touch事件。这样可以确保touchmove事件不会从body元素开始捕获"></a>1. 禁止body的touch事件。这样可以确保touchmove事件不会从body元素开始捕获</h5><p>处理的办法是设置body元素的touchAction属性为<code>none</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.style.touchAction = &apos;none&apos;;</span><br></pre></td></tr></table></figure>
<p>这样就可以禁止body的touch事件。不过这个只是适用于安卓系统，在safari上并不适用，因为safari不支持该属性</p>
<h5 id="2-阻止body发生默认的行为。这样可以保证touchmove事件不会触发body元素的滚动"><a href="#2-阻止body发生默认的行为。这样可以保证touchmove事件不会触发body元素的滚动" class="headerlink" title="2. 阻止body发生默认的行为。这样可以保证touchmove事件不会触发body元素的滚动"></a>2. 阻止body发生默认的行为。这样可以保证touchmove事件不会触发body元素的滚动</h5><p>处理的办法是使用<code>e.preventDefault()</code>，同时在绑定<code>addEventListener</code>的时候，需要再传一个<code>options</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.body.addEventListener(&apos;touchmove&apos;, this.stopTouch, &#123; passive: false, capture: true &#125;);</span><br><span class="line"></span><br><span class="line">stopTouch (e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addEventListener</code>的第三个参数<code>options</code>的写法比较少用到，我们一般用到的是<code>useCapture</code>，而且一般也是使用默认值<code>false</code>。在MDN有详细的说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">options</span><br><span class="line">一个指定有关 listener 属性的可选参数对象。可用的选项如下：</span><br><span class="line">capture:  Boolean，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发。</span><br><span class="line">once:  Boolean，表示 listener 在添加之后最多只调用一次。如果是 true， listener 会在其被调用之后自动移除。</span><br><span class="line">passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。</span><br></pre></td></tr></table></figure>
<p>我们在这里使用<code>{ passive: false }</code>，这样使用<code>preventDefault()</code>时Chrome等一些浏览器就不会报错；而使用<code>{ capture: true }</code>则可以是事件尽早被阻止。</p>
<p>第一个问题完整的解决方案代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    show(newVal) &#123;</span><br><span class="line">        this.toggleContainerTouchAction(newVal);</span><br><span class="line">        if (newVal) &#123;</span><br><span class="line">            document.body.addEventListener(&apos;touchmove&apos;, this.stopTouch, &#123; passive: false, capture: true &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            document.body.removeEventListener(&apos;touchmove&apos;, this.stopTouch, &#123; capture: true &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method: &#123;</span><br><span class="line">    toggleContainerTouchAction (flag) &#123;</span><br><span class="line">        document.body.style.touchAction = flag ? &apos;none&apos; : &apos;auto&apos;;</span><br><span class="line">    &#125;,</span><br><span class="line">    stopTouch (e) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="底部评论框顶起的位置"><a href="#底部评论框顶起的位置" class="headerlink" title="底部评论框顶起的位置"></a>底部评论框顶起的位置</h4><p>首先，这个问题的根本问题是iOS在处理fixed布局时，当页面输入框获得焦点的时候，会把fixed改成absolute绝对定位，同时计算fixed容器在页面的位置，以此作为绝对定位的位置。正常来说其实会让底部评论框顶到软键盘顶部的位置，虽然如果滚动页面的话底部评论框是会跟软键盘分开，但是上面已经有解决方案了，所以其实还好。问题在于因为在软键盘上滑的同时，页面整体也会被动向上滚动，但评论框的位置是在页面滚动前计算的，所以才会出现顶起后还跟软键盘分离的情况。</p>
<p>因此，首先可以想到的是，不用fixed布局，而改用absolute布局，同时在输入框获得焦点的时候，动态计算输入框容器的高度。</p>
<p>不过直接放弃fixed布局其实是很可惜的，因为如果一开始写布局的时候就用绝对定位，那底部评论框就得一直动态计算位置，而且这个问题只是iOS系统才会出现，安卓系统是没问题的。</p>
<p>所以在处理的时候，我把问题拆分了：</p>
<ol>
<li>输入框在布局上，iOS跟安卓是分开处理的；</li>
<li>其次，iOS系统的布局，也按软键盘调起(等同于输入框获得焦点)与否分开处理；</li>
<li>因为页面滚动已经被设置为不可滚动，所以动态计算可以控制在一定次数以内。这三个优化可以让方案实施时减少JS的操作，提高页面性能，增加CSS样式操作。</li>
</ol>
<h5 id="1-样式布局"><a href="#1-样式布局" class="headerlink" title="1. 样式布局"></a>1. 样式布局</h5><p>样式布局上，我把fixed布局跟absolute布局从原来class<code>.input-container</code>中分离出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.input-container-absolute &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.input-container-fixed &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    bottom: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过<code>v-bind</code>先把<code>.input-container-fixed</code>绑到输入框容器上。当输入框获得焦点的时候，判断平台是iOS还是安卓，如果是iOS，就改成<code>.input-container-absolute</code>，如果是安卓，就不变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleComment () &#123;</span><br><span class="line">    if (this.tp.platformInfo === &apos;iOS&apos;) &#123;</span><br><span class="line">        this.inputCls = &apos;input-container-absolute input-container&apos;;</span><br><span class="line">		/* ... */</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*...*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>当输入框失去焦点的时候，再改回fixed布局：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handleBlur () &#123;</span><br><span class="line">    if (this.tp.platformInfo === &apos;iOS&apos;) &#123;</span><br><span class="line">        /* ... */</span><br><span class="line">		this.$refs.inputCon.style.top = &apos;&apos;;</span><br><span class="line">        this.inputCls = &apos;input-container-fixed input-container&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这样对于安卓系统来说，解决iOS系统的js操作跟安卓系统来说一点影响都没有。</p>
<h5 id="2-iOS系统的布局"><a href="#2-iOS系统的布局" class="headerlink" title="2. iOS系统的布局"></a>2. iOS系统的布局</h5><p>其实上面的代码也基本说明了，在iOS系统上，布局也不是完全使用绝对布局，就上面的代码，就可以保证在软键盘没有被调起的时候，不需要js控制布局。</p>
<h5 id="3-动态计算"><a href="#3-动态计算" class="headerlink" title="3. 动态计算"></a>3. 动态计算</h5><p>这个问题是整个问题的核心点。首先，使用什么值来确定输入框的位置。因为使用了绝对定位，而且这个位置问题其实是y轴上滚动造成的，所以问题缩小为<code>top</code>跟<code>bottom</code>的选择上。一般fixed布局使用<code>bottom</code>，绝对定位也使用<code>bottom</code>可以统一定位方式，但是实际在<code>.input-container-fixed</code>跟<code>.input-container-absolute</code>的样式上，其实已经说明了绝对定位时，我是选择<code>top</code>来控制输入框的位置的。因为我在尝试使用<code>bottom</code>，发现计算不出来，尴尬…</p>
<p>所以我是计算了<code>top</code>。怎么计算？我们这么考虑，应该是这样的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top = 页面滚动高度 + 视窗高度 - 输入框容器高度</span><br></pre></td></tr></table></figure>
<p>首先，页面滚动高度可以通过<code>document.documentElement.scrollTop</code>或<code>document.body.scrollTop</code>获得；输入框是在软键盘的顶部，而且其实当软键盘调起之后，实际的视窗高度是原来视窗高度减去软键盘高度。这部分不需要计算，直接使用<code>window.innerHeight</code>；输入框容器高度可以通过<code>offsetHeight</code>获得。因此，公式转换成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top = document.documentElement.scrollTop/document.body.scrollTop + window.innerHeight - this.$refs.input.offsetHeight</span><br></pre></td></tr></table></figure>
<p>这里简单说一下，bottom的计算我就是用上面的公式，就是不减去容器高度而已，但是显示效果就是不对…</p>
<p>所以就有下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">getScrollTop () &#123;</span><br><span class="line">    let scroll_top = 0;</span><br><span class="line">    if (document.documentElement &amp;&amp; document.documentElement.scrollTop) &#123;</span><br><span class="line">        scroll_top = document.documentElement.scrollTop;</span><br><span class="line">    &#125; else if (document.body) &#123;</span><br><span class="line">        scroll_top = document.body.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    return scroll_top;</span><br><span class="line">&#125;,</span><br><span class="line">		  </span><br><span class="line">handleScroll () &#123;</span><br><span class="line">    if (this.commentVisible) &#123;</span><br><span class="line">        this.scrollHeight = this.getScrollTop();</span><br><span class="line">		// +5px是为了确保输入框跟软键盘是贴在一起的，所以让输入框有一点点藏在软键盘下面是最保险的做法</span><br><span class="line">        this.$refs.inputCon.style.top = `$&#123;this.scrollHeight + window.innerHeight - this.$refs.inputCon.offsetHeight + 5&#125;px`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>其实直接使用上面的代码也不能解决，因为软键盘弹出是有时间的，也就是如果一获取焦点就计算，那就会导致输入框还在软键盘弹出前视窗的底部。所以要动态计算，即在一定时间内，需要使用定时器<code>setInterval</code>不断计算输入框的位置，这样在软键盘调起的过程，输入框也能一直附在软键盘顶部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scrollContent () &#123;</span><br><span class="line">    clearInterval(this.interval);</span><br><span class="line">    let i = 0;</span><br><span class="line">    this.interval = setInterval(() =&gt; &#123;</span><br><span class="line">        this.handleScroll();</span><br><span class="line">        i++;</span><br><span class="line">        if (i &gt; 20) &#123;</span><br><span class="line">            this.clearSrcoll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 50)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这里控制了只计算20次，是因为软键盘被调起的时间其实很短，测试情况大概1秒内就可以完成，不用一直动态计算，而且定时器间隔时间是50，所以就计算为20次。</p>
<p>因此，样式布局的方法就得增加一些代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">clearSrcoll() &#123;</span><br><span class="line">    clearInterval(this.interval);</span><br><span class="line">&#125;,</span><br><span class="line">		  </span><br><span class="line">handleComment () &#123;</span><br><span class="line">    if (this.tp.platformInfo === &apos;iOS&apos;) &#123;</span><br><span class="line">        this.inputCls = &apos;input-container-absolute input-container&apos;;</span><br><span class="line">		setTimeout(() =&gt; &#123;</span><br><span class="line">            this.scrollContent();</span><br><span class="line">        &#125;, 10)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /*...*/</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">handleBlur () &#123;</span><br><span class="line">    if (this.tp.platformInfo === &apos;iOS&apos;) &#123;</span><br><span class="line">        /* ... */</span><br><span class="line">		this.clearSrcoll();</span><br><span class="line">		this.$refs.inputCon.style.top = &apos;&apos;;</span><br><span class="line">        this.inputCls = &apos;input-container-fixed input-container&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这里要说明的是，跟业务代码是有不同的，因为实际上页面一开始放的评论框容器没有input标签，只是放了一个像输入框的底部容器，加了点击事件后，会控制显示输入框容器的显示，然后在DOM刷新之后(<code>this.$nextTick</code>)使用<code>focus()</code>触发输入框获得焦点。所以就不放完整代码了。</p>
<h4 id="页面顶起"><a href="#页面顶起" class="headerlink" title="页面顶起"></a>页面顶起</h4><p>这个问题其实没有解决，考虑到影响不大，而且当页面高度只有一屏时，也不会出现(主要是没有找到很好的解决方案)，所以就不处理了。但是这个问题在其他情况下有解决方案，详情可以看工作总结(五)中关于iOS下微信H5页面的坑解决方案的整理。</p>
<p>上面就是全部内容。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/06/09/work-summary5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/09/work-summary5/" itemprop="url">工作总结(5)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-09T22:35:28+08:00">
                2019-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇总结主要涉及微信H5开发中的比较重要的内容，整理下来也是为了以后可以方便开发。</p>
<p>其实微信接口的使用在微信公众号文档中都有详细的讲解，所以我会整理工作中使用微信接口的代码逻辑。所有代码都是在Vuejs框架下开发的。</p>
<h3 id="微信网页授权"><a href="#微信网页授权" class="headerlink" title="微信网页授权"></a>微信网页授权</h3><p>微信网页授权是微信H5中最为重要的，因为如果授权不成功，用户也进不了页面中来。</p>
<p>微信网页授权分两种情况，用scope来体现：当scope为<code>snsapi_base</code>时，网页授权可以获得用户的openid，而且是静默授权，并自动跳转到回调页中，相当于直接进入H5页面中；当scope为<code>snsapi_userinfo</code>时，网页授权可以获得用户的基本信息，但是需要用户手动同意。还有一种是涉及用户关注公众号的，暂且不提。这里我们主要也是整理前一种网页授权方式。</p>
<p>微信公众号文档中对网页授权流程有分步骤，按照以获取用户openid为目的，操作就是引导用户打开以下链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// appid为公众号唯一标识</span><br><span class="line">// redirect_uri是授权后重定向的回调链接，对应业务链接</span><br><span class="line">// response_type是返回类型，请填写code</span><br><span class="line">// scope是授权类型</span><br><span class="line">// state为可选的参数，重定向后会带上，业务可以带一些参数</span><br><span class="line">// #wechat_redirect是无论直接打开还是做页面302重定向时候，必须带此参数</span><br><span class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</span><br></pre></td></tr></table></figure>
<p>然后静默获得用户授权之后，会跳转到以下链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// redirect_uri是重定向的回调链接</span><br><span class="line">// code是换取access_token的票据</span><br><span class="line">// state是网页授权时带上的可选参数</span><br><span class="line">redirect_uri/?code=CODE&amp;state=STATE</span><br></pre></td></tr></table></figure>
<p>我在搜索相关开发博客的时候也有看到在前端完成上面跳转的，简单说就是先判断链接是否带有code参数，没有的话就把<code>window.location.href</code>指向网页授权链接，重定向之后获得code参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.wxCode = this.$route.query.code ? code : &apos;&apos;;</span><br><span class="line">let local = window.location.href;</span><br><span class="line">if (this.wxCode == null || this.wxCode === &apos;&apos;) &#123; // 如果获取不到code，则重定向</span><br><span class="line">    window.location.href = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;APPID&#125;&amp;redirect_uri=$&#123;encodeURIComponent(local)&#125;&amp;response_type=$&#123;this.wxCode&#125;&amp;scope=$&#123;wxConfig.scope&#125;#wechat_redirect`;</span><br><span class="line">&#125; else &#123; </span><br><span class="line">    // 如果获取到code，发请求后端</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是实际开发中我们并没有在前端做这部分内容，而且交给后端做重定向。因为网页授权链接中带有appid，是公众号唯一标识，比较重要，考虑到保险起见，不放在前端代码中。</p>
<p>上面的代码可以看到，获取code之后，还需要后端获取access_token。文档也有提到，这部分安全级别非常高，涉及公众号secret跟用户的access_token，所以不允许在客户端请求。因此，获得code之后，我们可以把code通过接口传到服务器，在服务器进行access_token的获取。这一步可以获取到用户的openid，这个openid是用户跟公众号唯一的openid，所以非常有用。所以最终的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    inWx () &#123; // 判断是否在微信环境中</span><br><span class="line">        const userAgent = navigator.userAgent.toLowerCase();</span><br><span class="line">        return  /micromessenger/.test(userAgent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">created () &#123;</span><br><span class="line">    if (this.inWx) &#123;</span><br><span class="line">        this.initInfo();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    initInfo () &#123;</span><br><span class="line">        this.wxCode = this.$route.query.code;</span><br><span class="line">        // 由于是后端实现网页重定向跟授权的，所以其实前端只要获得code并发起请求传给服务器就可以了</span><br><span class="line">        /* ... */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="微信SDK"><a href="#微信SDK" class="headerlink" title="微信SDK"></a>微信SDK</h3><p>首先，使用微信sdk的前提是域名已绑定微信公众号。然后步骤是：引入js文件，通过config配置权限，通过ready接口跟error接口处理验证，最后用checkJsApi接口判断接口支持情况。</p>
<h4 id="引入js文件"><a href="#引入js文件" class="headerlink" title="引入js文件"></a>引入js文件</h4><p>在html文件中引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://res.wx.qq.com/open/js/jweixin-1.2.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">// 或</span><br><span class="line">// &lt;script src=&quot;http://res2.wx.qq.com/open/js/jweixin-1.4.0.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">// 都支持https</span><br></pre></td></tr></table></figure>
<h4 id="config配置"><a href="#config配置" class="headerlink" title="config配置"></a>config配置</h4><p>根据微信公众号文档，config配置需要以下字段：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> wx.config(&#123;</span><br><span class="line">    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">    appId: &apos;&apos;, // 必填，公众号的唯一标识</span><br><span class="line">    timestamp: , // 必填，生成签名的时间戳</span><br><span class="line">    nonceStr: &apos;&apos;, // 必填，生成签名的随机串</span><br><span class="line">    signature: &apos;&apos;,// 必填，签名</span><br><span class="line">    jsApiList: [] // 必填，需要使用的JS接口列表</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> 由于appid是公众号唯一标识，最好不要存放在客户端，所以可以通过请求从服务器获得除debug跟jsApiList之外的信息。所以会分两步走：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        jsApiList: [</span><br><span class="line">            &apos;updateAppMessageShareData&apos;, </span><br><span class="line">            &apos;updateTimelineShareData&apos;, </span><br><span class="line">            &apos;onMenuShareTimeline&apos;, </span><br><span class="line">            &apos;onMenuShareAppMessage&apos;, </span><br><span class="line">            &apos;onMenuShareQQ&apos;, </span><br><span class="line">            &apos;onMenuShareWeibo&apos;,</span><br><span class="line">            &apos;onMenuShareQZone&apos;, </span><br><span class="line">            &apos;previewImage&apos;, </span><br><span class="line">            &apos;openLocation&apos;, </span><br><span class="line">            &apos;getLocation&apos;</span><br><span class="line">        ],</span><br><span class="line">        checkResult: &#123;&#125;,</span><br><span class="line">        wxShareConfig: &#123;&#125;,</span><br><span class="line">        wxconfig_share: &#123;</span><br><span class="line">            title: &apos;&apos;, // 分享标题</span><br><span class="line">            desc: &apos;&apos;, // 分享描述</span><br><span class="line">            link: &apos;&apos;, // 分享链接</span><br><span class="line">            imgUrl: &apos;&apos;, // 分享图标</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">     getWechatConfig () &#123;</span><br><span class="line">        axios.get(api).then(res =&gt; &#123;</span><br><span class="line">            this.wxConfig = res.data;</span><br><span class="line">		    this.wxInit(this.wxConfig);</span><br><span class="line">	    &#125;).catch(error =&gt; &#123;</span><br><span class="line">            /* ... */</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">    wxInit(_rpdata) &#123;</span><br><span class="line">        // this.jsApiList = _rpdata.jsApiList;</span><br><span class="line">        wx.config(&#123;</span><br><span class="line">            debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">            appId: _rpdata.appId, // 必填，公众号的唯一标识</span><br><span class="line">            timestamp: _rpdata.timeStamp, // 必填，生成签名的时间戳</span><br><span class="line">            nonceStr: _rpdata.nonceStr, // 必填，生成签名的随机串</span><br><span class="line">            signature: _rpdata.signature, // 必填，签名，见附录1</span><br><span class="line">            jsApiList: this.jsApiList // 必填，需要使用的JS接口列表</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ready接口跟error接口处理"><a href="#ready接口跟error接口处理" class="headerlink" title="ready接口跟error接口处理"></a>ready接口跟error接口处理</h4><p> 在传入config之后，可以直接调用ready接口处理验证成功的，而error接口则是处理验证失败的情况：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    wxInit(_rpdata) &#123;</span><br><span class="line">        // this.jsApiList = _rpdata.jsApiList;</span><br><span class="line">        wx.config(&#123;</span><br><span class="line">            debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">            appId: _rpdata.appId, // 必填，公众号的唯一标识</span><br><span class="line">            timestamp: _rpdata.timeStamp, // 必填，生成签名的时间戳</span><br><span class="line">            nonceStr: _rpdata.nonceStr, // 必填，生成签名的随机串</span><br><span class="line">            signature: _rpdata.signature, // 必填，签名，见附录1</span><br><span class="line">            jsApiList: this.jsApiList // 必填，需要使用的JS接口列表</span><br><span class="line">        &#125;);</span><br><span class="line">        wx.ready(() =&gt; &#123;</span><br><span class="line">            /* ... */</span><br><span class="line">        &#125;);</span><br><span class="line">        wx.error(function (res) &#123;</span><br><span class="line">            /* ... */</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="checkJsApi接口"><a href="#checkJsApi接口" class="headerlink" title="checkJsApi接口"></a>checkJsApi接口</h3><p> 验证成功之后，还需要调用checkJsApi接口来判断客户端是否支持指定JS接口：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">wxInit(_rpdata) &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">    wx.ready(() =&gt; &#123;</span><br><span class="line">        wx.checkJsApi(&#123;</span><br><span class="line">            this.checkJsApi().then(() =&gt; &#123;</span><br><span class="line">                /* ... */</span><br><span class="line">				/* 这里就可以调用各种验证成功的接口了 */</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    /* ... */</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">checkJsApi() &#123;</span><br><span class="line">    return new Promise((resolve) =&gt; &#123;</span><br><span class="line">        wx.checkJsApi(&#123;</span><br><span class="line">            jsApiList: this.jsApiList, // 需要检测的JS接口列表，所有JS接口列表见附录2,</span><br><span class="line">            success: (res) =&gt; &#123;</span><br><span class="line">                console.log(res)</span><br><span class="line">                console.log(res.checkResult)</span><br><span class="line">                this.checkResult = res.checkResult;</span><br><span class="line">                // 以键值对的形式返回，可用的api值true，不可用为false</span><br><span class="line">                // 如：&#123;&quot;checkResult&quot;:&#123;&quot;chooseImage&quot;:true&#125;,&quot;errMsg&quot;:&quot;checkJsApi:ok&quot;&#125;</span><br><span class="line">                this.checkResult = res.checkResult;</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p> 以上完成微信SDK基础配置处理。</p>
<h3 id="微信分享"><a href="#微信分享" class="headerlink" title="微信分享"></a>微信分享</h3><p> 微信分享这块包括了所有分享的平台，使用的也是微信SDK所提供的所有分享相关的接口。目前微信分享有以下这些接口：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> updateAppMessageShareData // 分享给朋友及分享到QQ接口</span><br><span class="line">updateTimelineShareData // 分享到朋友圈及分享到QQ空间接口</span><br><span class="line">onMenuShareTimeline // 分享到朋友圈接口(即将废弃)</span><br><span class="line">onMenuShareAppMessage // 分享给朋友接口(即将废弃)</span><br><span class="line">onMenuShareQQ // 分享到QQ接口(即将废弃)</span><br><span class="line">onMenuShareWeibo // 分享到腾讯微博</span><br><span class="line">onMenuShareQZone // 分享到QQ空间</span><br></pre></td></tr></table></figure>
<p> 所有接口的写法基本相同，所有这里只列举一个接口的写法作为例子。通过上面的接口验证后，就可以调用这些接口了。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> wxShareInit() &#123;</span><br><span class="line">    const checkResult = this.checkResult;</span><br><span class="line">    if (checkResult.updateAppMessageShareData) &#123;</span><br><span class="line">        wx.updateAppMessageShareData(&#123;</span><br><span class="line">            title: this.wxconfig_share.title, // 分享标题</span><br><span class="line">            desc: this.wxconfig_share.desc, // 分享描述</span><br><span class="line">            link: this.wxconfig_share.link, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致</span><br><span class="line">            imgUrl: this.wxconfig_share.imgUrl, // 分享图标</span><br><span class="line">            success: function () &#123;</span><br><span class="line">                // 用户确认分享后执行的回调函数</span><br><span class="line">                console.log(&apos;share AppMessage success!&apos;)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">	// 其他接口写法相同</span><br><span class="line">	/*...*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="微信关注"><a href="#微信关注" class="headerlink" title="微信关注"></a>微信关注</h3><p>微信关注这个比较容易，其实就是跳转到历史消息页面，如果用户没有关注公众号的话，这个页面会显示关注按钮。这个链接的形式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=xxxxxxxx#wechat_redirect</span><br></pre></td></tr></table></figure>
<p>其中，xxxxxxxx用公众号的uin id的base64编码替换。这个公众号的uin id可以在微信公众平台登入账号后，在源代码中查找uin即可找到一串数字，然后把这串数字用base64编码，获得。</p>
<p>不过实际的效果是这个页面的关注按钮有时会出现，有时没有，后来网上查了一下，这个页面的关注按钮已经被微信屏蔽了，除非跟微信投钱合作，才会显示。所以……</p>
<h3 id="微信关注判断"><a href="#微信关注判断" class="headerlink" title="微信关注判断"></a>微信关注判断</h3><p>微信关注的判断目前我还没有做过，但是大致的了解到判断的方案。最关键的是需要获得openid，获得access_token，然后通过获取用户基本信息接口获得用户信息，进而判断。</p>
<p>首先，获得openid的方法已经在微信网页授权一节有说明，故可以获得；获得access_token需要前端获取code，然后传给服务器去换access_token，所以这一步也在微信网页授权一节有说明，故也可以获得。</p>
<p>获取用户基本信息接口为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// http请求方式: GET</span><br><span class="line">https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</span><br></pre></td></tr></table></figure>
<p>然后根据微信公众号开发文档所介绍的，返回的数据有这些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;subscribe&quot;: 1, </span><br><span class="line">    &quot;openid&quot;: &quot;o6_bmjrPTlm6_2sgVt7hMZOPfL2M&quot;, </span><br><span class="line">    &quot;nickname&quot;: &quot;Band&quot;, </span><br><span class="line">    &quot;sex&quot;: 1, </span><br><span class="line">    &quot;language&quot;: &quot;zh_CN&quot;, </span><br><span class="line">    &quot;city&quot;: &quot;广州&quot;, </span><br><span class="line">    &quot;province&quot;: &quot;广东&quot;, </span><br><span class="line">    &quot;country&quot;: &quot;中国&quot;, </span><br><span class="line">    &quot;headimgurl&quot;:&quot;http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</span><br><span class="line">    &quot;subscribe_time&quot;: 1382694957,</span><br><span class="line">    &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</span><br><span class="line">    &quot;remark&quot;: &quot;&quot;,</span><br><span class="line">    &quot;groupid&quot;: 0,</span><br><span class="line">    &quot;tagid_list&quot;:[128,2],</span><br><span class="line">    &quot;subscribe_scene&quot;: &quot;ADD_SCENE_QR_CODE&quot;,</span><br><span class="line">    &quot;qr_scene&quot;: 98765,</span><br><span class="line">    &quot;qr_scene_str&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以获得到不少的信息了，这里我们关注的是<code>subscribe</code>这个字段，是指用户是否订阅该公众号标识。0为未关注，1为已关注。这样，我们就可以判断用户是否关注公众号了。</p>
<h3 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h3><p>微信支付有两种方案，一种是依赖上面的微信JS-SDK，再配置完成之后调用chooseWXPay方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 官方文档</span><br><span class="line">wx.chooseWXPay(&#123;</span><br><span class="line">    timestamp: 0, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符</span><br><span class="line">    nonceStr: &apos;&apos;, // 支付签名随机串，不长于 32 位</span><br><span class="line">    package: &apos;&apos;, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\*\*\*）</span><br><span class="line">    signType: &apos;&apos;, // 签名方式，默认为&apos;SHA1&apos;，使用新版支付需传入&apos;MD5&apos;</span><br><span class="line">    paySign: &apos;&apos;, // 支付签名</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">        // 支付成功后的回调函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以参考上面微信分享一节的封装方案进行开发。</p>
<p>另一种方案是调用在微信内置浏览器才有的WeixinJSBridge内置对象。这种方案使用起来比较简单，不需要引入什么，配置什么，只要是在微信内置浏览器中，就一定能调用这个内置对象。使用的时候只要先判断是否存在WeixinJSBridge内置对象，存在则可以传入请求参数，然后再判断返回的支付信息。需要传入的参数跟上面的一样，一般需要发起支付请求给服务器，让服务器提供需要的参数，然后在去调用WeixinJSBridge内置对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 微信支付api相关配置文档</span><br><span class="line">onBridgeReady (data) &#123;</span><br><span class="line">    if (typeof WeixinJSBridge === &apos;undefined&apos;) &#123;</span><br><span class="line">    this.$toast(&#123;</span><br><span class="line">        message: &apos;请使用微信内置浏览器进行支付&apos;,</span><br><span class="line">        position: &apos;bottom&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        WeixinJSBridge.invoke(</span><br><span class="line">            &apos;getBrandWCPayRequest&apos;,</span><br><span class="line">            &#123;</span><br><span class="line">                appId: data.appId, // 公众号名称，由商户传入</span><br><span class="line">                timeStamp: data.timeStamp, // 时间戳，自1970年以来的秒数</span><br><span class="line">                nonceStr: data.nonceStr, // 随机串</span><br><span class="line">                package: data.package,</span><br><span class="line">                signType: data.signType, // 微信签名方式：</span><br><span class="line">                paySign: data.paySign // 微信签名</span><br><span class="line">            &#125;,</span><br><span class="line">            res =&gt; &#123;</span><br><span class="line">                if (res.err_msg === &apos;get_brand_wcpay_request:ok&apos;) &#123;</span><br><span class="line">                    this.$toast(&#123;</span><br><span class="line">                        message: &apos;支付成功&apos;,</span><br><span class="line">                        position: &apos;bottom&apos;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    /* ... */</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    this.$toast(&#123;</span><br><span class="line">                        message: &apos;支付失败&apos;,</span><br><span class="line">                        position: &apos;bottom&apos;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="微信地图"><a href="#微信地图" class="headerlink" title="微信地图"></a>微信地图</h3><p>在微信H5中调起微信地图也是一个常见的功能点，也是可以通过微信JS-SDK的接口来实现。</p>
<p>一般使用微信地图分两种情况：一种是需要打开已知地点的微信地图，方便用户对地点进行导航；另一种是需要打开用户所在位置的微信地图。</p>
<h4 id="已知地点的微信地图"><a href="#已知地点的微信地图" class="headerlink" title="已知地点的微信地图"></a>已知地点的微信地图</h4><p>这里使用的为微信JS-SDK 中的openLocation接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 官方文档</span><br><span class="line">wx.openLocation(&#123;</span><br><span class="line">    latitude: 0, // 纬度，浮点数，范围为90 ~ -90</span><br><span class="line">    longitude: 0, // 经度，浮点数，范围为180 ~ -180。</span><br><span class="line">    name: &apos;&apos;, // 位置名</span><br><span class="line">    address: &apos;&apos;, // 地址详情说明</span><br><span class="line">    scale: 1, // 地图缩放级别,整形值,范围从1~28。默认为最大</span><br><span class="line">    infoUrl: &apos;&apos; // 在查看位置界面底部显示的超链接,可点击跳转</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>根据官方文档，我们需要拿到已知地点的纬度，经度，位置名跟地址详情说明。我们可以通过以下网页获得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.gpsspg.com/maps.htm</span><br></pre></td></tr></table></figure>
<p>然后参考前面微信分享的封装进行开发。</p>
<h4 id="打开用户所在位置的微信地图"><a href="#打开用户所在位置的微信地图" class="headerlink" title="打开用户所在位置的微信地图"></a>打开用户所在位置的微信地图</h4><p>这里还需要使用另一个接口：getLocation接口。也很简单，这里直接贴代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wx.getLocation(&#123;</span><br><span class="line">    type: &apos;gcj02&apos;,</span><br><span class="line">    success: function (res) &#123;</span><br><span class="line">         wx.openLocation(&#123;</span><br><span class="line">            latitude: res.latitude,</span><br><span class="line">            longitude: res.longitude,</span><br><span class="line">            name: config.name,</span><br><span class="line">            address: config.address,</span><br><span class="line">            scale: 28,</span><br><span class="line">            infoUrl: &apos;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    cancel: function (res) &#123;</span><br><span class="line">        console.log(&apos;cancel: &apos;, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="微信H5的坑"><a href="#微信H5的坑" class="headerlink" title="微信H5的坑"></a>微信H5的坑</h3><h4 id="iOS中微信环境下页面有浮框软键盘隐藏后页面不能点击问题"><a href="#iOS中微信环境下页面有浮框软键盘隐藏后页面不能点击问题" class="headerlink" title="iOS中微信环境下页面有浮框软键盘隐藏后页面不能点击问题"></a>iOS中微信环境下页面有浮框软键盘隐藏后页面不能点击问题</h4><p>问题是这样的：浮框中有输入框，使用了fixed布局，可能在页面正中间，也可能出现在页面底部。当输入框失去焦点时，软键盘隐藏，但是页面所有点击事件都发生错乱。</p>
<p>其实和这个问题跟iOS系统有关，也跟微信有关。本身iOS系统下调出软键盘就会影响页面布局，然后滚动页面，然后微信内置浏览器会在软键盘隐藏时恢复页面布局，但是并没有恢复监听事件的位置。也就是在虽然有监听事件的标签元素恢复到原位了，但是监听的区域并没有恢复，因为受到页面滚动的影响。</p>
<p>如何处理？分两种情况：一种情况是浮框只出现在页面第一屏，这种情况下，在软键盘隐藏的同时，操作页面滚动到顶部，即可恢复正常的监听区域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollBack () &#123; // 绑定在blur事件上</span><br><span class="line">    window.scrollTo(0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种情况是浮框在底部，这种情况主要跟iOS系统有关，会单独放在下一篇工作总结中详细整理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2019/05/06/work-summary4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/work-summary4/" itemprop="url">工作总结(4)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T23:28:05+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/" itemprop="url" rel="index">
                    <span itemprop="name">Vue</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/Vue/工作总结/" itemprop="url" rel="index">
                    <span itemprop="name">工作总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇工作总结，会整理一些比较零散的开发内容。</p>
<h3 id="Element-UI相关"><a href="#Element-UI相关" class="headerlink" title="Element-UI相关"></a>Element-UI相关</h3><h4 id="el-scrollbar组件"><a href="#el-scrollbar组件" class="headerlink" title="el-scrollbar组件"></a>el-scrollbar组件</h4><p>在查ElementUI官方文档的时候，你会发现找不到滚动相关的组件，但实际上是有一个关于滚动相关的组件，只是没有文档。就是el-scrollbar组件。</p>
<p>这个组件可以在查官方文档页面元素的时候找到，我是因为官方文档左右独立滚动而发现的。我们可以查查它的源码。</p>
<p>源码中，在scrollbar/src下有main.js文件，这个文件中就有关于srollbar的实现源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    native: Boolean, // 是否显示滚动条</span><br><span class="line">    wrapStyle: &#123;&#125;, // 外层容器el-scrollbar__wrap同层的style样式</span><br><span class="line">    wrapClass: &#123;&#125;, // 外层容器el-scrollbar__view同层的class样式</span><br><span class="line">    viewClass: &#123;&#125;, // 内层容器el-scrollbar__view同层的style样式</span><br><span class="line">    viewStyle: &#123;&#125;, // 内层容器el-scrollbar__view同层的class样式</span><br><span class="line">    noresize: Boolean, // 如果 container 尺寸不会发生变化，最好设置它可以优化性能</span><br><span class="line">    tag: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &apos;div&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上面就是我们使用el-scrollbar组件时可以传入的prop：<code>native</code>是用于判断是否显示滚动条，从源码的实现来看，滚动条是ElementUI自己实现的，也就是如果需要显示滚动条，可以考虑使用这个组件；<code>noresize</code>是用于判断是否需要监听尺寸变化事件，如果滚动内容的长度固定不变，可以设置为true以优化性能；<code>tag</code>是用于指定内层容器渲染的标签。知道这些，我们就可以知道怎么使用el-scrollbar组件了。</p>
<p>我们再看看ElementUI官网是怎么使用它的：以官网导航栏为例，在<code>.el-scrollbar</code>的父类<code>.page-component</code>上设定了高度为100%，然后在<code>.el-scrollbar</code>同层增加<code>.page-component__nav</code>类实现导航栏的样式，最后在内层容器内使用<code>.side-nav</code>再设定100%的高度。</p>
<p>我自己使用的过程中是在内层容器内使用一个类设定固定的高度，然后就可以实现滚动效果。</p>
<h4 id="el-table-表头跟表格宽度不一致"><a href="#el-table-表头跟表格宽度不一致" class="headerlink" title="el-table 表头跟表格宽度不一致"></a>el-table 表头跟表格宽度不一致</h4><p>我在开发中发现了这个问题，在网上也发现有很多人遇到这个问题，目前我使用的解决方案是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 解决elementUI表头跟表格宽度不一致 */</span><br><span class="line">body .el-table th.gutter &#123;</span><br><span class="line">    display: table-cell!important;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">body .el-table colgroup.gutter &#123;</span><br><span class="line">    display: table-cell!important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="安卓跟iOS的坑"><a href="#安卓跟iOS的坑" class="headerlink" title="安卓跟iOS的坑"></a>安卓跟iOS的坑</h3><h4 id="new-Date-转换时间戳"><a href="#new-Date-转换时间戳" class="headerlink" title="new Date()转换时间戳"></a>new Date()转换时间戳</h4><p>在iOS的微信H5开发中，使用<code>new Date(&#39;2019-5-4&#39;)</code>会出现报错，究其原因是iOS下不能使用<code>-</code>，应该使用<code>/</code>，即<code>new Date(&#39;2019/5/4&#39;)</code>。</p>
<h4 id="安卓非body标签无滚动条"><a href="#安卓非body标签无滚动条" class="headerlink" title="安卓非body标签无滚动条"></a>安卓非body标签无滚动条</h4><p>在开发的过程中，我们发现在安卓系统中，页面中除了body之外其他标签都无法传滚动条，但是iOS系统就会有。这种情况下我们可以自己实现或借助一些UI框架实现滚动条。如果选择借助的话，可以考虑ElementUI的el-scrollbar组件(前面在分析源码的时候就有这样一个prop)，也可以考虑better-scroll插件，通过配置来实现滚动条。</p>
<h3 id="前端开发的占位图"><a href="#前端开发的占位图" class="headerlink" title="前端开发的占位图"></a>前端开发的占位图</h3><p>其实开发中如果能考虑上占位图的话，对用户的使用体验是有很高的提升的。以往通过加载条来表示加载会让用户觉得加载时间很长，而使用占位图则会给用户一种页面逐渐加载完毕的效果。</p>
<p>网上有很多推荐的占位图实现方案，有给未加载数据的容器加占位图样式的，有在数据加载完毕前先画一些占位容器的。这里就不一一细讲，主要是找到一个觉得挺不错的插件可以方便占位图的实现的：vue-content-loader。</p>
<p>这个插件是通过实现SVG组件来完成占位图，看起来效果还不错，而且官方还给出一个页面可以通过拉拽，数据调整实现占位图组件。</p>
<p>另外，它还有一个React版本。虽然我还没有使用过，不知道效果如何，但是我觉得应该是很有尝试的必要的。</p>
<h3 id="vue中的图片懒加载"><a href="#vue中的图片懒加载" class="headerlink" title="vue中的图片懒加载"></a>vue中的图片懒加载</h3><p>除了占位图的加载优化，图片的懒加载也是前端开发中比较常见的加载优化点。在一个页面上，如果需要加载的图片很多，一般都会考虑优先加载第一版的图片，等用户滚动页面时，出现在窗口内的图片才会被加载。</p>
<p>这里可以使用vue-lazyload插件。这个插件使用起来非常简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// npm</span><br><span class="line">$ npm i vue-lazyload -S</span><br><span class="line"></span><br><span class="line">//main.js</span><br><span class="line">// 引入</span><br><span class="line">import VueLazyload from &apos;vue-lazyload&apos;</span><br><span class="line">// 注册</span><br><span class="line">Vue.use(VueLazyload)</span><br><span class="line">// 配置</span><br><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">  preLoad: 1.3,</span><br><span class="line">  error: &apos;dist/error.png&apos;,</span><br><span class="line">  loading: &apos;dist/loading.gif&apos;,</span><br><span class="line">  attempt: 1</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 例子</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;img in list&quot;&gt;</span><br><span class="line">        &lt;img v-lazy=&quot;img.src&quot; &gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>以上是截取官方文档的部分代码。这样就可以完成简单的图片懒加载了。还有很多配置可以使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Listentolife</p>
              <p class="site-description motion-element" itemprop="description">Listentolife's Blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archive">
              
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/listentolife" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:listentolife@qq.com" target="_blank" title="E-Mail">
                      E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Listentolife</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




<span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;</span>
<span id="showDays"></span>

<script>
	var birthDay = new Date('04/23/2018');
	var now = new Date();
	var duration = now.getTime() - birthDay.getTime();
	var total= Math.floor(duration / (1000 * 60 * 60 * 24));
	document.getElementById('showDays').innerHTML='本站已运行' + total + '天';
</script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
