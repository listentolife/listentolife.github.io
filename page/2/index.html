<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Listentolife&apos;s Blog">
<meta name="keywords" content="HTML CSS JavaScript">
<meta property="og:type" content="website">
<meta property="og:title" content="Listentolife">
<meta property="og:url" content="http://listentolife.github.io/page/2/index.html">
<meta property="og:site_name" content="Listentolife">
<meta property="og:description" content="Listentolife&apos;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Listentolife">
<meta name="twitter:description" content="Listentolife&apos;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://listentolife.github.io/page/2/"/>





  <title>Listentolife</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Listentolife</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">简单就好</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archive" rel="section">
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/12/19/React-Learning-Styled-Components/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/React-Learning-Styled-Components/" itemprop="url">react学习总结系列-styled-components</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T07:54:08+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一篇主要整理关于React的CSS插件styled-components。这个插件是我一开始学习React跟做项目的时候推荐并使用的。用了之后觉得这个插件确实很适合React的项目，有无缝对接的效果。</p>
<p>这里也是留一下styled-components官网文档地址：</p>
<p><a href="https://www.styled-components.com/docs" target="_blank" rel="noopener">https://www.styled-components.com/docs</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>简单说一下安装。</p>
<p>代码1 NPM&amp;CDN安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* NPM install */</span><br><span class="line">npm  install --save styled-components</span><br><span class="line"></span><br><span class="line">/* CDM install */</span><br><span class="line">; &lt;script src=&quot; https://unpkg.com/styled-components/dist/styled-components.min.js&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>styled-components使用也比较简单。最简单的写法就是声明styled变量，然后把css样式以模板字符串形式写入，最后把这个变量以React组件的形式写到<code>render()</code>中就可以了。</p>
<p>代码2 styled-components简单例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: palevioletred;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Wrapper = styled.section`</span><br><span class="line">  padding: 4em;</span><br><span class="line">  background: papayawhip;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Wrapper&gt;</span><br><span class="line">    &lt;Title&gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">  &lt;/Wrapper&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>上面是官网用例。可以看到，其实是把css样式表嵌入到JavaScript中，然后通过styled-components转成组件，然后再在其他组件中使用。所以使用起来非常简单。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>因为style-components把css样式表转成一个个的组件，所以也可以实现一些样式的传参。</p>
<p>代码2 传递参数，对代码1的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: \function(e)&#123;return e.inputColor||&quot;palevioletred&quot;&#125;;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Title inputColor=&quot;rebeccapurple&quot; &gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>代码2中，在变量<code>Input</code>的样式表中，color后面是跟着一个<code>\</code>，接着一个匿名函数。这个匿名函数有一个传参<code>e</code>，函数中会返回<code>e.inputColor</code>或默认值<code>&quot;palevioletred&quot;</code>。在<code>render()</code>函数中，第二个<code>Input</code>组件标签中声明了一个inputColor的属性值，而第一个没有。在最终的显示上，第一个组件字体样式是紫罗兰红(palevioletred)，第二个组件字体样式是丽贝卡紫(rebeccapurple)。也就是说，变量<code>Input</code>的样式表中的匿名函数，传入的参数<code>e</code>应该指向当前组件对象</p>
<p>传递参数的类型还可以是真假值。组件的属性上，可以直接声明一个属性并不传值，匿名函数中可将直接判断是否存在这个属性，以确定返回的样式值。</p>
<p>代码3 传递属性，对代码1的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: $&#123;props =&gt; props.primary ? &quot;palevioletred&quot; : &quot;white&quot;&#125;;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Title primary &gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="组件继承"><a href="#组件继承" class="headerlink" title="组件继承"></a>组件继承</h3><p>一个项目中或多或少会出现一些组件上设计样式的类似，比如不同级标题可能HTML样式，尺寸是一样的，但是颜色会不同。如果都是写成独立的组件样式表，则会出现代码冗余，不好维护。这种情况下就可以考虑使用组件继承。</p>
<p>代码4 组件继承，对代码1的修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const Title = styled.h1`</span><br><span class="line">  font-size: 1.5em;</span><br><span class="line">  text-align: center;</span><br><span class="line">  color: palevioletred;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const SecondTitle = styled(Title)`</span><br><span class="line">	font-size: 1em;</span><br><span class="line">	font-weight: bold;</span><br><span class="line">` </span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Title&gt;</span><br><span class="line">      Hello World, this is my first styled component!</span><br><span class="line">    &lt;/Title&gt;</span><br><span class="line">	&lt;SecondTitle&gt;</span><br><span class="line">	  This is the second title!</span><br><span class="line">	&lt;/SecondTitle&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>如果<code>Title</code>中没有样式的话，那它就是直接继承<code>react.component</code>的组件，仍然可以被继承。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>styled-components对动画也有很好的支持。内置了<code>keyframes</code>来实现CSS3中的<code>@keyframes</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const rotate360 = keyframes`</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: rotate(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: rotate(360deg);</span><br><span class="line">  &#125;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">const Rotate = styled.div`</span><br><span class="line">  display: inline-block;</span><br><span class="line">  animation: $&#123;rotate360&#125; 2s linear infinite;</span><br><span class="line">  padding: 2rem 1rem;</span><br><span class="line">  font-size: 1.2rem;</span><br><span class="line">`;</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Rotate&gt;&amp;lt; 💅 &amp;gt;&lt;/Rotate&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>除了上面介绍的方面之外，styled-component插件还有一些更复杂的用法，但是目前大部分的样式实现只要上面这些内容掌握了，在项目中也能解决大部分的问题了。剩下的以后有涉及到会再介绍。</p>
<p>下一篇将会介绍redux及react-redux插件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/11/24/React-Learning-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/24/React-Learning-II/" itemprop="url">react学习总结系列-react(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-24T21:29:27+08:00">
                2018-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇主要写的是React中父子组件数据传递跟生命周期。</p>
<h3 id="父子组件数据传递"><a href="#父子组件数据传递" class="headerlink" title="父子组件数据传递"></a>父子组件数据传递</h3><p>上一篇其实有说到，组件跟组件之前其实是相对独立的。虽然每个组件的数据是可以独立处理，但是组件与组件之间的数据还是存在联系的，而所有的组件之间的数据关系，都是可以归结为父组件跟子组件之间的数据传递关系。再拆分这种数据传递关系，就是要解决<strong>父组件数据传给子组件</strong>，<strong>子组件数据传给父组件</strong>两个问题。</p>
<ol>
<li><strong>父组件传入参数</strong>。在React中，父组件给子组件传递数据其实挺简单的，就是在子组件标签中通过变量进行传入，子组件通过props获取传入的数据：</li>
</ol>
<p>代码1 父组件传参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* 自己写豆瓣的一段代码，</span><br><span class="line">  * 图书页面Book组件中把页面类型参数Contants.Book传入</span><br><span class="line">  * 搜索Search组件</span><br><span class="line">  * /</span><br><span class="line">class Book extends Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;Search</span><br><span class="line">          page=&#123;this.state.book&#125;</span><br><span class="line">          searchInfo=&#123;this.getSearchInfo&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 搜索Search组件通过props.page接收父组件的参数，</span><br><span class="line">  * 判断input标签的属性placeholder的值</span><br><span class="line">  * 项目中还使用了styled-components插件，后面会另有介绍</span><br><span class="line">  * /</span><br><span class="line">class Search extends Component &#123;</span><br><span class="line">  // 根据父组件传入的props.page确定input标签的属性placeholder的值</span><br><span class="line">  showPlaceHolder () &#123;</span><br><span class="line">    const &#123; placeHolders, page &#125; = this.props</span><br><span class="line">    const placeHoldersJS = placeHolders.toJS()</span><br><span class="line">    return placeHoldersJS[page]</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;SearchWrapper&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;SearchInput</span><br><span class="line">            value=&#123;this.props.keyword&#125;</span><br><span class="line">            placeholder=&#123;this.showPlaceHolder()&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/SearchWrapper&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码有所省略，但基本上是对父子组件之前传递数据有基本的实现。注意，父组件的数据需要在子组件标签内用一个变量传入，这个变量将会放在子组件的props属性中。子组件调用这个变量时需要到props中调用。</p>
<ol start="2">
<li><strong>子组件传出参数</strong>。一般来说，React的数据流是单向流动，即父组件的数据可以流入子组件，但是子组件的数据是不能向父组件传递或修改父组件的数据。但是子组件是可以通过自己的事件处理函数，手动触发父组件传递进来的回调函数，在回调函数上把数据通过参数传递进去。这样就可以让子组件当数据有变化的时候，父组件也可以根据变化进行响应处理：</li>
</ol>
<p>代码2 子组件调用父组件回调函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 父组件Book组件向子组件Search先传入getSearchInfo()方法</span><br><span class="line">class Book extends Component &#123;</span><br><span class="line">  constructor (props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.getSearchInfo = this.getSearchInfo.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  getSearchInfo (newKeyword) &#123;</span><br><span class="line">    /* 省略代码 */</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    const &#123; pullDownStatus, pullUpStatus &#125; = this.props</span><br><span class="line">    return (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;Search</span><br><span class="line">          searchInfo=&#123;this.getSearchInfo&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子组件在handleClick()方法中调用父组件传入的回调函数searchInfo(keyword)，并把值传入</span><br><span class="line">class Search extends Component &#123;</span><br><span class="line">  constructor (props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.handleClick = this.handleClick.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    const &#123; searchInfo, keyword&#125; = this.props</span><br><span class="line">    if (keyword !== &apos;&apos;) &#123;</span><br><span class="line">      searchInfo(keyword)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;SearchWrapper&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;SearchInput /&gt;</span><br><span class="line">          &lt;SearchButton</span><br><span class="line">            onClick=&#123;this.handleClick&#125;</span><br><span class="line">          &gt;搜索&lt;/SearchButton&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/SearchWrapper&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有个地方需要注意的。父组件方法<code>getSearchInfo()</code>虽然是对象中的方法，但是它也有自己的作用域，所以正常来说它的this指向它自己的作用域，this.props就不存在了。所以需要在<code>constructor()</code>中指定它的作用域为整个类，需要补上<code>this.getSearchInfo = this.getSearchInfo.bind(this)</code>。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>我们来回头说一下组件的生命周期。组件的生命周期包括了初始化，第一次加载渲染，更新渲染跟卸载四个阶段。而React的生命周期函数主要分布在后面三个阶段。我们先每个阶段简单整理一下：</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>这个阶段主要还是调用了ES6中类的<code>constructor()</code>。通过构造器完成对父类的继承，变量的初始化和函数指定作用域。这个阶段还没有调用生命周期函数。</p>
<h4 id="第一次加载渲染"><a href="#第一次加载渲染" class="headerlink" title="第一次加载渲染"></a>第一次加载渲染</h4><p>第一次加载渲染的过程会调用三个生命周期函数：</p>
<p>1.<code>componentWillMount()</code>，这个函数将会在组件第一次加载渲染之前被调用。可以做一些组件渲染到页面前的操作。只调用一次。</p>
<p>2.<code>render()</code>，这个函数就是负责创建虚拟DOM，此时所有数据都至少已经初始化了。</p>
<p>3.<code>componentDidMount()</code>，这个函数是在组件第一次加载渲染完成之后马上被调用的，也只调用一次。这个函数可以调用ajax请求，返回的数据会在后面阶段更新组件状态，并触发重新渲染</p>
<h4 id="更新渲染"><a href="#更新渲染" class="headerlink" title="更新渲染"></a>更新渲染</h4><p>第一次加载渲染完成之后到组件被卸载之前，组件中的state状态跟props数据还是可以改变。所以会调用下面几个生命周期函数：</p>
<p>1.<code>componentWillReceiveProps(nextProps)</code>，在组件第一次加载渲染之后，如果props数据将要发生改变，那改变之前会先调用这个函数。函数的传参为props改变之后的值。</p>
<p>2.<code>shouldComponentUpdate(nextProps,nextState)</code>，在组件props或state将发生改变，进行更新渲染之前会调用这个函数。函数的传参为props或者state改变之后的值。函数最后返回值一定是布尔值，表示是否重新渲染组件(true为重新渲染，false为阻止渲染)。这里可以判断props或state的值是否达到需要重新渲染组件的要求。这个函数的判断有助于提高页面性能，因为当父组件重新渲染时也会导致其所有子组件重新渲染，所以在组件中做这个判断可以阻止不必要的重新渲染。</p>
<p>3.<code>componentWillUpdate (nextProps,nextState)</code>，在组件调用<code>shouldComponentUpdate(nextProps,nextState)</code>并返回<code>true</code>之后，进行更新渲染之前会调用这个函数。这里同样可以拿到<code>nextProps</code>跟<code>nextState</code>进行操作。</p>
<p>4.<code>render()</code>，这里的渲染就是根据新更新的<code>props</code>跟<code>state</code>的值进行重新创建虚拟DOM，然后在根据diff算法比对新旧DOM数，找到有差异的最小DOM节点，并重新渲染。</p>
<p>5.<code>componentDidUpdate(prevProps,prevState)</code>，在组件重新渲染之后会调用这个函数。函数的传参为props或者state改变之前的值。</p>
<h4 id="组件卸载"><a href="#组件卸载" class="headerlink" title="组件卸载"></a>组件卸载</h4><p>当组件将不再被渲染到页面上时，组件将会被卸载。卸载前只有一个函数会被触发调用：</p>
<p><strong><code>componentWillUnmount ()</code></strong> ，这个函数因为是在组件被卸载前被调用，所以很适合以下一些操作：</p>
<p>1.清除组件内的所有定时<code>setTimeout</code>，<code>setInterval</code>；</p>
<p>2.移除组件内的所有监听事件 <code>removeEventListener</code>；</p>
<p>3.处理未完成的ajax请求。一般ajax请求之后都会修改state，导致会调用组件的<code>setState()</code>，如果组件被卸载的时候ajax请求未完成，会导致请求完成后调用报错，所以可以在组件内设置状态值控制ajax请求完成后是否执行组件内<code>setState()</code>，然后在<code>componentWillUnmount ()</code>中修改状态值。</p>
<h4 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h4><p>这里拓展一下，父子组件的生命周期被调用也是有顺序的。</p>
<p>在组件初次渲染阶段，会从父组件开始，先调用父组件的<code>constructor()</code>构造函数、<code>componentWillMount()</code>，然后接着子组件开始调用这两个函数，直到最底层子组件调用这两个函数。接着调用对底层子组件的<code>componentDidMount()</code>，再一层层往上调用父组件的这个函数，直到最顶层父组件。</p>
<p>在组件的卸载阶段，则会先从最顶层父组件开始调用<code>componentDidUnmount()</code>，直到最底层子组件。</p>
<h4 id="父子组件之间的性能优化"><a href="#父子组件之间的性能优化" class="headerlink" title="父子组件之间的性能优化"></a>父子组件之间的性能优化</h4><p>其实在React中，父组件的数据变化，是会影响子组件进行重新渲染，倒是出现不必要的性能消耗。</p>
<p>前面有说到，可以通过<code>shouldComponentUpdate(nextProps,nextState)</code>函数来判断是否需要重新渲染组件，但这样一来，每个组件都要手动判断重新渲染。每次只要出现父组件传来的数据，包括state状态的变化，都会调用这个函数，也会导致代码冗余。所以React还提供了一种处理方案。</p>
<p>React V15中就引入了<code>React.PureComponent</code>。这个<code>PureComponent</code>跟<code>Component</code>用法上是一样的，只是组件继承了<code>PureComponent</code>类后，组件会自动实现<code>props</code>跟<code>state</code>的浅比较。当组件的<code>props</code>跟<code>state</code>的类型都比较简单的时候，就可以直接使用<code>PureComponent</code>。当如果<code>props</code>跟<code>state</code>是嵌套对象或数组时，浅比较将得不到预期的结果。</p>
<p>关于 React的内容就先把这些基础的先介绍到这里，主要还是要看文档，这里的就算是一些个人整理。下一篇将会介绍style-components插件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/12/React-Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/12/React-Learning/" itemprop="url">react学习总结系列-开篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-12T00:20:52+08:00">
                2018-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面写了好几篇关于Canvas射击小游戏的博文，内容还总结了挺多的。不过其实在写之前主要的时间都在学习react。react是一个很热门的mvc框架，支持的插件非常多，从小页面到大工程都是可以hold得住，所以很有必要学习react并要熟练的使用。所以连着做了两个项目。一个是找了些学习资料边学边做的，是比较简单的简书PC端网页项目，学习完后就去拿豆瓣的数据做了一个简单的豆瓣app。现在打算开始写新的系列博客，把中间学习react的内容做一下整理回顾，把掌握的东西再加强一下。</p>
<p>内容主要涉及react框架及使用过或期间学习过的框架的，有一些内容比较多，会结合代码去说，有一些学得比较浅，就先把项目中有用到的先介绍了，以后在慢慢的深入。再者就是做了两个项目了，对项目的分析跟设计也会想说一下。</p>
<p>先给后面会涉及到的内容做一个列表，然后一项项的完成。</p>
<p>列表：<br>react框架<br>styled-components插件<br>PropTypes插件<br>redux及react-redux插件<br>redux-thunk及redux-saga插件<br>redux-immutable插件<br>react-router-dom插件<br>react-transition-group插件<br>jest测试</p>
<p>列表可能会继续更新，然后下一篇将会从react框架开始。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/12/React-Learning-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/12/React-Learning-I/" itemprop="url">react学习总结系列-react(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-12T00:17:14+08:00">
                2018-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里开始总结一下React。最好了解跟学习react的方法当然是去看react的官方文档，所以这里主要写的是各个知识点需要注意的点。</p>
<h3 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h3><p>JSX语法就是在JS中直接写类似HTML标签，但实际上写的不是HTML代码，这中写法其实是<code>React.creatElement(component, props, ...children)</code>的语法糖。这种语法糖的书写相较于后者的书写更为方便易懂。</p>
<p>代码1 react文档中的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// JSX语法</span><br><span class="line">&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;/MyButton&gt;</span><br><span class="line"></span><br><span class="line">// 编译为:</span><br><span class="line">React.createElement(</span><br><span class="line">  MyButton,</span><br><span class="line">  &#123;color: &apos;blue&apos;, shadowSize: 2&#125;,</span><br><span class="line">  &apos;Click Me&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>react文档有非常详细的介绍，这里主要提一些需要留意的点：</p>
<p>1.<strong>字母大小写</strong>。标签名(组件名)都是驼峰命名法(大驼峰命名法)，后面也会说到的style-component插件也是用这样的写法。</p>
<p>2.<strong>className</strong>。因为JSX语法其实是JS封装的，所以class还是js的关键词。所以在标签中如果要使用class类的话，需要写成className而不是class。写成class也不会影响代码的运行，但是会报一个提示。其他的html标签中使用的属性在JSX中都是小驼峰命名法的写法。</p>
<p>3.<strong>标签之间的值</strong>。如果标签之间没有值，则可以直接一个标签闭合。在html中，有一些标签是单一标签，不用写/闭合也是可以的，但是在JSX中所有标签都需要用<code>/</code>来闭合，所以像input，img都需要写成<code>&lt;input /&gt;</code>、<code>&lt;img /&gt;</code>的闭合形式。如果是标签之间有值，那么支持像html一样直接把字符串写在标签之间，也可以直接写变量，如果遇到数组，可以用map函数枚举数组所有项，但是需要注意的是，标签之间不支持多个语句，最多只支持一个语句。上面用到的map也是一个语句下完成的。不支持if-else判断语句，但是支持三元判断。</p>
<p>4.<strong>获取dom</strong>。react中支持用<code>ref</code>来获取dom对象，但实际上是react封装的一个React对象。如果要获取原生dom对象，可以使用<code>innerRef</code>。(PS: 这一部分其实涉及起来可以有很多内容，不过先知道这些就好，而且一般也建议少用<code>ref</code>)</p>
<p>代码2 获取div的React对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// v16之前写法</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;(myRef) =&gt; &#123;this.myRef = myRef&#125;&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// v16的写法</span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref=&#123;this.myRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.标签中支持写入带html代码的字符串，但是如果直接填入这样的字符串并不会被渲染成相应的内容，因为react也有这方面的安全防御。如果一定要填入这样的字符串，则需要通过<code>dangerouslySetInnerHTML</code>这个属性来传入。`dangerouslySetInnerHTML={{__html: }}`</p>
<p>代码3 在<code>Content</code>组件中传入带HTML代码的字符串<code>this.props.content</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Content dangerouslySetInnerHTML=&#123;&#123;__html: this.props.content&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>6.<strong>JSX语法可以在函数中使用</strong>。一般指函数最后返回的值是直接放在标签中的。其实这些JSX语句在函数中还是以字符串的形式专递的，直到进入<code>render()</code>的return中才会被编译。</p>
<p>7.<strong>属性</strong>。标签中的属性都是小驼峰命名法。属性支持的值可以是各种类型的（包括Function），也可以是一个执行语句，但是一样不支持多语句，判断语句中只支持三元判断。</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>组件是react中一个很重要的概念。首先，从一个用户来说，整个页面可以分为多个信息块，不同的信息块可以获得不同的信息，而从开发者来说，整个页面可以分为多个开发模块，每个模块都是相对独立，互不干扰，而且有些模块可能在整个网站多个页面都会出现。组件其实就是这些开发模块，它拥有属于自己的数据(信息)，根据自己的样式被渲染到页面上。</p>
<p>react中组件的写法很简单，上一篇已经提到了JSX语法，针对的就是react的组件。组件中可以直接书写字符串，非引用类型变量，执行一条语句等，也可以什么都不写，自我闭合。</p>
<p>组件中还可以嵌套子组件，但是前提是子组件必须已经定义或者引入。下面来说一些关于组件开发中的一些需要注意的点：</p>
<p>1.<strong>组件的返回值只能有一个根元素</strong>。组件的返回值如果不只有一个根元素，则编译的时候回出现报错，无法渲染到页面。一般在实现一个组件时，会在最外层用一个html标签包住内容。</p>
<p>2.<strong><code>Fragment</code>组件</strong>。有时候因为一些样式的原因，组件最外层的标签会影响页面显示的效果。这个时候可以考虑使用react提供的方案，<code>Fragment</code>。先把<code>Fragment</code>从react中引入，然后把组件最外层的标签替换成<code>&lt;Fragment&gt;</code>。在编译之后，DOM中将不会出现Fragment组件，组件内部直接渲染出来。这样既减少不必要的<code>div</code>标签，还可以保证一些样式的效果。</p>
<p>3.<strong>React DOM更新</strong>。大家都知道，React是通过虚拟DOM来提高页面性能的。React对DOM的操作其实都是对虚拟DOM的操作。当虚拟DOM的修改完成之后，React在把虚拟DOM跟DOM做比对，把需要更新的部分进行更新。注意，这里是只更新需要更新的部分，其他没变动的部分不会更新。</p>
<p>4.<strong><code>props</code>跟<code>state</code></strong> 。<code>props</code>跟<code>state</code>其实区别还挺明显的，不过这个还是用得越多也清楚这个区别。<code>props</code>可以理解为传入的参数的集合，因为这个集合内的变量都是传入进来的，所以是不可以修改的。<code>state</code>可以 理解问组件自身的属性值集合，这些属性都是会根据不同状态页面的表现而改变，所以是可以修改的，但是需要调用<code>setState()</code>进行修改，不能随意修改。所有的<code>props</code>在组件外传入，包括父组件，url等等，而<code>state</code>是需要在组件的<code>constructor()</code>中先声明后才可以赋值使用。</p>
<p>5.<strong><code>super(props);</code></strong> 。在写<code>constructor()</code>，必须要先写一个语句<code>super(props);</code>。我看网上的解释是因为我们写的组件都是继承父类<code>React.component</code>，而我们在组件中写的<code>constructor()</code>会覆盖掉父类的<code>constructor()</code>，导致你父类构造函数没执行，所以手动执行下。</p>
<p>其他的注意点想到或遇到后更新上来，现在就先写这么多。下一篇会介绍React的父子组件数据传递跟生命周期。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/07/Canvas-Game-VI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/07/Canvas-Game-VI/" itemprop="url">Canvas 射击小游戏详解系列(六)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-07T23:10:00+08:00">
                2018-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML5/" itemprop="url" rel="index">
                    <span itemprop="name">HTML5</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML5/Canvas/" itemprop="url" rel="index">
                    <span itemprop="name">Canvas</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇将介绍页面动画跟项目设计实现。先会对动画做介绍，然后再总结项目中实现动画的设计。</p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>这里说的页面动画指的是js动画，使用<code>requestAnimationFrame()</code>实现。</p>
<p>实现动画效果的原理是把动画拆成一帧帧的画面，当达到每秒至少24帧时，可以给人造成流畅的视觉变化效果。也就算在实现动画效果时，要经历更新画面，清除画面，绘制画面三个部分。</p>
<p>代码1 每个循环的代码逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var animate = function () &#123;</span><br><span class="line">  /* </span><br><span class="line">   * 1.更新下一帧画面，比如移动</span><br><span class="line">   * 2.清除当前页面画面</span><br><span class="line">   * 3.绘制下一帧画面</span><br><span class="line">   */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一步是更新下一帧的画面，处理完一些画面元素的数据调整跟状态调整；第二步是清除当前页面画布，腾出画布空间；第三步绘制下一帧画面，刷新画布内容。</p>
<p>完成三步循环之后，还需要通过<code>requestAnimationFrame()</code>进入下一个循环周期。</p>
<p>另外，既然有动画就需要用暂停或者结束的情况，需要做状态的判断。判断状态转变成暂停或者结束的条件一般有监听事件，碰撞检测，位置范围，超时等等。一般在第一步前判断是否需要更新，调用<code>requestAnimationFrame()</code>前判断是否需要进入下一个循环周期。</p>
<p>最终，一个完整的动画设计就明了了。</p>
<p>代码2 完整的动画代码逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var animate = function () &#123;</span><br><span class="line">  /* </span><br><span class="line">   * 判断条件，选择暂停动画或继续动画</span><br><span class="line">   * 1.更新下一帧画面，比如移动</span><br><span class="line">   * 2.清除当前页面画面</span><br><span class="line">   * 3.绘制下一帧画面</span><br><span class="line">   * 判断条件，选择调用requestAnimationFrame(animate)或结束动画</span><br><span class="line">   */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="项目设计"><a href="#项目设计" class="headerlink" title="项目设计"></a>项目设计</h3><p>项目中的动画主要是在GAME对象中。当玩家点击开始游戏后，会执行<code>play()</code>方法。这个方法会先设置游戏状态，然后重置关卡数据，创建跟初始化画布所有的元素，然后再调用<code>animate()</code>方法。</p>
<h4 id="动画设计"><a href="#动画设计" class="headerlink" title="动画设计"></a>动画设计</h4><h5 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h5><p>进入<code>animate()</code>方法后，先做判断。先判断暂停状态变量是否为真，是则直接在画布上渲染暂停的图标。但是不是真的停下动画，只是让每一帧的渲染都是一样而已。直到暂停状态变量修改成假，就可以给移动量赋值。</p>
<p>在项目中，判断前还需要对键盘对象做一次检测，确认玩家是否有出现键盘事件，再根据不同的键盘事件修改。</p>
<h5 id="更新动画"><a href="#更新动画" class="headerlink" title="更新动画"></a>更新动画</h5><p>完成判断，继续动画时，根据前面得到的移动量，传入到飞机，怪兽类的实例对象中修改坐标位置。调用碰撞测试的方法<code>collision()</code>，判断碰撞是否发生。</p>
<h5 id="清除画布"><a href="#清除画布" class="headerlink" title="清除画布"></a>清除画布</h5><p>参考上一篇，直接使用<code>context.clearRect(0, 0, canvas.width, canvas.height)</code>。</p>
<h5 id="绘制画面"><a href="#绘制画面" class="headerlink" title="绘制画面"></a>绘制画面</h5><p>完成清除之后，调用<code>drawOject()</code>方法。这个方法内部会遍历所有画布的对象，调用对象的绘制方法。</p>
<h5 id="调用requestAnimationFrame-animate"><a href="#调用requestAnimationFrame-animate" class="headerlink" title="调用requestAnimationFrame(animate)"></a>调用<code>requestAnimationFrame(animate)</code></h5><p>这里需要再加一个判断。因为在前面的更新动画中，只是判断了是否暂停，这里判断是否结束动画。前面绘制之后，可能结束的条件是怪兽已经被消灭完或怪兽已经到达底部，其他情况下继续动画，需要调用<code>requestAnimationFrame(animate)</code>。</p>
<h4 id="碰撞设计"><a href="#碰撞设计" class="headerlink" title="碰撞设计"></a>碰撞设计</h4><p>碰撞设计主要是判断两个画布元素是否有重叠，其次是碰撞之后的状态跟动画效果的处理。这里主要讨论碰撞判断。</p>
<p>碰撞的判断到底为画布元素的边界是否有交叉。比如矩形的碰撞判断，为两个矩形的左边界与右边界，上边界与下边界的交叉判断。比如圆形，则是判断两个圆形圆心的距离是否小于两个圆形的半径之和。</p>
<p>如果是考虑矩形跟圆形，则需要判断矩形四个角跟圆形的位置关系及矩形中心到圆心的距离；</p>
<p>如果是考虑矩形缺角或圆形缺弧，则需要判断矩形各个角跟圆心及弧角的位置关系及矩形中心到圆心的距离。</p>
<p>如果是跟复杂的图形，则需要增加参考移动行为。比如项目中的怪兽跟子弹。不管怪兽的形状有多复杂，子弹的移动只有向上一个移动行为，所以主要的判断可以是子弹最上方的坐标是否进入怪兽边界内。</p>
<p>越复杂的碰撞判断，越要参考除了图形之外，其他的因素，比如移动行为，形状变化等等。</p>
<p>以上就是关于项目中动画部分的总结。</p>
<h3 id="系列结语"><a href="#系列结语" class="headerlink" title="系列结语"></a>系列结语</h3><p>整个项目其实整体的重点是动画的流程，怎么实现完整的动画每一帧的代码逻辑。然后拆分成两个问题，怎么渲染游戏元素，怎么设计游戏对象。</p>
<p>这个只是前端的一部分，还需要继续学习。加油！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/05/Canvas-Game-V/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/Canvas-Game-V/" itemprop="url">Canvas 射击小游戏详解系列(五)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T00:32:48+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML5/" itemprop="url" rel="index">
                    <span itemprop="name">HTML5</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML5/Canvas/" itemprop="url" rel="index">
                    <span itemprop="name">Canvas</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇开始介绍Canvas的内容。Canvas是属于HTML5的内容。下面就来介绍一下Canvas。</p>
<h3 id="Canvas元素及画布"><a href="#Canvas元素及画布" class="headerlink" title="Canvas元素及画布"></a>Canvas元素及画布</h3><p>Canvas元素其实写法跟其他的HTML元素写法一样，比如下面的项目中的例子：</p>
<p>代码1 项目中Canvas元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;game&quot; data-status=&quot;start&quot;&gt;  </span><br><span class="line">    &lt;-- 其他代码 !-&gt;</span><br><span class="line">    &lt;canvas id=&quot;canvas&quot; width=&quot;700&quot; height=&quot;600&quot;&gt;</span><br><span class="line">        &lt;!-- 动画画板 --&gt;</span><br><span class="line">    &lt;/canvas&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;-- 其他代码 !-&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>代码1中，Canvas元素在页面上创建了一个宽700，长600的画布，这个就是Canvas实现图形的基础。</p>
<p>然后需要在JavaScript代码中写下这么两行代码：</p>
<p>代码2 获取Canvas对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var canvas = document.getElementById(&apos;canvas&apos;);</span><br><span class="line">var context = canvas.getContext(&apos;2d&apos;);</span><br></pre></td></tr></table></figure></p>
<p>这段代码先是获取了canvas元素，然后在调用canvas元素的getContext方法访问获取2d渲染上下文。得到的context才能进行绘画的操作。</p>
<p>下面是一些关于Canvas的绘制的介绍，因为是基础内容的介绍，所以就主要以代码形式说明。</p>
<h3 id="Canvas绘制"><a href="#Canvas绘制" class="headerlink" title="Canvas绘制"></a>Canvas绘制</h3><p>Canvas绘制分下面几种： 线跟圆弧，几何图形，文本，图片。</p>
<h4 id="绘制原理"><a href="#绘制原理" class="headerlink" title="绘制原理"></a>绘制原理</h4><p>Canvas绘制的原理是把画布坐标化，以左上角为原点，上边为x坐标正方向，左边为y坐标正方向。所有的绘制方法都是context下的方法。</p>
<h4 id="线跟圆弧"><a href="#线跟圆弧" class="headerlink" title="线跟圆弧"></a>线跟圆弧</h4><p>代码1 线跟圆弧的绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* 线的绘制 */</span><br><span class="line">// 设置路径</span><br><span class="line">context.beginPath();</span><br><span class="line">// 设置路径起始点</span><br><span class="line">context.moveTo(320,470);</span><br><span class="line">// 设置路径终点</span><br><span class="line">context.lineTo(320,480);</span><br><span class="line">// 绘制路径</span><br><span class="line">context.stroke();</span><br><span class="line"></span><br><span class="line">/* 圆弧的绘制 */</span><br><span class="line">context.beginPath();</span><br><span class="line">// 圆弧的绘制使用context.arc()方法</span><br><span class="line">// context.arc(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line">// x,y为圆心坐标</span><br><span class="line">// redius为圆的半径</span><br><span class="line">// startAngle，endAngle分别为开始角度跟结束角度（圆的水平右侧为0°）</span><br><span class="line">// anticlockwise为顺/逆时针设置，默认值为false顺时针</span><br><span class="line">context.arc(250, 250, 300, 0, Math.PI, false);</span><br><span class="line">// 绘制路径</span><br><span class="line">context.stroke();</span><br><span class="line">// 使用fill()方法将会把圆弧两端直接闭合填充</span><br><span class="line">// context.fill();</span><br></pre></td></tr></table></figure></p>
<h4 id="几何图形"><a href="#几何图形" class="headerlink" title="几何图形"></a>几何图形</h4><p>代码2 集合多边形跟圆形的绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 矩形的绘制 */</span><br><span class="line">context.beginPath();</span><br><span class="line">context.moveTo(320, 470);</span><br><span class="line">context.lineTo(350, 470);</span><br><span class="line">context.lineTo(350, 500);</span><br><span class="line">context.lineTo(320, 500);</span><br><span class="line">// 设置闭合路径</span><br><span class="line">context.closePath();</span><br><span class="line">context.stroke();</span><br><span class="line">// 填充路径用fill()方法</span><br><span class="line">// context.fill();</span><br><span class="line">// 也可以直接使用矩形的绘制方法context.rect(x, y, width, height);</span><br><span class="line">// context.rect(320, 500, 30, 30);</span><br><span class="line"></span><br><span class="line">/* 圆形的绘制 */</span><br><span class="line">context.beginPath();</span><br><span class="line">//context.arc(250, 250, 300, 0, 2 * Math.PI, false);</span><br><span class="line">// 使用fill()方法将填充整个圆形</span><br><span class="line">// context.fill();</span><br></pre></td></tr></table></figure></p>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>代码3 文本的绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 文本的绘制 */</span><br><span class="line">// 先设置字体样式</span><br><span class="line">context.font = &apos;25px arial&apos;;</span><br><span class="line">// context.strokeText()方法将文本描边绘制</span><br><span class="line">// 三个参数分别为被绘制的字符串，坐标(x,y)</span><br><span class="line">context.strokeText(&quot;描边文本&quot;, 100, 100);</span><br><span class="line">// context.fillText()方法将文本填充绘制</span><br><span class="line">context.fillText(&quot;填充文本&quot;, 100, 100);</span><br></pre></td></tr></table></figure></p>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p>代码4 图片的绘制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 图片的绘制 */</span><br><span class="line">// 设置图片对象</span><br><span class="line">var image = new Image();</span><br><span class="line">// 设置图片地址</span><br><span class="line">image.src = &apos;plane.png&apos;;</span><br><span class="line">// 设置图片加载完成后的回调函数</span><br><span class="line">image.onload = function () &#123;</span><br><span class="line">    // 绘制图片context.drawImage(img, x, y, width, height)</span><br><span class="line">	context.drawImage(image, 50, 50, 60, 100)</span><br><span class="line">	// 裁剪图片也是用context.drawImage(image, source_x, source_y, source_width, source_height, x, y, width, heigh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="样式设置"><a href="#样式设置" class="headerlink" title="样式设置"></a>样式设置</h4><p>代码5 绘制样式设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 描边颜色设置 */</span><br><span class="line">context.fillStyle = #999;</span><br><span class="line"></span><br><span class="line">/* 填充颜色设置 */</span><br><span class="line">context.strokeStyle = #333;</span><br><span class="line"></span><br><span class="line">/* 线宽设置 */</span><br><span class="line">context.lineWidth = (Number);</span><br><span class="line"></span><br><span class="line">/* 设置字体样式 */</span><br><span class="line">context.font = &apos;25px arial&apos;;</span><br></pre></td></tr></table></figure></p>
<h4 id="Canvas擦除"><a href="#Canvas擦除" class="headerlink" title="Canvas擦除"></a>Canvas擦除</h4><p>代码6 绘制擦除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 擦除 */</span><br><span class="line">// 擦除可以使用context.clearRect(x, y, width, height)方法</span><br><span class="line">// 下面直接擦除整个画布</span><br><span class="line">context.clearRect(0, 0, canvas.width, canvas.height);</span><br></pre></td></tr></table></figure></p>
<p>下一篇将会介绍Canvas动画跟项目中的关于Canvas跟动画的设计。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/02/Canvas-Game-IV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/Canvas-Game-IV/" itemprop="url">Canvas 射击小游戏详解系列(四)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T23:32:44+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/对象设计/" itemprop="url" rel="index">
                    <span itemprop="name">对象设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>写着写着内容有点多了，不过还是觉得这些东西记下来还是很有用的。下面开始介绍项目中对象的设计。</p>
<h3 id="项目中主要对象的设计"><a href="#项目中主要对象的设计" class="headerlink" title="项目中主要对象的设计"></a>项目中主要对象的设计</h3><p>整个项目中最重要的是游戏中的三个对象元素：飞机，怪兽，子弹。</p>
<h4 id="元素分析"><a href="#元素分析" class="headerlink" title="元素分析"></a>元素分析</h4><p>飞机支持在画布的底部进行左右的连续移动，移动时依赖玩家的操作，并仅支持左右键的操作。飞机还可以进行射击，玩家点击空格键，上键或Enter键会可以让飞机射击出子弹，并且支持连续射击。</p>
<p>上面总结的飞机行为可以得到，飞机有渲染，移动，临界判断跟射击的功能。需要的参数包括渲染时的画布对象，坐标，飞机图片，飞机尺寸，移动的速度，临界判断的画布上渲染的最大最小x坐标及射击的子弹长度跟移动速度参数。</p>
<p>怪兽只是在画布上部的一个区域进行从上到下蛇形自动移动。被子弹击中会有爆炸效果并消失。</p>
<p>上面总结的怪兽行为可以得到，怪兽有渲染，移动，临界判断的功能。需要的参数包括渲染时的画布对象，坐标，怪兽图片，爆炸图片，怪兽尺寸，移动的速度，临界判断的画布上渲染的最大最小x坐标。怪兽的下移移动不在对象中实现。</p>
<p>子弹通过飞机射击射出，保持一定速度向上移动，如果碰到怪兽会消失，如果一直到达画布顶部也会自动消失。</p>
<p>上面总结的子弹行为可以得到，子弹有渲染，移动，临界判断，清除的功能。需要的参数包括渲染时的画布对象，坐标，子弹长度，移动的速度。临界判断不在对象中设置方法。</p>
<h4 id="对象设计"><a href="#对象设计" class="headerlink" title="对象设计"></a>对象设计</h4><p>通过对三个元素的分析，飞机跟怪兽有可抽象成一致的属性(<code>options</code>属性及<code>context</code>画布)跟方法<code>drawing()</code>，<code>move()</code>，<code>translate()</code>。</p>
<p><code>options</code>传入的参数为JSON对象，包括了大量的参数，如果对象所渲染到画布上的图片，图片渲染的坐标点，图片尺寸，在画布上的可渲染的最大最小x坐标，移动速度等。Plane父类跟Enemy子类的<code>options</code>传入的参数会有差异，但是做了抽象统一。</p>
<p>两个元素的移动可以统一实现，所以我让怪兽的构造函数继承飞机的构造函数。</p>
<p>Enemy类虽然继承了Plane类，但是还是有一些差异点。Plane类中还有一个创建子弹的<code>shoot()</code>方法，这个方法也有被Enemy类继承，但是当前项目中Enemy类的实例并没有使用这个类，是存在代码冗余的问题。但是也支持了项目进一步优化，Enemy类的实例可以进一步提高难度，增加项目的趣味。</p>
<p>Enemy类的方法<code>drawing()</code>做了重写，因为怪兽有一个爆炸的渲染判断，涉及判断是否存活(属性<code>isLive</code>)。</p>
<p>子弹的行为跟前两者不同，虽然也是一样的属性，但是方法基本需要重写，所以不做继承。</p>
<h3 id="键盘对象设计"><a href="#键盘对象设计" class="headerlink" title="键盘对象设计"></a>键盘对象设计</h3><p>因为飞机的移动跟射击都是支持连续，如果只是在Game对象中实现键盘事件监听，实际的移动跟射击都会有卡顿感，所以把键盘事件转换成点击状态，效果上会更加顺畅。</p>
<p>键盘对象包括了左右上键，空格键，Enter键的状态，并把<code>document.onkeydown</code>跟<code>document.onkeyup</code>都指向了自身的方法，在放在中判断键盘按键是否按下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @constructor KeyBoard</span><br><span class="line"> * @description 键盘监听对象</span><br><span class="line"> * @see The &lt;a href=&quot;#&quot;&gt;KeyBoard&lt;/a &gt;.</span><br><span class="line"> * @example </span><br><span class="line"> * this.keyBoard = new KeyBoard();</span><br><span class="line"> */</span><br><span class="line">function KeyBoard () &#123;</span><br><span class="line">  document.onkeydown = this.keydown.bind(this);</span><br><span class="line">  document.onkeyup = this.keyup.bind(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KeyBoard.prototype = &#123;</span><br><span class="line">  pressedLeft: false, // 是否点击左键</span><br><span class="line">  pressedRight: false, // 是否点击右键</span><br><span class="line">  pressedUp: false, // 是否按了上报</span><br><span class="line">  pressedSpace: false, // 是否按了上报</span><br><span class="line">  pressedEnter: false, // 是否按了上报</span><br><span class="line">  keydown: function (event) &#123;</span><br><span class="line">    // 判断哪个按键按下，修改按键状态</span><br><span class="line">  &#125;,</span><br><span class="line">  keyup: function (event) &#123;</span><br><span class="line">    // 判断哪个按键松开，修改按键状态</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除了这几个对象的设计，因为还涉及对象的继承，所以还另外齐起了一个文件common.js放处理继承父类原型对象的函数<code>inheritPrototype()</code>。具体的介绍可以会看上一篇关于继承的介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description 继承父类原型对象的函数</span><br><span class="line"> * @param &#123;Object&#125; subType 子类对象</span><br><span class="line"> * @param &#123;Object&#125; subType 父类对象</span><br><span class="line"> */</span><br><span class="line">var inheritPrototype = function (subType, superType) &#123;</span><br><span class="line">  // 把父类对象的原型对象赋值给proto</span><br><span class="line">  var protoType = Object.create(superType.prototype);</span><br><span class="line">  // proto的constructor指向子类对象，进行重置</span><br><span class="line">  protoType.constructor = subType;</span><br><span class="line">  // 把子类的原型指向原型</span><br><span class="line">  subType.prototype = protoType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于对象中设计到的Canvas的部分，下一篇将介绍。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/02/Canvas-Game-III/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/Canvas-Game-III/" itemprop="url">Canvas 射击小游戏详解系列(三)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T23:21:32+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/对象设计/" itemprop="url" rel="index">
                    <span itemprop="name">对象设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇讲了一下创建对象的三种模式，本篇就来讲一下继承。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>这里说的继承是指构造函数的继承。一般继承是在设计中把一些不同类型的对象的共同点抽象出来，或者是在原有的构造函数中继承出新的构造函数，减少代码冗余。</p>
<p>继承可以使子类拥有父类的属性跟方法，而且不会出现重复的代码。</p>
<p>最简单的方式就是在子类的构造函数中创建一个父类的实例对象，再把子类自有的属性跟对象添加到这个实例对象上，在返回出来。</p>
<p>代码1 项目中怪兽子类继承飞机父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Plane (option, context) &#123;</span><br><span class="line">  this.opts = option;</span><br><span class="line">  this.context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Plane.prototype.drawing = function () &#123;</span><br><span class="line">  // 画布上渲染图片</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Plane.prototype.move = function () &#123;</span><br><span class="line">  // 飞机每帧移动</span><br><span class="line">&#125;</span><br><span class="line">// 其他方法省略</span><br><span class="line"></span><br><span class="line">function Enemy (option, context) &#123;</span><br><span class="line">  this.prototype = new Plane(option, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Enemy.prototype.drawing = function () &#123;</span><br><span class="line">  // 重写方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方案虽然能实现子类对父类的继承，但是出现了以下的几个问题：子类的实例对象的constructor指向了父类的构造函数，原因是子类构造函数中先创建了一个父类的实例对象，这个对象的constructor肯定指向父类的构造函数。<br>因此，在上面的代码基础上，还需要把constructor指向自身，可以解决这个问题了。</p>
<p>代码2 项目中怪兽子类继承的优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Enemy (option, context) &#123;</span><br><span class="line">  this.prototype = new Plane(option, context);</span><br><span class="line">  this.protptype.constructor = Enemy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Enemy.prototype.drawing = function () &#123;</span><br><span class="line">  // 重写方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，这里可以看到，有些方法可能会需要重写，这个问题不大，但是会有属性覆盖父类属性的问题，所以这点也是需要优化的，减少创建出来的对象的冗余。</p>
<p>这里要补充一个，还可以直接通过<code>call()</code>绑定父类构造函数进行继承，但是写在原型上的方法都没法用。但是也是我们参考的一个点</p>
<p>代码3 项目中怪兽子类绑定飞机父类构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Enemy (option, context) &#123;</span><br><span class="line">  Plane.call(this, option, context);</span><br><span class="line">  // 其他省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上的问题点其实都是在如何可以准确的继承父类的方法，减少属性覆盖，又保证子类constructor指向子类的构造函数。这里我用到了这个项目前学习到的继承方案，包括以下的函数</p>
<p>代码4 <code>inheritPrototype()</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description 继承父类原型对象的函数</span><br><span class="line"> * @param &#123;Object&#125; subType 子类对象</span><br><span class="line"> * @param &#123;Object&#125; subType 父类对象</span><br><span class="line"> */</span><br><span class="line">var inheritPrototype = function (subType, superType) &#123;</span><br><span class="line">  // 把父类对象的原型对象赋值给proto</span><br><span class="line">  var protoType = Object.create(superType.prototype);</span><br><span class="line">  // proto的constructor指向子类对象，进行重置</span><br><span class="line">  protoType.constructor = subType;</span><br><span class="line">  // 把子类的原型指向原型</span><br><span class="line">  subType.prototype = protoType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方案利用了构造函数继承跟上面的<code>inheritPrototype()</code>方法。前者继承了父类的属性，后者函数继承了父类原型中的所有方法。最终的效果如下：</p>
<p>代码5 项目中的继承设计<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Plane (option,context) &#123;</span><br><span class="line">  this.opts = option;</span><br><span class="line">  this.context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Plane.prototype.drawing = function () &#123;</span><br><span class="line">  // 画布上渲染图片</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Enemy(options,context) &#123;</span><br><span class="line">  // 继承父类Plane的属性</span><br><span class="line">  Plane.call(this, options, context);</span><br><span class="line">&#125;</span><br><span class="line">// 继承父类Plane的原型</span><br><span class="line">inheritPrototype(Enemy, Plane);</span><br><span class="line"></span><br><span class="line">Enemy.prototype.drawing = function () &#123;</span><br><span class="line">  // 重写方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下一篇介绍项目中对象的设计。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/09/02/Canvas-Game-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/Canvas-Game-II/" itemprop="url">Canvas 射击小游戏详解系列(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T23:16:53+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/对象设计/" itemprop="url" rel="index">
                    <span itemprop="name">对象设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接下来会介绍关于游戏项目中关于对象的设计，但在这之前想先对JavaScript对象做一些总结，然后再介绍项目的对象设计。这里会分三篇介绍。</p>
<h3 id="JavaScript创建对象的三种模式"><a href="#JavaScript创建对象的三种模式" class="headerlink" title="JavaScript创建对象的三种模式"></a>JavaScript创建对象的三种模式</h3><p>js创建对象的三种模式有工厂模式，构造函数模式及原型模式。</p>
<p>其实正常来说，创建一个对象是可以直接声明一个Object类型，但是如果需要创建多个对象的时候，这个方法显然不利于开发。而且很多时候需要创建的对象都有一些相似点，比如同一类型，同样的属性跟方法。如果能有一种方式可以用相同的代码处理创建对象的话，就可以提高代码的性能了。上面提及的三种模式就是解决方案。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式就是通过传参给一个函数方法，在函数中进行对象的创建，赋值，然后返回。</p>
<p>代码1 项目中飞机对象根据工厂模式的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function createPlane (option, context) &#123;</span><br><span class="line">  var plane = new Object();</span><br><span class="line">  plane.opts = option;</span><br><span class="line">  plane.context = context;</span><br><span class="line">  plane.drawing = function () &#123;</span><br><span class="line">    // 画布上渲染图片</span><br><span class="line">  &#125;</span><br><span class="line">  plane.move = function () &#123;</span><br><span class="line">    // 飞机每帧移动</span><br><span class="line">  &#125;</span><br><span class="line">  // 其他方法省略</span><br><span class="line">  return plane;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var plane1 = createPlane(opts, context);</span><br></pre></td></tr></table></figure></p>
<p>这种方式创建对象比较简单，只需要知道创建对象的函数跟传入需要的参数即可。其不足在于两点：工厂模式是通过函数方法来创建对象，而不是通过new方法来创建，这样的创建方式不够直观，还是会有一些冗余的代码；工厂模式所返回的对象，在后面的程序中，无法识别对象类型，只能识别是Object类型。</p>
<p>所以就有了构造函数模式。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>这种模式是先声明一个构造函数，然后通过new来创建对象。</p>
<p>代码2  项目中飞机对象根据工厂模式的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Plane (option, context) &#123;</span><br><span class="line">  this.opts = option;</span><br><span class="line">  this.context = context;</span><br><span class="line">  this.drawing = function () &#123;</span><br><span class="line">    // 画布上渲染图片</span><br><span class="line">  &#125;</span><br><span class="line">  this.move = function () &#123;</span><br><span class="line">    // 飞机每帧移动</span><br><span class="line">  &#125;</span><br><span class="line">  // 其他方法省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var plane2 = new Plane(opts, context);</span><br></pre></td></tr></table></figure></p>
<p>代码2跟代码1的对比中可以发现，工厂模式是在函数内部通过new一个对象再返回，但是构造函数模式中，new是在构造函数外面，而且函数内部是通过this来进行赋值的。</p>
<p>在构造函数模式中，程序是先执行了new关键词，即创建了一个对象。然后把构造函数的作用域赋值给了这个对象，也就是构造函数的this指针指向这个对象。然后执行函数，这期间会把属性跟方法全部赋值给这个对象。最后再把对象返回出来。</p>
<p>构造函数的优点也比较明显，它避免了工厂模式的两个不足。通过构造函数创建的对象，其实就是这个构造函数的一个实例。我们就可以通过<code>instanceof</code>方法判断一个对象的构造函数。</p>
<p>代码3 instanceof判断对象是否是某个构造函数的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(plane2 instanceof Plane); // true</span><br></pre></td></tr></table></figure></p>
<p>不过，构造函数模式也有它的一些不足。构造函数所创建出来的每个实例对象都会包含一些属性跟方法，而方法其实在所有实例对象中的功能都是一样的。而这些方法实际上也是Function的实例对象，这样就出现了不必要的冗余，这些方法应该实现复用。</p>
<p>下面的原型模式就能解决这个不足。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式就是利用到JavaScript中对象的原型prototype来实现的。</p>
<p>每个构造函数上都会有一个属性prototype。prototype就是原型，也是一个对象，而且这个对象prototype是所有通过同一构造函数创建(new)的实例对象所共享的(实际上在浏览器console窗口打印每个实例对象，显示的是属性<code>__proto__</code>指向prototype，实际开发中只要用prototype就好)。prototype下的constructor指向实例对象的构造函数。</p>
<p>代码4 判断实例的prototype<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.isPrototypeOf(object1) // 判断object1挂载的prototype是不是Object的</span><br></pre></td></tr></table></figure></p>
<p>原型模式根据JavaScript的原型原理，在构造函数的基础上，把方法放到了prototype对象下。创建对象的方法跟构造函数模式一样，内部创建对象的流程也差不多，也是先执行new关键词，创建一个对象，然后把函数的this指向这个对象，在执行属性赋值跟方法声明时，把方法都放在this.prototype原型对象中。</p>
<p>代码5 项目中飞机对象根据工厂模式的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Plane (option, context) &#123;</span><br><span class="line">  this.opts = option;</span><br><span class="line">  this.context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Plane.prototype.drawing = function () &#123;</span><br><span class="line">  // 画布上渲染图片</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Plane.prototype.move = function () &#123;</span><br><span class="line">  // 飞机每帧移动</span><br><span class="line">&#125;</span><br><span class="line">// 其他方法省略</span><br><span class="line"></span><br><span class="line">var plane3 = new Plane(opts, context);</span><br></pre></td></tr></table></figure></p>
<p>这样的创建对象模式，可以使构造函数创建的实例对象，共享原型中的方法。但是也会有问题存在，这个问题是共享本身的问题。当所有的实例对象共享原型时，就可能出现数据污染的情况。</p>
<p>数据污染的原因在于JavaScript的数据存储方式。JavaScript的数据分为值类型跟引用类型，值类型就是一个变量储存一个值，而引用类型就是一个变量指向内存的一个地址，这个地址储存一个值。值类型变量的赋值是深赋值，赋值完成后两个变量的操作互不影响，但是引用类型的变量之间的赋值其实是复制了指针，这就导致一个变量对指针指向的值进行修改时，另一个变量的值也会跟着改变，就会出现数据污染。</p>
<p>所以，在使用原型模式时，一般把函数方法放在原型prototype中。</p>
<p>下一篇介绍继承。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://listentolife.github.io/2018/08/16/Canvas-Game-I/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Listentolife">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Listentolife">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/16/Canvas-Game-I/" itemprop="url">Canvas 射击小游戏详解系列(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-16T23:30:14+08:00">
                2018-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/对象设计/" itemprop="url" rel="index">
                    <span itemprop="name">对象设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面根据腾讯的一个项目，自己做了一个Canvas设计小游戏，这个小游戏为玩家操作小飞机射击怪兽。小飞机可以左右移动，然后可以射出子弹。怪兽有若干个，从屏幕上方左右移动，当移动到侧边界会下移一行。如果怪兽存活并移动到与飞机一行，则游戏失败，如果飞机能在此之前射击到所有怪兽，则游戏通关。游戏总共设计6关，每一关难度不一样。</p>
<p>整个项目最初只有一个html文件，一个配置文件及一个app入口文件，入口文件的框架已经建好，主要的功能逻辑代码及对象文件都是自己设计实现的。整个项目的关键点是JavaScript中的面向对象设计跟Canvas。页面的渲染都是通过Canvas进行渲染，然后把整个游戏设计成一个对象，里面的角色及零件也都是设计成一个个的对象。下面就给整个项目做一个详细的分析。</p>
<h2 id="项目整体分析"><a href="#项目整体分析" class="headerlink" title="项目整体分析"></a>项目整体分析</h2><p>虽然项目的框架并不是自己设计的，但是毕竟整个设计还是非常好的，值得我们去分析，所以我就先把整个游戏的框架跟自己的设计做一下分析。</p>
<p>游戏页面分为四个部分，根据游戏的状态进行切换展示：游戏首页，游戏成功页面，游戏失败页面及游戏通关页面，通过状态start, failed, success及all-success来控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data-status=&quot;start&quot;] .game-intro &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  padding-top: 180px;</span><br><span class="line">  background: url(./img/bg.png) no-repeat 430px 180px;</span><br><span class="line">  background-size: 200px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[data-status=&quot;failed&quot;] .game-failed, </span><br><span class="line">[data-status=&quot;success&quot;] .game-success,</span><br><span class="line">[data-status=&quot;all-success&quot;] .game-all-success &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  padding-top: 180px;</span><br><span class="line">  background: url(./img/bg-end.png) no-repeat 380px 190px;</span><br><span class="line">  background-size: 250px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，整个游戏就设计成一个名为GAME的对象进行管理。当页面渲染完之后，GAME对象就会进行初始化，设定最初的状态为start，即展示游戏首页，并初始化四个部分的按钮，设置监听事件。</p>
<p>这就是项目原有的框架部分。后面为我根据框架跟游戏设计实现的部分。</p>
<p>不同的按钮会根据游戏状态设置不同的触发内容，不过因为游戏最初，游戏失败后及游戏通关后重玩的触发内容都是从一个新的游戏开始玩起，所以内容都是初始化游戏数据<code>dataInit()</code>及开始游戏<code>play()</code>，只有游戏通关后继续不需要初始化游戏数据即可进入游戏。</p>
<p>初始化游戏数据<code>dataInit()</code>主要是实现一些游戏的配置数据，比如游戏关卡数，游戏分数及怪兽和飞机的配置数据等。</p>
<p>开始游戏<code>play()</code>操作比较多，所以把步骤都拆分成独立的函数方法：<code>setState()</code>用于设置游戏状态，<code>dataReset()</code>用于重置游戏关卡数据，包括难度，位置及键盘监听，<code>createObject()</code>用于创建初始化画布上的对象，比如小飞机，怪兽等，最后的<code>animate()</code>则设置动画效果，涉及渲染画布上所有对象每一帧的变化及位移，并判断游戏的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">play: function () &#123;</span><br><span class="line">    this.setStatus(&apos;playing&apos;);</span><br><span class="line">    // 重置每一关数据</span><br><span class="line">    this.dataReset();</span><br><span class="line">    // 创建画布上飞机，怪兽军团及分数的初始化对象</span><br><span class="line">    this.createObject();</span><br><span class="line">    // 开始动画</span><br><span class="line">    this.animate();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里就大致的说明了一下这个小游戏项目框架的设计。下一篇会分析项目中对象的设计。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Listentolife</p>
              <p class="site-description motion-element" itemprop="description">Listentolife's Blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archive">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/listentolife" target="_blank" title="GitHub">
                      GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:listentolife@qq.com" target="_blank" title="E-Mail">
                      E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Listentolife</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




<span>&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;</span>
<span id="showDays"></span>

<script>
	var birthDay = new Date('04/23/2018');
	var now = new Date();
	var duration = now.getTime() - birthDay.getTime();
	var total= Math.floor(duration / (1000 * 60 * 60 * 24));
	document.getElementById('showDays').innerHTML='本站已运行' + total + '天';
</script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
